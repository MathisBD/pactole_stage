(**************************************************************************)
(*   Mechanised Framework for Local Interactions & Distributed Algorithms *)
(*   T. Balabonski, P. Courtieu, L. Rieg, X. Urbain                       *)
(*   PACTOLE project                                                      *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence.    *)
(*                                                                        *)
(**************************************************************************)

(**************************************************************************)
(**  Mechanised Framework for Local Interactions & Distributed Algorithms   
                                                                            
     T. Balabonski, P. Courtieu, L. Rieg, X. Urbain                         
                                                                            
     PACTOLE project                                                        
                                                                            
     This file is distributed under the terms of the CeCILL-C licence.      
                                                                          *)
(**************************************************************************)


Require Import Arith.Div2.
Require Import Omega.
Require Export SetoidDec.
Require Export Pactole.Util.Preliminary.
Require Export Pactole.Setting.
Require Export Pactole.Spaces.RealMetricSpace.
Require Export Pactole.Spaces.Similarity.
Require Export Pactole.Models.Similarity.
Close Scope R_scope.
Set Implicit Arguments.


Section GatheringDefinitions.

(** We only require the space to be a real metric space.
    The actual number of robots is arbitrary. *)
Context {T : Type}.
Context `{Location}.
Context {VS : RealVectorSpace location}.
Context {RMS : RealMetricSpace location}.
Context `{Names}.

(** The only information available is the current location.
    The change of frame of reference uses a similarity, so we export [Pactole.Models.Similarity]. *)
Global Instance Info : State location := OnlyLocation.

(** The spectrum and the way updates are made to the robot state are still arbitrary. *)
Context {Spect : Spectrum}.
Context `{robot_choice}.
Context {UC : update_choice T}.
Context `{inactive_choice}.
Context {UpdFun : update_function _ _ T}.
Context {InaFun : inactive_function _}.

Lemma no_info : forall x y, get_location x == get_location y -> x == y.
Proof. now intros. Qed.

Notation "!!" := (fun config => spect_from_config config origin).

(** Not true in general as the info may change even if the robot does not move. *)
Lemma no_moving_same_config : forall r da config,
  moving r da config = List.nil -> round r da config == config.
Proof.
intros r da config Hmove id.
destruct (round r da config id =?= config id) as [Heq | Heq]; trivial; [].
apply <- moving_spec in Heq. rewrite Hmove in Heq. inversion Heq.
Qed.

(** [gathered_at conf pt] means that in configuration [conf] all good robots
    are at the same location [pt] (exactly). *)
Definition gathered_at (pt : location) (config : configuration) := forall g, get_location (config (Good g)) == pt.

(** [Gather pt e] means that at all rounds of (infinite) execution [e],
    robots are gathered at the same position [pt]. *)
Definition Gather (pt: location) (e : execution) : Prop := Stream.forever (Stream.instant (gathered_at pt)) e.

(** [WillGather pt e] means that (infinite) execution [e] is *eventually* [Gather]ed. *)
Definition WillGather (pt : location) (e : execution) : Prop := Stream.eventually (Gather pt) e.

(** [FullSolGathering r d] means that any possible (infinite)
    execution, generated by demon [d] and robogram [r] and any intial
    configuration, will *eventually* be [Gather]ed.
    This is the statement used for the impossiblity proof. *)

Definition FullSolGathering (r : robogram) (d : demon) :=
  forall config : configuration, exists pt : location, WillGather pt (execute r d config).

(** Compatibility properties *)
Global Instance gathered_at_compat : Proper (equiv ==> equiv ==> iff) gathered_at.
Proof.
intros pt1 pt2 Hpt config1 config2 Hconfig. unfold gathered_at.
setoid_rewrite Hconfig. setoid_rewrite Hpt. reflexivity.
Qed.

Global Instance Gather_compat : Proper (equiv ==> equiv ==> iff) Gather.
Proof.
intros pt1 pt2 Hpt. apply Stream.forever_compat, Stream.instant_compat.
intros config1 config2 Hconfig. now rewrite Hpt, Hconfig.
Qed.

Global Instance WillGather_compat : Proper (equiv ==> equiv ==> iff) WillGather.
Proof. intros pt1 pt2 Hpt. apply Stream.eventually_compat. now apply Gather_compat. Qed.

Global Instance FullSolGathering_compat : Proper (equiv ==> equiv ==> iff) FullSolGathering.
Proof.
intros r1 r2 Hr d1 d2 Hd. unfold FullSolGathering.
setoid_rewrite Hr. setoid_rewrite Hd. reflexivity.
Qed.

Lemma gathered_at_dec : forall config pt, {gathered_at pt config} + {~gathered_at pt config}.
Proof.
intros config pt.
destruct (List.forallb (fun g => if config (Good g) =?= pt then true else false) Gnames) eqn:Hall.
+ left. rewrite List.forallb_forall in Hall. intro g.
  specialize (Hall g (In_Gnames _)). revert Hall. destruct_match; tauto || discriminate.
+ right. rewrite <- Bool.negb_true_iff, existsb_forallb, List.existsb_exists in Hall.
  destruct Hall as [g [Hin Heq]].
  revert Heq. destruct_match; simpl; discriminate || intros _.
  intros Habs. specialize (Habs g). contradiction.
Qed.

End GatheringDefinitions.
