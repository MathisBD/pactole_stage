Require Import Bool.
Require Import Reals.
Require Import ConvergentFormalismR.
Require Import EqualitiesR.
Require Import FiniteSumR.
Require Import Morphisms.

Set Implicit Arguments.

(* ************************************* *)
(** * Some necessary results on Reals.   *)
(* ************************************* *)

(** Small dedicated decision tactic for reals handling 1<>0 and r=r *)
Ltac Rdec := repeat
  match goal with
    | |- context[Rdec ?x ?x] =>
        let Heq := fresh "Heq" in destruct (Rdec x x) as [Heq | Heq];
        [clear Heq | exfalso; elim Heq; reflexivity]
    | |- context[Rdec 1 0] => 
        let Heq := fresh "Heq" in destruct (Rdec 1 0) as [Heq | Heq];
        [now elim R1_neq_R0 | clear Heq]
  end.

(** *  The Gathering Problem  **)

(** Vocabulary: we call a [location] the coordinate of a robot. We
    call a [position] a function from robots to position. An
    [execution] is an infinite (coinductive) stream of [position]s. A
    [demon] is an infinite stream of [demonic_action]s. *)

(** ** Some properties related to the gathering problem *)
(** [gathered_at pos pt] means that in position [pos] all robots
    are at the same location [pt] (exactly). *)
Definition gathered_at {G} (pos:G -> location) (pt:location) := forall r:G, pos r = pt.

(** [Gather pt e] means that at all rounds of (infinite) execution
    [e], robots are gathered at the same position [pt]. *)
CoInductive Gather {G} (pt: location) (e : execution G) : Prop :=
  Gathering : gathered_at (execution_head e) pt -> Gather pt (execution_tail e) -> Gather pt e.

(** [WillGather pt e] means that (infinite) execution [e] is
    *eventually* [Gather]ed. *)
Inductive WillGather {G} (pt : location) (e : execution G) : Prop :=
  | Now : Gather pt e -> WillGather pt e
  | Later : WillGather pt (execution_tail e) -> WillGather pt e.

(** [solGathering r d] means that any possible (infinite)
    execution, generated by demon [d] and robogram [r] and any intial
    position, will *eventually* be [Gather]ed. *)
Definition solGathering {G B} (r : robogram G B) (d : demon G B) :=
  forall (gp : G -> location), exists pt : location, WillGather pt (execute r d gp).

(** [Split p] means that position [p] contains to bijective sets of
    robots that do not share positions. *)
Definition Split {G} (p: (G ⊎ G) -> R) :=
  forall x y:G, p (inl x) <> p (inr y).

(** [Always_Split e] means that (infinite) execution [e] is [Split]
    forever. We will prove that with [bad_demon], robots are always
    apart. *)
CoInductive Always_Split {G} (e : execution (G ⊎ G)) :=
  CAD : Split (execution_head e) ->
        Always_Split (execution_tail e) -> Always_Split e.

(** ** Linking the different properties *)

Theorem different_no_gathering : forall (G : finite) (e:execution (G ⊎ G)),
  inhabited G -> Always_Split e -> forall pt, ~WillGather pt e.
Proof.
  intros G e [g] He pt Habs.
  induction Habs.
  - inversion H. inversion He. elim (H2 g g). now do 2 rewrite H0.
  - inversion He. now apply IHHabs.
Qed.

Lemma Always_Split_compat G : forall e1 e2,
  eeq e1 e2 -> @Always_Split G e1 -> Always_Split e2.
Proof.
  coinduction diff.
  - unfold Split in *. intros. rewrite <- H. now destruct H0.
  - destruct H. apply (diff _ _ H1). now destruct H0.
Qed.

Lemma Always_Split_compat_iff G : Proper (eeq ==> iff) (@Always_Split G).
Proof.
  intros e1 e2 He; split; intro.
  - now apply (Always_Split_compat He).
  - now apply (Always_Split_compat (symmetry He)).
Qed.


(** * Framework of the impossibility proof  **)

(** ** Framework for the empty set of byzantine robots **)

(** [Zero] is the (finite) empty set.  *)
Definition Zero : finite.
refine {|
  name := False;
  next := fun fo => match fo with | None => None | Some f => match f with end end;
  prev := fun fo => match fo with | None => None | Some f => match f with end end |}.
Proof.
abstract (now intros [ [] | ] [ [] | ]).
abstract (intros []).
abstract (intros []).
Defined.

(** [Four] is a finite set of size four.  *)

Inductive Four_state :=
  | One4 : Four_state
  | Two4 : Four_state
  | Three4 : Four_state
  | Four4 : Four_state.

Definition Four_next fo := 
  match fo with
    | None => Some One4
    | Some One4 => Some Two4
    | Some Two4 => Some Three4
    | Some Three4 => Some Four4
    | Some Four4 => None
  end.

Definition Four_prev fo := 
  match fo with
    | None => Some Four4
    | Some Four4 => Some Three4
    | Some Three4 => Some Two4
    | Some Two4 => Some One4
    | Some One4 => None
  end.

Lemma Four_NextPrev :
  forall x y : option Four_state, Four_next x = y <-> Four_prev y = x.
Proof. intros [[] |] [[] |]; split; intro H; reflexivity || discriminate H. Qed.

(*Lemma RecNext : forall z : name, Acc NextRel z;
    RecPrev : forall z : name, Acc PrevRel z*)
Lemma Acc_next_1 : Acc (fun x y => Four_next (Some x) = Some y) One4.
Proof. apply Acc_intro. intros [] H; discriminate H. Qed.

Lemma Acc_next_2 : Acc (fun x y => Four_next (Some x) = Some y) Two4.
Proof.
apply Acc_intro. intros [] H; try discriminate H.
exact Acc_next_1.
Qed.

Lemma Acc_next_3 : Acc (fun x y => Four_next (Some x) = Some y) Three4.
Proof.
apply Acc_intro. intros [] H; try discriminate H.
exact Acc_next_2.
Qed.

Lemma Acc_next_4 : Acc (fun x y => Four_next (Some x) = Some y) Four4.
Proof.
apply Acc_intro. intros [] H; try discriminate H.
exact Acc_next_3.
Qed.

Theorem Acc_next : forall f : Four_state, Acc (fun x y => Four_next (Some x) = Some y) f.
Proof.
intros [];
solve[apply Acc_next_1
     | apply Acc_next_2
     | apply Acc_next_3
     | apply Acc_next_4].
Qed.

Lemma Acc_prev_4 : Acc (fun x y => Four_prev (Some x) = Some y) Four4.
Proof. apply Acc_intro. intros [] H; discriminate H. Qed.

Lemma Acc_prev_3 : Acc (fun x y => Four_prev (Some x) = Some y) Three4.
Proof.
apply Acc_intro. intros [] H; try discriminate H.
exact Acc_prev_4.
Qed.

Lemma Acc_prev_2 : Acc (fun x y => Four_prev (Some x) = Some y) Two4.
Proof.
apply Acc_intro. intros [] H; try discriminate H.
exact Acc_prev_3.
Qed.

Lemma Acc_prev_1 : Acc (fun x y => Four_prev (Some x) = Some y) One4.
Proof.
apply Acc_intro. intros [] H; try discriminate H.
exact Acc_prev_2.
Qed.

Theorem Acc_prev : forall f : Four_state, Acc (fun x y => Four_prev (Some x) = Some y) f.
Proof.
intros [];
solve[apply Acc_prev_1
     | apply Acc_prev_2
     | apply Acc_prev_3
     | apply Acc_prev_4].
Qed.

Definition Four : finite := {|
  name := Four_state;
  next := Four_next;
  prev := Four_prev;
  NextPrev := Four_NextPrev;
  RecNext := Acc_next;
  RecPrev := Acc_prev
  |}.

Theorem Four_dec : forall x y : Four, {x = y} + {x <> y}.
Proof. decide equality. Defined.


(** This is the unique function from [Zero] to anything. *)
Definition Zero_fun X : Zero -> X := fun fo => match fo with end.

(** ** Lifting notions from good robots to (good,∅). *)

(** [lift_function f g] lifts two renaming functions, one for good and
    one for bad robots, into a renaming function for any robot. *)
Definition lift_function {G H I J : finite}
  (f : G -> H) (g : I -> J) (id : ident G I): ident H J :=
  match id with
    | Good g => Good H J (f g)
    | Byz b => Byz H J (g b)
  end.

(** Renaming if the set of bad robots is empty.  *)
Definition lift_with_Zero {G H : finite} (f : G -> H) :=
  lift_function f (Zero_fun Zero).

Definition lift_automorphism {G} (σ : automorphism (name G)) :
  automorphism (ident G Zero).
refine {| section := lift_with_Zero σ.(section);
retraction := lift_with_Zero σ.(retraction);
Inversion := _ |}.
Proof.
abstract (intros [x | []] [y | []];
          simpl; split; intro H;
          f_equal; injection H; apply σ.(Inversion)).
Defined.


(** *  Lemmas on Permutations  **)

Lemma permutation_inj : forall T (σ : permutation T) (x y : T), σ x = σ y -> x = y.
Proof.
intros T [σ σ' Hσ] x y Heq. simpl in Heq.
rewrite Hσ in Heq. subst x. now rewrite <- Hσ.
Qed.

Definition permutation_inverse {T} (σ : permutation T) : permutation T.
refine ({|
  section := σ.(retraction);
  retraction := σ.(section)|}).
  abstract (intros; rewrite σ.(Inversion); reflexivity).
Defined.

Notation "σ ⁻¹" := (permutation_inverse σ) (at level 10).
(*
Definition compose {T U V : Type} (f : U -> V) (g : T -> U) := fun x => f (g x).

Instance compose_compat T U V : Proper (ExtEq ==> ExtEq ==> ExtEq) (@compose T U V).
Proof. intros f1 f2 Hf g1 g2 Hg x. unfold compose. now rewrite Hf, Hg. Qed.
*)
Definition compose_perm {T} (σ' σ : permutation T) : permutation T.
refine ({|
  section := fun x => σ' (σ x);
  retraction := fun x => σ⁻¹ (σ'⁻¹ x)|}).
abstract (intros x y; rewrite Inversion; change (retraction σ') with (section (σ' ⁻¹));
rewrite (σ⁻¹).(Inversion); change (retraction (σ ⁻¹)) with (section σ); intuition).
Defined.

Notation "σ₂ '∘∘' σ₁" := (compose_perm σ₂ σ₁) (at level 10).

Definition PermEq {T : Set} (σ σ' : permutation T) := ExtEq σ σ'.

Instance PermEq_equiv T : Equivalence (@PermEq T).
Proof. unfold PermEq. split.
 intro. reflexivity.
 intros ? ? ?. now symmetry.
 intros ? ? ? ? ?. etransitivity; eassumption.
Qed.

Instance ExtEq_perm_bisim (T : Set) : Bisimulation (@permutation T).
Proof. exists PermEq. apply PermEq_equiv. Defined.

Theorem compose_perm_assoc T : forall σ₁ σ₂ σ₃ : permutation T, σ₁ ∘∘ (σ₂ ∘∘ σ₃) ≈ (σ₁ ∘∘ σ₂) ∘∘ σ₃.
Proof. intros ? ? ? ?. reflexivity. Qed.

Theorem compose_inverse_r G B : forall σ, PermEq (σ ∘∘ (σ⁻¹)) (id_perm G B).
Proof. intros σ x. simpl. now rewrite σ.(Inversion). Qed.

Theorem compose_inverse_l G B : forall σ, PermEq (σ⁻¹ ∘∘ σ) (id_perm G B).
Proof. intros σ x. simpl. now rewrite <- σ.(Inversion). Qed.

Theorem compose_id_perm_r G B : forall σ, PermEq (σ ∘∘ (id_perm G B)) σ.
Proof. now intros σ [n | n]. Qed.

Theorem compose_id_perm_l G B : forall σ, PermEq ((id_perm G B) ∘∘ σ) σ.
Proof. now intros σ [n | n]. Qed.

Identity Coercion idPerm : PermEq >-> ExtEq.

Instance PermEq_ExtEq T : Proper (PermEq ==> ExtEq) (@section T).
Proof. intros σ σ' Hσ x. apply Hσ. Qed.

(** ** Exhaustive enumeration of the 24 permutations of 4 elements **)

Definition mk_perm a b c d : Four -> Four := fun x =>
  match x with
    | One4 => a
    | Two4 => b
    | Three4 => c
    | Four4 => d
  end.

Definition mk_perm_inv a b c (d : Four) : Four -> Four := fun x =>
  if Four_dec x a then One4 else
  if Four_dec x b then Two4 else
  if Four_dec x c then Three4 else Four4.

Definition perm1234 : permutation Four.
refine({|
  section := mk_perm One4 Two4 Three4 Four4;
  retraction := mk_perm_inv One4 Two4 Three4 Four4|}).
abstract (intros [] []; unfold mk_perm_inv; simpl; intuition; discriminate).
Defined.

Definition perm1243 : permutation Four.
refine({|
  section := mk_perm One4 Two4 Four4 Three4;
  retraction := mk_perm_inv One4 Two4 Four4 Three4|}).
abstract (intros [] []; unfold mk_perm_inv; simpl; intuition; discriminate).
Defined.

Definition perm1324 : permutation Four.
refine({|
  section := mk_perm One4 Three4 Two4 Four4;
  retraction := mk_perm_inv One4 Three4 Two4 Four4|}).
abstract (intros [] []; unfold mk_perm_inv; simpl; intuition; discriminate).
Defined.

Definition perm1342 : permutation Four.
refine({|
  section := mk_perm One4 Three4 Four4 Two4;
  retraction := mk_perm_inv One4 Three4 Four4 Two4|}).
abstract (intros [] []; unfold mk_perm_inv; simpl; intuition; discriminate).
Defined.

Definition perm1423 : permutation Four.
refine({|
  section := mk_perm One4 Four4 Two4 Three4;
  retraction := mk_perm_inv One4 Four4 Two4 Three4|}).
abstract (intros [] []; unfold mk_perm_inv; simpl; intuition; discriminate).
Defined.

Definition perm1432 : permutation Four.
refine({|
  section := mk_perm One4 Four4 Three4 Two4;
  retraction := mk_perm_inv One4 Four4 Three4 Two4|}).
abstract (intros [] []; unfold mk_perm_inv; simpl; intuition; discriminate).
Defined.

Definition perm2134 : permutation Four.
refine({|
  section := mk_perm Two4 One4 Three4 Four4;
  retraction := mk_perm_inv Two4 One4 Three4 Four4|}).
abstract (intros [] []; unfold mk_perm_inv; simpl; intuition; discriminate).
Defined.

Definition perm2143 : permutation Four.
refine({|
  section := mk_perm Two4 One4 Four4 Three4;
  retraction := mk_perm_inv Two4 One4 Four4 Three4|}).
abstract (intros [] []; unfold mk_perm_inv; simpl; intuition; discriminate).
Defined.

Definition perm2314 : permutation Four.
refine({|
  section := mk_perm Two4 Three4 One4 Four4;
  retraction := mk_perm_inv Two4 Three4 One4 Four4|}).
abstract (intros [] []; unfold mk_perm_inv; simpl; intuition; discriminate).
Defined.

Definition perm2341 : permutation Four.
refine({|
  section := mk_perm Two4 Three4 Four4 One4;
  retraction := mk_perm_inv Two4 Three4 Four4 One4|}).
abstract (intros [] []; unfold mk_perm_inv; simpl; intuition; discriminate).
Defined.

Definition perm2413 : permutation Four.
refine({|
  section := mk_perm Two4 Four4 One4 Three4;
  retraction := mk_perm_inv Two4 Four4 One4 Three4|}).
abstract (intros [] []; unfold mk_perm_inv; simpl; intuition; discriminate).
Defined.

Definition perm2431 : permutation Four.
refine({|
  section := mk_perm Two4 Four4 Three4 One4;
  retraction := mk_perm_inv Two4 Four4 Three4 One4|}).
abstract (intros [] []; unfold mk_perm_inv; simpl; intuition; discriminate).
Defined.

Definition perm3124 : permutation Four.
refine({|
  section := mk_perm Three4 One4 Two4 Four4;
  retraction := mk_perm_inv Three4 One4 Two4 Four4|}).
abstract (intros [] []; unfold mk_perm_inv; simpl; intuition; discriminate).
Defined.

Definition perm3142 : permutation Four.
refine({|
  section := mk_perm Three4 One4 Four4 Two4;
  retraction := mk_perm_inv Three4 One4 Four4 Two4|}).
abstract (intros [] []; unfold mk_perm_inv; simpl; intuition; discriminate).
Defined.

Definition perm3214 : permutation Four.
refine({|
  section := mk_perm Three4 Two4 One4 Four4;
  retraction := mk_perm_inv Three4 Two4 One4 Four4|}).
abstract (intros [] []; unfold mk_perm_inv; simpl; intuition; discriminate).
Defined.

Definition perm3241 : permutation Four.
refine({|
  section := mk_perm Three4 Two4 Four4 One4;
  retraction := mk_perm_inv Three4 Two4 Four4 One4|}).
abstract (intros [] []; unfold mk_perm_inv; simpl; intuition; discriminate).
Defined.

Definition perm3412 : permutation Four.
refine({|
  section := mk_perm Three4 Four4 One4 Two4;
  retraction := mk_perm_inv Three4 Four4 One4 Two4|}).
abstract (intros [] []; unfold mk_perm_inv; simpl; intuition; discriminate).
Defined.

Definition perm3421 : permutation Four.
refine({|
  section := mk_perm Three4 Four4 Two4 One4;
  retraction := mk_perm_inv Three4 Four4 Two4 One4|}).
abstract (intros [] []; unfold mk_perm_inv; simpl; intuition; discriminate).
Defined.

Definition perm4123 : permutation Four.
refine({|
  section := mk_perm Four4 One4 Two4 Three4;
  retraction := mk_perm_inv Four4 One4 Two4 Three4|}).
abstract (intros [] []; unfold mk_perm_inv; simpl; intuition; discriminate).
Defined.

Definition perm4132 : permutation Four.
refine({|
  section := mk_perm Four4 One4 Three4 Two4;
  retraction := mk_perm_inv Four4 One4 Three4 Two4|}).
abstract (intros [] []; unfold mk_perm_inv; simpl; intuition; discriminate).
Defined.

Definition perm4213 : permutation Four.
refine({|
  section := mk_perm Four4 Two4 One4 Three4;
  retraction := mk_perm_inv Four4 Two4 One4 Three4|}).
abstract (intros [] []; unfold mk_perm_inv; simpl; intuition; discriminate).
Defined.

Definition perm4231 : permutation Four.
refine({|
  section := mk_perm Four4 Two4 Three4 One4;
  retraction := mk_perm_inv Four4 Two4 Three4 One4|}).
abstract (intros [] []; unfold mk_perm_inv; simpl; intuition; discriminate).
Defined.

Definition perm4312 : permutation Four.
refine({|
  section := mk_perm Four4 Three4 One4 Two4;
  retraction := mk_perm_inv Four4 Three4 One4 Two4|}).
abstract (intros [] []; unfold mk_perm_inv; simpl; intuition; discriminate).
Defined.

Definition perm4321 : permutation Four.
refine({|
  section := mk_perm Four4 Three4 Two4 One4;
  retraction := mk_perm_inv Four4 Three4 Two4 One4|}).
abstract (intros [] []; unfold mk_perm_inv; simpl; intuition; discriminate).
Defined.

Ltac absurd_perm :=
  match goal with
    | H1 : ?σ ?x = ?z, H2 : ?σ ?y = ?z |- _ =>
        rewrite <- H1 in H2 at 2 || rewrite <- H1 in H2 at 1; apply permutation_inj in H2; discriminate H2
    | _ => idtac
  end.

Theorem decompose_perm4 : forall σ : permutation Four,
  ((σ ≈ perm1234 \/ σ ≈ perm1243) \/ (σ ≈ perm1324 \/ σ ≈ perm1342) \/ (σ ≈ perm1423 \/ σ ≈ perm1432)) \/
  ((σ ≈ perm2134 \/ σ ≈ perm2143) \/ (σ ≈ perm2314 \/ σ ≈ perm2341) \/ (σ ≈ perm2413 \/ σ ≈ perm2431)) \/
  ((σ ≈ perm3124 \/ σ ≈ perm3142) \/ (σ ≈ perm3214 \/ σ ≈ perm3241) \/ (σ ≈ perm3412 \/ σ ≈ perm3421)) \/
  ((σ ≈ perm4123 \/ σ ≈ perm4132) \/ (σ ≈ perm4213 \/ σ ≈ perm4231) \/ (σ ≈ perm4312 \/ σ ≈ perm4321)).
Proof.
intro σ.
case_eq (σ One4); intro Hone; [left | right; left | right; right; left | right; right; right];
case_eq (σ Two4); intro Htwo; case_eq (σ Three4); intro Hthree; case_eq (σ Four4); intro Hfour; absurd_perm.
- left. left. now intros [].
- left. right. now intros [].
- right; left. left. now intros [].
- right; left. right. now intros [].
- right; right. left. now intros [].
- right; right. right. now intros [].
- left. left. now intros [].
- left. right. now intros [].
- right; left. left. now intros [].
- right; left. right. now intros [].
- right; right. left. now intros [].
- right; right. right. now intros [].
- left. left. now intros [].
- left. right. now intros [].
- right; left. left. now intros [].
- right; left. right. now intros [].
- right; right. left. now intros [].
- right; right. right. now intros [].
- left. left. now intros [].
- left. right. now intros [].
- right; left. left. now intros [].
- right; left. right. now intros [].
- right; right. left. now intros [].
- right; right. right. now intros [].
Qed.

Lemma compose_subst_pos G B : forall (p : position G B) σ σ', p ∘ (σ ∘∘ σ') ≈ (p ∘ σ) ∘ σ'.
Proof.
intros p [σ₁ σ₁' Hσ₁] [σ₂ σ₂' Hσ₂]. split; intro n; simpl.
  now destruct (σ₂ (Good G B n)).
  now destruct (σ₂ (Byz G B n)).
Qed.

Instance compose_perm_compat {T} : Proper (PermEq ==> PermEq ==> PermEq) (@compose_perm T).
Proof. intros σ₁ σ₁' Hσ₁ σ₂ σ₂' Hσ₂ x. simpl. now rewrite Hσ₁, Hσ₂. Qed.

Definition project_without_Zero {G} (f : ident G Zero -> ident G Zero) :=
  fun x => match f (Good G Zero x) with | Good y => y | Byz y => match y with end end.

Instance project_without_Zero_compat G : Proper (ExtEq ==> ExtEq) (@project_without_Zero G).
Proof. intros f g Hfg x. unfold project_without_Zero. now rewrite Hfg. Qed.

Lemma project_without_Zero_lemma G : forall (σ : permutation (ident G Zero)) (x y : G),
project_without_Zero σ x = y <-> project_without_Zero (retraction σ) y = x.
Proof.
intros σ x y. destruct σ. simpl.
unfold project_without_Zero. case_eq (retraction (Good _ _ y)); [intros n Hn | intros []].
rewrite <- Inversion in Hn. split; intro.
case_eq (section (Good _ _ x)); [intros m Hm | intros []]. rewrite Hm in H. subst. rewrite <- Hm in Hn.
cut (Good _ _ n = Good _ Zero x). intro H. now injection H.
apply (permutation_inj {| section := section; retraction := retraction; Inversion := Inversion|}). now simpl.
subst. now rewrite Hn.
Qed.

Definition permutation_without_Zero {G} (σ : permutation (ident G Zero)) := {|
  section := project_without_Zero σ;
  retraction := project_without_Zero σ.(retraction);
  Inversion := project_without_Zero_lemma σ |}.

Instance permutation_without_Zero_compat G : Proper (PermEq ==> PermEq) (@permutation_without_Zero G).
Proof. intros σ σ' Hσ x. unfold permutation_without_Zero. simpl. unfold project_without_Zero. now rewrite Hσ. Qed.

(** *  Definitions for 4 robots **)

Definition forbidden pos := exists p1, exists p2, exists σ : permutation (ident Four Zero),
  (pos ∘ σ).(gp) One4 = p1 /\ (pos ∘ σ).(gp) Two4 = p1
  /\ (pos ∘ σ).(gp) Three4 = p2 /\ (pos ∘ σ).(gp) Four4 = p2 /\ p1 <> p2.

Lemma forbidden_invariant_aux : forall p q (σ : permutation (ident Four Zero)),
  p ∘ σ ≈ q -> forbidden q -> forbidden p.
Proof.
intros p q σ Hpos [p1 [p2 [σ' [H1 [H2 [H3 [H4 H5]]]]]]]. rewrite <- Hpos in H1, H2, H3, H4.
rewrite <- compose_subst_pos in H1, H2, H3, H4.
exists p1. exists p2. exists (σ ∘∘ σ'). repeat split; assumption.
Qed.

Lemma forbidden_invariant : forall p q (σ : permutation (ident Four Zero)),
  p ∘ σ ≈ q -> (forbidden q <-> forbidden p).
Proof.
intros p q σ Hσ. split.
  revert Hσ. now apply forbidden_invariant_aux.
  cut (q ∘ σ⁻¹ ≈ p). now apply forbidden_invariant_aux.
  split; intro n. rewrite <- Hσ. rewrite <- compose_subst_pos. now rewrite compose_inverse_r.
  destruct n.
Qed.

Definition center4 (pos : position Four Zero) :=
  (pos.(gp) One4 + pos.(gp) Two4 + pos.(gp) Three4 + pos.(gp) Four4) / 4.

Lemma center4_invariant : forall p q (σ : permutation (ident Four Zero)), p ∘ σ ≈ q -> center4 p = center4 q.
Proof.
intros p q σ [Heq _]. unfold center4.
rewrite <- (Heq One4). rewrite <- (Heq Two4). rewrite <- (Heq Three4). rewrite <- (Heq Four4).
clear Heq. unfold subst_pos; simpl.
case_eq (σ (Good Four Zero One4)); [intros p1 Hp1 | intros []].
case_eq (σ (Good Four Zero Two4)); [intros p2 Hp2 | intros []].
case_eq (σ (Good Four Zero Three4)); [intros p3 Hp3 | intros []].
case_eq (σ (Good Four Zero Four4)); [intros p4 Hp4 | intros []].
simpl. destruct p1, p2, p3, p4;
repeat match goal with
  | H : ?σ ?x = ?σ ?z |- _ => apply permutation_inj in H; discriminate H
  | H1 : ?x = ?z, H2 : ?y = ?z |- _ => setoid_rewrite <- H1 in H2 at 2 || setoid_rewrite <- H1 in H2 at 1
end; field.
Qed.

(** Are robots on a stack **)
Definition has_stack (pos : position Four Zero) : option R :=
  if Rdec (pos.(gp) One4)   (pos.(gp) Two4)   then Some (pos.(gp) One4)   else
  if Rdec (pos.(gp) One4)   (pos.(gp) Three4) then Some (pos.(gp) One4)   else
  if Rdec (pos.(gp) One4)   (pos.(gp) Four4)  then Some (pos.(gp) One4)   else
  if Rdec (pos.(gp) Two4)   (pos.(gp) Three4) then Some (pos.(gp) Two4)   else
  if Rdec (pos.(gp) Two4)   (pos.(gp) Four4)  then Some (pos.(gp) Two4)   else
  if Rdec (pos.(gp) Three4) (pos.(gp) Four4)  then Some (pos.(gp) Three4) else
  None.

Ltac Rdec_full :=
  match goal with
    | |- context[Rdec ?x ?y] =>
      let Heq := fresh "Heq" in let Hneq := fresh "Hneq" in
      destruct (Rdec x y) as [Heq | Hneq]
    | _ => fail
  end.

Ltac rewrite_eqs := match goal with | H : ?x = ?y |- _ => rewrite H in *; move H at top end.

Lemma has_stack_invariant : forall p q (σ : permutation (ident Four Zero)),
  ~forbidden p -> p ∘ σ ≈ q -> has_stack p = has_stack q.
Proof.
intros p q σ Hp [Heq _]. unfold has_stack.
rewrite <- (Heq One4). rewrite <- (Heq Two4). rewrite <- (Heq Three4). rewrite <- (Heq Four4).
clear Heq. unfold subst_pos; simpl.
case_eq (σ (Good Four Zero One4)); [intros p1 Hp1 | intros []].
case_eq (σ (Good Four Zero Two4)); [intros p2 Hp2 | intros []].
case_eq (σ (Good Four Zero Three4)); [intros p3 Hp3 | intros []].
case_eq (σ (Good Four Zero Four4)); [intros p4 Hp4 | intros []].
simpl. destruct p1, p2, p3, p4;
repeat match goal with
  (* change false goal into ⊥ to help congruence *)
  | |- Some ?x = None => exfalso
  (* remove invalid permutations *)
  | H : ?σ ?x = ?σ ?z |- _ => apply permutation_inj in H; discriminate H
  (* rewrite only the last ocurrence to avoid replacing in a left-hand side. *)
  | H1 : ?x = ?z, H2 : ?y = ?z |- _ => setoid_rewrite <- H1 in H2 at 2 || setoid_rewrite <- H1 in H2 at 1
end; repeat (reflexivity || Rdec_full); try congruence; clear dependent σ;
(* are the remaining ones all forbidden? not all, we lack inequalities in some cases *)
try now (elim Hp; exists (gp p One4);
try (exists (gp p Two4); (exists (lift_automorphism perm1234); simpl; now repeat split)
                      || (exists (lift_automorphism perm1324); simpl; now repeat split)
                      || (exists (lift_automorphism perm1423); simpl; now repeat split))).
elim Hp; exists (gp p One4); exists (gp p Three4).
  exists (lift_automorphism perm1234); simpl; repeat split; do 2 rewrite_eqs; now intuition.
elim Hp; exists (gp p One4); exists (gp p Three4).
  exists (lift_automorphism perm1234); simpl; repeat split; do 2 rewrite_eqs; now intuition.
elim Hp; exists (gp p One4); exists (gp p Three4).
  exists (lift_automorphism perm1234); simpl; repeat split; do 2 rewrite_eqs; now intuition.
elim Hp; exists (gp p One4); exists (gp p Three4).
  exists (lift_automorphism perm1234); simpl; repeat split; do 2 try rewrite_eqs; now intuition.
destruct (Rdec (gp p One4) (gp p Three4)).
  congruence.
  elim Hp; exists (gp p One4); exists (gp p Three4).
    exists (lift_automorphism perm1234); simpl; repeat split; do 2 rewrite_eqs; now intuition.
destruct (Rdec (gp p One4) (gp p Three4)).
  congruence.
  elim Hp; exists (gp p One4); exists (gp p Three4).
    exists (lift_automorphism perm1234); simpl; repeat split; do 2 rewrite_eqs; now intuition.
destruct (Rdec (gp p One4) (gp p Three4)).
  congruence.
  elim Hp; exists (gp p One4); exists (gp p Three4).
    exists (lift_automorphism perm1234); simpl; repeat split; do 2 rewrite_eqs; now intuition.
destruct (Rdec (gp p One4) (gp p Three4)).
  congruence.
  elim Hp; exists (gp p One4); exists (gp p Three4).
    exists (lift_automorphism perm1234); simpl; repeat split; do 2 rewrite_eqs; now intuition.
destruct (Rdec (gp p One4) (gp p Three4)).
  congruence.
  elim Hp; exists (gp p One4); exists (gp p Three4).
    exists (lift_automorphism perm1234); simpl; repeat split; do 2 rewrite_eqs; now intuition.
destruct (Rdec (gp p One4) (gp p Three4)).
  congruence.
  elim Hp; exists (gp p One4); exists (gp p Three4).
    exists (lift_automorphism perm1234); simpl; repeat split; do 2 rewrite_eqs; now intuition.
destruct (Rdec (gp p One4) (gp p Three4)).
  congruence.
  elim Hp; exists (gp p One4); exists (gp p Three4).
    exists (lift_automorphism perm1234); simpl; repeat split; try do 2 rewrite_eqs; now intuition.
destruct (Rdec (gp p One4) (gp p Three4)).
  congruence.
  elim Hp; exists (gp p One4); exists (gp p Three4).
    exists (lift_automorphism perm1234); simpl; repeat split; try do 2 rewrite_eqs; now intuition.
Qed.

Ltac Rdec_aux H :=
  match type of H with
    | context[Rdec ?x ?y] =>
      let Heq := fresh "Heq" in let Hneq := fresh "Hneq" in
      destruct (Rdec x y) as [Heq | Hneq]
    | _ => fail
  end.

Lemma has_stack_spec : forall (pos : position Four Zero),
  (exists r, has_stack pos = Some r)
  <-> exists f1 f2 : Four, f1 <> f2 /\ pos.(gp) f1 = pos.(gp) f2.
Proof.
intros pos. split; intro H.
+ destruct H as [r H]. unfold has_stack in H. repeat Rdec_aux H;
  try (do 2 eexists; split; [| apply Heq]); discriminate.
+ unfold has_stack. repeat Rdec_full; try (eexists; reflexivity).
  exfalso. destruct H as [[] [[] [Hdiff Heq]]];
  solve[ now elim Hdiff | contradiction | symmetry in Heq; contradiction].
Qed.

(** ** Sorting 3 and 4 elements **)
Definition Sorted3 abc :=
  let '(a, b, c) := abc in a <= b <= c.
Definition Sorted4 abcd :=
  let '(a, b, c, d) := abcd in a <= b <= c /\ c <= d.

Definition sort3 (Tle_dec : forall x y : R, {x <= y} + {y < x}) a b c :=
  if Tle_dec a b then (* a ≤ b *)
    if Tle_dec b c then (a, b, c)
    else (* a ≤ b, c < b *)
      if Tle_dec a c then (a, c, b) else (c, a, b)
  else (* b < a *)
    if Tle_dec a c then (b, a, c)
    else (* b < a, c < a *)
      if Tle_dec b c then (b, c, a) else (c, b, a).

Ltac Rle_dec :=
  match goal with
    | |- context[Rle_lt_dec ?x ?y] =>
      let Heq := fresh "Heq" in let Hneq := fresh "Hneq" in
      destruct (Rle_lt_dec x y) as [Heq | Hneq]
    | _ => fail
  end.

(*
Definition mk_perm n m p a b c :=
  fun x =>
    if Rdec x a then (* we want the new value at the pos of a *)
      if eq_nat_dec n 1 then a else
      if eq_nat_dec n 2 then b else
      if eq_nat_dec n 3 then c else 0
    else if Rdec x b then (* we want the new value at the pos of b *)
      if eq_nat_dec m 1 then a else
      if eq_nat_dec m 2 then b else
      if eq_nat_dec m 3 then c else 0
    else if Rdec x c then (* we want the new value at the pos of c *)
      if eq_nat_dec p 1 then a else
      if eq_nat_dec p 2 then b else
      if eq_nat_dec p 3 then c else 0
    else 0.

Definition mk_perm_inv n m p a b c :=
  fun x =>
    if Rdec x a then (* we want the new value at the pos of a *)
      if beq_nat n 1 then a else
      if beq_nat m 1 then b else
      if beq_nat m 1 then c else 0
    else if Rdec x b then (* we want the new value at the pos of b *)
      if beq_nat n 2 then a else
      if beq_nat m 2 then a else
      if beq_nat p 2 then c else 0
    else if Rdec x c then (* we want the new value at the pos of c *)
      if beq_nat n 3 then a else
      if beq_nat m 3 then b else
      if beq_nat p 3 then c else 0
    else 0.

Theorem mk_perm_involutive : forall n m p,
  (n = 1 \/ n = 2 \/ n = 3)%nat ->
  (m = 1 \/ m = 2 \/ m = 3)%nat ->
  (p = 1 \/ p = 2 \/ p = 3)%nat ->
  forall a b c x, (x = a \/ x = b \/ x = c) ->
    mk_perm_inv n m p a b c (mk_perm n m p a b c x) = x.
Proof.
intros n m p [ | [ | ]] [ | [ | ]] [ | [ | ]] a b c x [? | [? | ?]];
subst n m p x; unfold mk_perm, mk_perm_inv; simpl.
repeat (reflexivity || subst || match goal with
  | H : ?x <> ?x |- _ => elim H; reflexivity
  | H : context[Rdec ?x ?y] |- _ => destruct (Rdec x y)
  | |- context[Rdec ?x ?y] => destruct (Rdec x y)
end).

Qed.
*)

Theorem sort3_Sorted : forall a b c,
  let '(x, y, z) := sort3 Rle_lt_dec a b c in
  Sorted3 (x, y, z).
(*  /\ exists σ : permutation R, σ a = x /\ σ b = y /\ σ z = c.*)
Proof.
intros a b c. unfold sort3.
repeat Rle_dec; unfold Sorted3; intuition. (*(split; [unfold Sorted3; intuition |]).
+ Definition σ : permutation R.
  refine ({| section := fun x => x; retraction := fun x => x |}).
  abstract intuition. Defined.
  exists σ. intuition.
+ Definition σ : permutation R.
  refine ({| section := fun x => x; retraction := fun x => x |}).
  abstract intuition. Defined.*)
Qed.

Definition sort4 (Tle_dec : forall x y : R, {x <= y} + {y < x}) a b c d :=
  let '(x, y, z) := sort3 Rle_lt_dec a b c in (* x ≤ y ≤ z *)
  if Tle_dec y d then (* y ≤ d *)
    if Tle_dec z d then (x, y, z, d) else (x, y, d, z)
  else (* d < y *)
    if Tle_dec x d then (x, d, y, z) else (d, x, y, z).

Theorem sort4_Sorted : forall a b c d,
  let '(x, y, z, t) := sort4 Rle_lt_dec a b c d in
  Sorted4 (x, y, z, t).
Proof.
intros a b c d. unfold sort4.
assert (H3 := sort3_Sorted a b c).
destruct (sort3 Rle_lt_dec a b c) as [[α β] γ].
destruct H3.
repeat Rle_dec; unfold Sorted4; intuition.
Qed.

Theorem sort4_perm : forall pos, exists σ : permutation (ident Four Zero),
  ((pos ∘ σ).(gp) One4, (pos ∘ σ).(gp) Two4, (pos ∘ σ).(gp) Three4, (pos ∘ σ).(gp) Four4) 
  = sort4 Rle_lt_dec (pos.(gp) One4) (pos.(gp) Two4) (pos.(gp) Three4) (pos.(gp) Four4).
Proof. Admitted.

Lemma sort4_invariant : forall (p q : position Four Zero) σ, p ∘ σ ≈ q ->
  sort4 Rle_lt_dec (p.(gp) One4) (p.(gp) Two4) (p.(gp) Three4) (p.(gp) Four4)
  = sort4 Rle_lt_dec (q.(gp) One4) (q.(gp) Two4) (q.(gp) Three4) (q.(gp) Four4).
Proof.
intros p q σ Hpq. rewrite <- Hpq. simpl.
Admitted.

Corollary sort4_min : forall pos : position Four Zero,
  let '(x, y, z, t) := sort4 Rle_lt_dec (gp pos One4) (gp pos Two4) (gp pos Three4) (gp pos Four4) in
  forall n, x <= locate pos n.
Proof.
intros pos.
assert (Hsort := sort4_Sorted (gp pos One4) (gp pos Two4) (gp pos Three4) (gp pos Four4)).
case_eq (sort4 Rle_lt_dec (gp pos One4) (gp pos Two4) (gp pos Three4) (gp pos Four4)).
intros [[x y] z] t Heq. rewrite Heq in Hsort.
destruct (sort4_perm pos) as [σ Hσ]. rewrite Heq in Hσ. injection Hσ. intros H1 H2 H3 H4.
Admitted.

Corollary sort4_max : forall pos : position Four Zero,
  let '(x, y, z, t) := sort4 Rle_lt_dec (gp pos One4) (gp pos Two4) (gp pos Three4) (gp pos Four4) in
  forall n, locate pos n <= t.
Proof. Admitted.

Definition is_forbidden (pos : position Four Zero) :=
  let '(x, y, z, t) := sort4 Rle_lt_dec (pos.(gp) One4) (pos.(gp) Two4) (pos.(gp) Three4) (pos.(gp) Four4) in
  if Rdec x y then if Rdec z t then if Rdec y z then false else true else false else false.

Theorem is_forbidden_true : forall pos, is_forbidden pos = true <-> forbidden pos.
Proof.
intros pos. unfold is_forbidden,forbidden.
assert (H4sort := sort4_Sorted (gp pos One4) (gp pos Two4) (gp pos Three4) (gp pos Four4)).
assert (H4perm := sort4_perm pos).
destruct (sort4 Rle_lt_dec (gp pos One4) (gp pos Two4) (gp pos Three4) (gp pos Four4))
  as [[[x y] z] t].
destruct H4sort as [[H1 H2] H3]. destruct H4perm as [σ Heq].
repeat Rdec_full; subst.
+ split; intro H. discriminate H. exfalso. clear H1 H2 H3.
  assert (Ht : forall n, locate (pos ∘ σ) n = t). { now intros [[] | []]; simpl; inversion Heq. }
  destruct H as [p1 [p2 [σ' [H1 [H2 [H3 [H4 H5]]]]]]]. elim H5.
  rewrite <- H1, <- H3. rewrite <- compose_id_perm_l. rewrite <- (compose_inverse_r σ).
  rewrite <- compose_perm_assoc. rewrite compose_subst_pos. simpl.
  now do 2 rewrite Ht.
+ split; intro H; try reflexivity.
  exists y. exists t. exists σ. repeat split; inversion Heq; congruence.
+ split; intro H. discriminate H. exfalso. clear H1.
  destruct H as [p1 [p2 [σ' [Hp1 [Hp2 [Hp3 [Hp4 Hp5]]]]]]].
  assert (Hneq2 : y <> t).
  { apply Rlt_not_eq. SearchAbout Rlt. apply Rle_lt_trans with z. assumption.
    destruct (Rdichotomy _ _ Hneq). assumption. exfalso. revert H. now apply Rle_not_gt. }
  case_eq (σ'⁻¹ (σ (Good Four _ Four4))); intros []; intro Hn.
  - assert (Habs : p1 = t).
    { rewrite <- Hp1. simpl. rewrite <- Hn.
      change (locate pos ((σ' ∘∘ (σ' ⁻¹)) (σ (Good Four _ Four4))) = t).
      rewrite compose_inverse_r. simpl. now inversion Heq. }
    rewrite Habs in *. apply Hneq2. inversion Heq. 
(*  - 
  - 
  - 
+ *)
Admitted.

Corollary is_forbidden_false : forall pos, is_forbidden pos = false <-> ~forbidden pos.
Proof. intro pos. assert (Hp := is_forbidden_true pos). destruct (is_forbidden pos); rewrite <- Hp; intuition. Qed.

Definition range b1 b2 (pos : position Four Zero) :=
  forall x, b1 <= gp pos x <= b2.

Definition extremal r (pos : position Four Zero) :=
  exists b, range b (locate pos r) pos \/ range (locate pos r) b pos.

(*
Parameter is_extremal : ident Four Zero -> position Four Zero -> bool.
Hypothesis is_extremal_correct : forall r (pos : position Four Zero),
  is_extremal r pos = true <-> extremal r pos.
*)

Definition is_extremal r (pos : position Four Zero) :=
  let '(x, y, z, t) := sort4 Rle_lt_dec (pos.(gp) One4) (pos.(gp) Two4) (pos.(gp) Three4) (pos.(gp) Four4) in
  if Rdec r x then true else
  if Rdec t r then true else false.

Lemma is_extremal_invariant : forall p q (σ : permutation (ident Four Zero)) x,
  p ∘ σ ≈ q -> is_extremal x p = is_extremal x q.
Proof. intros p q σ x Hσ. unfold is_extremal. now rewrite (sort4_invariant Hσ). Qed.

Theorem is_extremal_correct : forall r (pos : position Four Zero),
  is_extremal (locate pos r) pos = true <-> extremal r pos.
Proof.
unfold is_extremal,extremal. intros [n | []] pos. simpl.
case_eq (sort4 Rle_lt_dec (gp pos One4) (gp pos Two4) (gp pos Three4) (gp pos Four4)); intros [[x y] z] t Hord.
repeat Rdec_full; split; intro H; try (reflexivity || discriminate H);
try solve [reflexivity | discriminate H | right; now intros [] | left; now intros []].
+ clear H. exists t. right. rewrite Heq.
  intro r. split.
    change (x <= locate pos (Good _ _ r)).
    assert (Hmin := sort4_min pos). rewrite Hord in Hmin. apply Hmin.
    change (locate pos (Good _ _ r) <= t).
    assert (Hmax := sort4_max pos). rewrite Hord in Hmax. apply Hmax.
+ clear H. exists x. left. rewrite <- Heq.
  intro r. split.
    change (x <= locate pos (Good _ _ r)).
    assert (Hmin := sort4_min pos). rewrite Hord in Hmin. apply Hmin.
    change (locate pos (Good _ _ r) <= t).
    assert (Hmax := sort4_max pos). rewrite Hord in Hmax. apply Hmax.
+ exfalso. destruct H as [r [Hr | Hr]].
  - elim (Rlt_irrefl t). apply Rle_lt_trans with (gp pos n).
    
    
Qed.

Definition extreme_center (pos : position Four Zero) :=
  let '(x, y, z, t) := sort4 Rle_lt_dec (pos.(gp) One4) (pos.(gp) Two4) (pos.(gp) Three4) (pos.(gp) Four4) in
  (x + y) / 2.

Theorem extreme_center_invariant : forall p q (σ : permutation (ident Four Zero)),
  p ∘ σ ≈ q -> extreme_center p = extreme_center q.
Proof. intros p q σ Hσ. unfold extreme_center. now rewrite (sort4_invariant Hσ). Qed.

Definition robogram4 (pos : position Four Zero) : location :=
  if is_forbidden pos then 0 else
  match has_stack pos with
    | Some p => p
    | None => if is_extremal 0 pos then 0 else extreme_center pos end.

Lemma robogram4_morph : forall (p q : position Four Zero) (σ : permutation _),
  q ≈ p ∘ σ -> robogram4 p = robogram4 q.
Proof.
intros p q σ Hσ. unfold robogram4. case_eq (is_forbidden p); intro Hf.
+ rewrite is_forbidden_true in Hf. symmetry in Hσ.
  rewrite <- (forbidden_invariant σ Hσ) in Hf. rewrite <- is_forbidden_true in Hf. now rewrite Hf.
+ rewrite is_forbidden_false in Hf. symmetry in Hσ. assert (Hff := Hf).
  rewrite <- (forbidden_invariant σ Hσ) in Hff. rewrite <- is_forbidden_false in Hff. rewrite Hff. clear Hff.
  rewrite (has_stack_invariant σ Hf Hσ).
  rewrite (extreme_center_invariant _ Hσ).
  rewrite (is_extremal_invariant σ 0 Hσ).
  reflexivity.
Qed.

Definition robogram := {|
  algo := robogram4;
  AlgoMorph := robogram4_morph |}.

Print Assumptions robogram.