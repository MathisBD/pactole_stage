Require Import Bool.
Require Import Rbase.
Require Import List.
Require Import ConvergentFormalismR.
Require Import EqualitiesR.
Import FiniteSumR.
Require Import Morphisms.
Require Import Psatz.
Import Permutation.
Import Datatypes. (* to overshadow Rlist and its constructors [nil] and [cons] *)
Require FMapWeakList.
Require Import FMultisetMap.
Require Import Preliminary.

Set Implicit Arguments.
Close Scope R_scope.


(** *  The Gathering Problem  **)

(** Vocabulary: we call a [location] the coordinate of a robot. We
    call a [position] a function from robots to position. An
    [execution] is an infinite (coinductive) stream of [position]s. A
    [demon] is an infinite stream of [demonic_action]s. *)

(** ** Framework for the empty set of byzantine robots **)

(** [Zero] is the (finite) empty set.  *)
Definition Zero : finite.
refine {|
  name := False;
  next := fun fo => match fo with | None => None | Some f => match f with end end;
  prev := fun fo => match fo with | None => None | Some f => match f with end end |}.
Proof.
abstract (now intros [ [] | ] [ [] | ]).
abstract (intros []).
abstract (intros []).
Defined.

(** This is the unique function from [Zero] to anything. *)
Definition Zero_fun X : Zero -> X := fun fo => match fo with end.

Lemma Zero_fun_equiv X : forall f : Zero -> X, ExtEq f (Zero_fun X).
Proof. intros f []. Qed.

Lemma ExtEq_Zero_PosEq {G} : forall pos1 pos2 : position G Zero, ExtEq pos1.(gp) pos2.(gp) -> PosEq pos1 pos2.
Proof. intros pos1 pos2 Hext. split; intro n. apply Hext. destruct n. Qed.

(** *** Lifting notions from good robots to (good,∅). *)

(** [lift_function f g] lifts two renaming functions, one for good and
    one for bad robots, into a renaming function for any robot. *)
Definition lift_gp {G : finite} (f : G -> R) := {| gp := f; bp := Zero_fun R |}.
(* It would be great to have it as a coercion between G → location and position,
   but I do not know how to make it work. *)

Instance lift_gp_proper {G : finite} : Proper (ExtEq ==> @PosEq G Zero) lift_gp.
Proof. intros f g Hfg. split. apply Hfg. intros []. Qed.

(** As there is no byzantine robots, a position is caracterized by the locations of good robots only. *)
Lemma lift_gp_equiv  {G} : forall pos : position G Zero, PosEq pos (lift_gp pos.(gp)).
Proof. intros [gp bp]. split; simpl. now intro. now intros []. Qed.


(** ** Some properties related to the gathering problem *)

(** [gathered_at pos pt] means that in position [pos] all robots
    are at the same location [pt] (exactly). *)
Definition gathered_at {G} (pos:G -> location) (pt:location) := forall r:G, pos r = pt.

(** [Gather pt e] means that at all rounds of (infinite) execution
    [e], robots are gathered at the same position [pt]. *)
CoInductive Gather {G} (pt: location) (e : execution G) : Prop :=
  Gathering : gathered_at (execution_head e) pt -> Gather pt (execution_tail e) -> Gather pt e.

(** [WillGather pt e] means that (infinite) execution [e] is
    *eventually* [Gather]ed. *)
Inductive WillGather {G} (pt : location) (e : execution G) : Prop :=
  | Now : Gather pt e -> WillGather pt e
  | Later : WillGather pt (execution_tail e) -> WillGather pt e.

(** When all robots are on two piles od the same height,
    there is no solution to the gathering problem.
    Therefore, we define these positions as [forbidden]. *)
Definition forbidden {G B} (pos : position G B) :=
  exists p1, exists p2, exists n, p1 <> p2 /\ Permutation (nominal_spectrum pos) (alls p1 n ++ alls p2 n).

(** [solGathering r d] means that any possible (infinite)
    execution, generated by demon [d] and robogram [r] and any intial
    position not [forbidden], will *eventually* be [Gather]ed. *)
Definition solGathering {G} (r : robogram) (d : demon G Zero) :=
  forall (gp : G -> location), ~forbidden (lift_gp gp) -> exists pt : location, WillGather pt (execute r d gp).

(** [Split p] means that position [p] contains to bijective sets of
    robots that do not share positions. *)
Definition Split {G} (p: (G ⊎ G) -> R) :=
  forall x y:G, p (inl x) <> p (inr y).

(** [Always_Split e] means that (infinite) execution [e] is [Split]
    forever. We will prove that with [bad_demon], robots are always
    apart. *)
CoInductive Always_Split {G} (e : execution (G ⊎ G)) :=
  CAD : Split (execution_head e) ->
        Always_Split (execution_tail e) -> Always_Split e.

(** ** Linking the different properties *)

Theorem different_no_gathering : forall (G : finite) (e:execution (G ⊎ G)),
  inhabited G -> Always_Split e -> forall pt, ~WillGather pt e.
Proof.
  intros G e [g] He pt Habs.
  induction Habs.
  - inversion H. inversion He. elim (H2 g g). now do 2 rewrite H0.
  - inversion He. now apply IHHabs.
Qed.

Lemma Always_Split_compat G : forall e1 e2,
  eeq e1 e2 -> @Always_Split G e1 -> Always_Split e2.
Proof.
  coinduction diff.
  - unfold Split in *. intros. rewrite <- H. now destruct H0.
  - destruct H. apply (diff _ _ H1). now destruct H0.
Qed.

Lemma Always_Split_compat_iff G : Proper (eeq ==> iff) (@Always_Split G).
Proof.
  intros e1 e2 He; split; intro.
  - now apply (Always_Split_compat He).
  - now apply (Always_Split_compat (symmetry He)).
Qed.


(** * Framework of the impossibility proof  **)

(** [Four] is a finite set of size four.  *)

Inductive Four_state :=
  | One4 : Four_state
  | Two4 : Four_state
  | Three4 : Four_state
  | Four4 : Four_state.

Definition Four_next fo := 
  match fo with
    | None => Some One4
    | Some One4 => Some Two4
    | Some Two4 => Some Three4
    | Some Three4 => Some Four4
    | Some Four4 => None
  end.

Definition Four_prev fo := 
  match fo with
    | None => Some Four4
    | Some Four4 => Some Three4
    | Some Three4 => Some Two4
    | Some Two4 => Some One4
    | Some One4 => None
  end.

Lemma Four_NextPrev :
  forall x y : option Four_state, Four_next x = y <-> Four_prev y = x.
Proof. intros [[] |] [[] |]; split; intro H; reflexivity || discriminate H. Qed.

(*Lemma RecNext : forall z : name, Acc NextRel z;
    RecPrev : forall z : name, Acc PrevRel z*)
Lemma Acc_next_1 : Acc (fun x y => Four_next (Some x) = Some y) One4.
Proof. apply Acc_intro. intros [] H; discriminate H. Qed.

Lemma Acc_next_2 : Acc (fun x y => Four_next (Some x) = Some y) Two4.
Proof.
apply Acc_intro. intros [] H; try discriminate H.
exact Acc_next_1.
Qed.

Lemma Acc_next_3 : Acc (fun x y => Four_next (Some x) = Some y) Three4.
Proof.
apply Acc_intro. intros [] H; try discriminate H.
exact Acc_next_2.
Qed.

Lemma Acc_next_4 : Acc (fun x y => Four_next (Some x) = Some y) Four4.
Proof.
apply Acc_intro. intros [] H; try discriminate H.
exact Acc_next_3.
Qed.

Theorem Acc_next : forall f : Four_state, Acc (fun x y => Four_next (Some x) = Some y) f.
Proof.
intros [];
solve[apply Acc_next_1
     | apply Acc_next_2
     | apply Acc_next_3
     | apply Acc_next_4].
Qed.

Lemma Acc_prev_4 : Acc (fun x y => Four_prev (Some x) = Some y) Four4.
Proof. apply Acc_intro. intros [] H; discriminate H. Qed.

Lemma Acc_prev_3 : Acc (fun x y => Four_prev (Some x) = Some y) Three4.
Proof.
apply Acc_intro. intros [] H; try discriminate H.
exact Acc_prev_4.
Qed.

Lemma Acc_prev_2 : Acc (fun x y => Four_prev (Some x) = Some y) Two4.
Proof.
apply Acc_intro. intros [] H; try discriminate H.
exact Acc_prev_3.
Qed.

Lemma Acc_prev_1 : Acc (fun x y => Four_prev (Some x) = Some y) One4.
Proof.
apply Acc_intro. intros [] H; try discriminate H.
exact Acc_prev_2.
Qed.

Theorem Acc_prev : forall f : Four_state, Acc (fun x y => Four_prev (Some x) = Some y) f.
Proof.
intros [];
solve[apply Acc_prev_1
     | apply Acc_prev_2
     | apply Acc_prev_3
     | apply Acc_prev_4].
Qed.

Definition Four : finite := {|
  name := Four_state;
  next := Four_next;
  prev := Four_prev;
  NextPrev := Four_NextPrev;
  RecNext := Acc_next;
  RecPrev := Acc_prev
  |}.

Theorem Four_dec : forall x y : Four, {x = y} + {x <> y}.
Proof. decide equality. Defined.


(** *  Some result about sorting  *)

Import Mergesort.
Print Module Mergesort.
Print Module Type Orders.TotalLeBool.

Definition Rleb (x y : R) := if Rle_lt_dec x y then true else false.

Lemma Rleb_spec : forall x y, Rleb x y = true <-> Rle x y.
Proof.
intros x y; unfold Rleb; destruct (Rle_lt_dec x y); split; intro H; trivial. inversion H. elim (Rlt_not_le _ _ r H).
Qed.

Corollary Rleb_total : forall x y, Rleb x y = true \/ Rleb y x = true.
Proof.
intros x y. unfold Rleb. destruct (Rle_lt_dec x y).
  now left.
  right. destruct (Rle_lt_dec y x). reflexivity. elim (Rlt_irrefl x). now apply Rlt_trans with y.
Qed.
Local Coercion is_true : bool >-> Sortclass.

Corollary Rleb_trans : Transitive Rleb.
Proof. intros ? ? ?. unfold is_true. setoid_rewrite Rleb_spec. apply Rle_trans. Qed.

Module Rletot : Orders.TotalLeBool with Definition t := R
                                   with Definition leb := Rleb.
  Definition t := R.
  Definition leb := Rleb.
  Definition leb_total := Rleb_total.
End Rletot.

Import Sorted.
Module Rsort := Mergesort.Sort(Rletot).
Print Module Rsort.
Import Rsort.

Ltac Rle_dec :=
  match goal with
    | |- context[Rle_lt_dec ?x ?y] =>
      let Heq := fresh "Heq" in let Hneq := fresh "Hneq" in
      destruct (Rle_lt_dec x y) as [Heq | Hneq]
    | _ => fail
  end.

Theorem StronglySorted_uniq :
  forall l l', StronglySorted Rleb l -> StronglySorted Rleb l' -> Permutation l l' -> l = l'.
Proof.
intros l l' Hl. revert l Hl l'.
apply (StronglySorted_ind (fun l => forall l' : list R, StronglySorted Rleb l' -> Permutation l l' -> l = l')).
+ intros l' _ Hperm. symmetry. now apply Permutation_nil.
+ intros a l Hl IHl Hle l' Hl' Hperm. destruct l' as [| b l'].
  - apply Permutation_nil. now symmetry.
  - assert (a = b). 
    { destruct (Req_dec a b); trivial. apply Rle_antisym.
      - rewrite List.Forall_forall in Hle. rewrite <- Rleb_spec. apply Hle.
        cut (List.In b (a :: l)). now intros [|].
        rewrite Hperm. now left.
      - apply StronglySorted_inv in Hl'. destruct Hl' as [_ Hl'].
        rewrite List.Forall_forall in Hl'. rewrite <- Rleb_spec. apply Hl'.
        cut (List.In a (b :: l')). now intros [Hin | Hin]; try symmetry in Hin.
        rewrite <- Hperm. now left. }
    subst. f_equal. apply IHl. now apply StronglySorted_inv in Hl'.
    now apply Permutation_cons_inv with b.
Qed.

Instance sort_uniq : Proper (@Permutation R ==> eq) sort.
Proof.
intros l l' Hl. apply StronglySorted_uniq.
- apply StronglySorted_sort. exact Rleb_trans.
- apply StronglySorted_sort. exact Rleb_trans.
- transitivity l. symmetry. apply Permuted_sort. transitivity l'. assumption. apply Permuted_sort.
Qed.


Corollary StronglySorted_sort_identity : forall l, StronglySorted Rleb l -> sort l = l.
Proof.
intros l Hl. apply StronglySorted_uniq.
apply StronglySorted_sort. apply Rleb_trans.
assumption.
symmetry. apply Permuted_sort.
Qed.

Corollary sort_idempotent : forall l, sort (sort l) = sort l.
Proof. intros l. apply StronglySorted_sort_identity. apply StronglySorted_sort. apply Rleb_trans. Qed.

Lemma StronglySorted_alls : forall x n, StronglySorted Rleb (alls x n).
Proof.
intros x n. induction n. constructor.
apply SSorted_cons. assumption.
rewrite List.Forall_forall. intros e Hin. apply alls_In in Hin. subst.
unfold is_true. rewrite Rleb_spec. apply Rle_refl.
Qed.

Lemma sort_alls : forall pt n, sort (alls pt n) = alls pt n.
Proof. intros. apply StronglySorted_sort_identity. apply StronglySorted_alls. Qed.

Open Scope R_scope.

Theorem sort_min : forall (s : spectrum) (d x : R), List.In x s ->
  (List.hd d (sort s) <= x)%R.
Proof.
intros s d x Hin.
assert (Hsort := StronglySorted_sort s Rleb_trans).
assert (Hperm := Permuted_sort s).
destruct (sort s).
- symmetry in Hperm. apply Permutation_nil in Hperm. subst. now inversion Hin.
- simpl. rewrite Hperm in Hin. destruct Hin. subst. apply Rle_refl.
  apply StronglySorted_inv in Hsort. destruct Hsort as [Hsort Hmin].
  rewrite List.Forall_forall in Hmin. rewrite <- Rleb_spec. now apply Hmin.
Qed.

Theorem sort_max : forall (s : spectrum) (d x : R), List.In x s ->
  (x <= List.last (sort s) d)%R.
Proof.
intros s d x Hin.
assert (Hsort := StronglySorted_sort s Rleb_trans).
assert (Hperm := Permuted_sort s).
rewrite Hperm in Hin. revert Hsort x Hin. clear Hperm. generalize (sort s).
apply (@StronglySorted_ind R _ (fun l => forall x : R, List.In x l -> x <= List.last l d)).
now intros ? [].
intros a l Hsorted HP Hle x Hin. destruct Hin.
- subst. destruct l. simpl. apply Rle_refl.
  apply Rle_trans with r. inversion_clear Hle. now rewrite <- Rleb_spec. apply HP. now left.
- destruct l. inversion H. now apply HP.
Qed.

Existing Instance Permutation_map_aux_Proper.

Lemma StronglySorted_map_increasing : forall A B (RA : relation A) (RB : relation B) f, Proper (RA ==> RB) f ->
  forall l, StronglySorted RA l -> StronglySorted RB (map f l).
Proof.
intros A B RA RB f Hf l Hl. induction Hl; simpl; constructor.
  assumption.
  induction H; simpl; constructor.
    now apply Hf.
    apply IHForall.
      now inversion_clear Hl.
      now inversion_clear IHHl.
Qed.

Corollary sort_map_increasing : forall f, Proper (Rleb ==> Rleb) f -> forall l, sort (map f l) = map f (sort l).
Proof.
intros f Hf l. rewrite (Permuted_sort l) at 1.
apply StronglySorted_sort_identity, (StronglySorted_map_increasing Hf), (StronglySorted_sort l Rleb_trans).
Qed.

Lemma StronglySorted_map_decreasing : forall A B (RA : relation A) (RB : relation B) f, Proper (RA --> RB) f ->
  forall l, StronglySorted RA l -> StronglySorted RB (rev (map f l)).
Proof.
intros A B RA RB f Hf l Hl. rewrite <- map_rev. induction Hl; simpl.
  now constructor. rewrite map_app.
  SearchAbout StronglySorted app.
Admitted.

Corollary sort_map_decreasing : forall f, Proper (Rleb --> Rleb) f -> forall l, sort (map f l) = rev (map f (sort l)).
Proof.
intros f Hf l. rewrite (Permuted_sort l) at 1. rewrite (Permutation_rev (map f (sort l))) at 1.
apply StronglySorted_sort_identity, (StronglySorted_map_decreasing Hf), (StronglySorted_sort l Rleb_trans).
Qed.

Lemma app_last : forall {A : Type} (d : A) l1 l2, l2 <> nil -> last (l1 ++ l2) d = last l2 d.
Proof.
intros A d l1 l2 Hl2. induction l1; simpl.
  reflexivity.
  assert (l1 ++ l2 <> nil). { intro Habs. apply Hl2. now destruct (app_eq_nil _ _ Habs). }
  destruct (l1 ++ l2). now elim H. assumption.
Qed.

Lemma last_rev_hd : forall {A : Type} (d : A) l, last (rev l) d = hd d l.
Proof. intros A d l. destruct l; simpl. reflexivity. rewrite app_last. reflexivity. discriminate. Qed.

Corollary hd_rev_last : forall {A : Type} (d : A) l, hd d (rev l) = last l d.
Proof. intros A d l. rewrite <- (rev_involutive l) at 2. now rewrite last_rev_hd. Qed.

Close Scope R_scope.

(** *  Definitions for 4 robots **)

Implicit Type pos : position Four Zero.

(* Will not scale! *)
Theorem nominal_spectrum4 : forall pos,
  nominal_spectrum pos = (pos.(gp) Four4) :: (pos.(gp) Three4) :: (pos.(gp) Two4) :: (pos.(gp) One4) :: Datatypes.nil.
Proof.
intros [gp bp]. unfold nominal_spectrum, FiniteSumR.fold_left. simpl.
repeat (rewrite fold_left_from_equation; simpl). now compute.
Qed.

(* It needs to be defined on positions and not only on spectra.
   It is more natural and does not depend on a demon. *)

Instance forbidden_invariant : Proper (@PosEq Four Zero ==> iff) forbidden.
Proof.
intros p1 p2 Heq. split; intros [pt1 [pt2 [n [Hneq Hpt]]]]; 
exists pt1; exists pt2; exists n; split; trivial; now rewrite <- Hpt, Heq.
Qed.

Definition center4 (s : spectrum) := List.fold_left Rplus s R0.

(** **  Are robots on a stack?  **)

Module Rdecidable : DecidableType with Definition t := R
                                  with Definition eq := @Logic.eq R
                                  with Definition eq_dec := Rdec.
  Definition t := R.
  Definition eq := @Logic.eq R.
  Definition eq_refl : forall x : t, eq x x := reflexivity.
  Definition eq_sym : forall x y : t, eq x y -> eq y x := symmetry.
  Definition eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z := transitivity.
  Definition eq_dec : forall x y : t, {eq x y} + {~ eq x y} := Rdec.
End Rdecidable.

Module Mraw : FMultisetsOn Rdecidable := FMultisets FMapWeakList.Make Rdecidable.
Module M := FMultisetFacts Rdecidable Mraw.
Notation "m1  [=]  m2" := (M.eq m1 m2) (at level 70).
Notation "m1  [<=]  m2" := (M.Subset m1 m2) (at level 70).

Lemma pair_dec : forall xn ym : R * nat, {M.eq_pair xn ym} + {~M.eq_pair xn ym}.
Proof.
unfold M.eq_pair. intros [x n] [y m]. compute.
destruct (Rdec x y).
  destruct (eq_nat_dec n m).
    left. now split. 
    right. now intros [? ?].
  right. now intros [? ?].
Qed.

Definition Melt_field_struct : @field_theory M.elt _ _ _ _ _ _ _ _ _ := Rfield.
Add Field Melt_field : Melt_field_struct.

Inductive stackResult :=
  | NoResult (** No robots **)
  | Valid (l : location) (n : nat) (** One majoritary stack of size [n] at location [l]. **)
  | Invalid (n : nat) (** One majoritary stack of size [n] seen at least twice **).

Lemma stackResult_dec : forall x y : stackResult, {x = y} + {x <> y}.
Proof. decide equality. apply eq_nat_dec. apply Rdec. apply eq_nat_dec. Qed.


Definition multiset (s : spectrum) : M.t := List.fold_left (fun acc x => M.add x 1 acc) s M.empty.

Lemma multiset_nil : multiset nil [=] M.empty.
Proof. reflexivity. Qed.

Lemma multiset_cons_aux : forall s x m,
  List.fold_left (fun acc y => M.add y 1 acc) (x :: s) m [=]
  M.add x 1 (List.fold_left (fun acc x => M.add x 1 acc) s m).
Proof.
intro s. induction s; intros x m.
  reflexivity.
  simpl. intro.
  assert (Hf : Proper (M.eq ==> eq ==> M.eq) (fun (acc : M.t) (y : M.elt) => M.add y 1 acc)).
  { clear. intros s1 s2 Hs x y Hxy. now rewrite Hxy, Hs. }
  rewrite (@fold_left_start _ _ Logic.eq M.eq _ _ _ Hf s _ (M.add x 1 (M.add a 1 m)) (M.add_comm _ _ _ _ _)).
  apply IHs.
Qed.

Lemma multiset_cons : forall x s, multiset (x :: s) [=] M.add x 1 (multiset s).
Proof. intros x s y. unfold multiset. now rewrite multiset_cons_aux. Qed.

Lemma multiset_app : forall s s', multiset (s ++ s') [=] M.union (multiset s) (multiset s').
Proof.
induction s; intros s'; simpl.
  now rewrite M.union_empty_l.
  do 2 rewrite multiset_cons. intro x. destruct (Rdec x a).
    subst a. rewrite M.add_spec. rewrite IHs. repeat rewrite M.union_spec. rewrite M.add_spec. omega.
    rewrite M.add_spec'. rewrite IHs. repeat rewrite M.union_spec. rewrite M.add_spec'. reflexivity. auto. auto.
Qed.

Instance multiset_compat : Proper (@Permutation R ==> M.eq) multiset.
Proof.
intro s1. induction s1 as [| x s1]; intros s2 Hperm.
  apply Permutation_nil in Hperm. now subst.
  assert (Hx := Permutation_in_inside x Hperm). destruct Hx as [l1 [l2 Heq]]. now left. subst s2.
  intro y. rewrite multiset_app, M.union_spec. do 2 rewrite multiset_cons.
  destruct (Rdec x y) as [Heq | Hneq].
    subst y. repeat rewrite M.add_spec. rewrite plus_assoc. f_equal. rewrite <- M.union_spec, <- multiset_app.
    apply IHs1. now apply Permutation_cons_app_inv with x.
    repeat rewrite M.add_spec'; trivial. rewrite <- M.union_spec, <- multiset_app.
    apply IHs1. now apply Permutation_cons_app_inv with x.
Qed.

Lemma multiset_Permutation :
  forall x l n, M.multiplicity x (multiset l) = n -> exists l', ~In x l' /\ Permutation l (alls x n ++ l').
Proof.
intros x l. induction l; intros n Hin.
  exists nil. split. now auto. rewrite multiset_nil, M.empty_spec in Hin. subst n. simpl. reflexivity.
  rewrite multiset_cons in Hin. destruct (Rdec a x).
  - subst a. rewrite M.add_spec in Hin. destruct n. omega.
    rewrite plus_comm in Hin. simpl in Hin. apply eq_add_S in Hin. apply IHl in Hin. destruct Hin as [l' [Hl1 Hl2]].
    exists l'. split. assumption. simpl. now constructor.
  - rewrite M.add_spec' in Hin; trivial. apply IHl in Hin. destruct Hin as [l' [Hl1 Hl2]].
    exists (a :: l'). split. intros [|]; contradiction.
    transitivity (a :: alls x n ++ l'); now constructor || apply Permutation_middle.
Qed.

Lemma multiset_alls : forall x n, n > 0 -> multiset (alls x n) [=] M.singleton x n.
Proof.
intros x n Hn. induction n. omega. clear Hn. simpl. rewrite multiset_cons. destruct n.
  rewrite multiset_nil. setoid_rewrite <- M.union_empty_r at 3. now rewrite M.add_union_singleton.
  rewrite IHn; try omega. intro y. rewrite M.singleton_spec.
  destruct (Rdecidable.eq_dec y x) as [Heq |] eqn:Hxy.
    rewrite Heq in *. rewrite M.add_spec. rewrite M.singleton_spec. rewrite Hxy. omega.
    rewrite M.add_spec'. rewrite M.singleton_spec. now rewrite Hxy. auto.
Qed.

Corollary multiset_In : forall x l, M.multiplicity x (multiset l) > 0 <-> In x l.
Proof.
intros x l. split; intro Hl.
- destruct (multiset_Permutation _ (eq_refl (M.multiplicity x (multiset l)))) as [l' [Hl' Hperm]].
  rewrite Hperm. rewrite in_app_iff. left. destruct (M.multiplicity x (multiset l)). omega. now left.
- induction l. now inversion Hl. rewrite multiset_cons. destruct (Rdec a x).
    subst a. rewrite M.add_spec. omega.
    rewrite M.add_spec'; trivial. apply IHl. now inversion_clear Hl.
Qed.


Definition f_majority :=
  fun x n res =>
    match res with
      | NoResult => Valid x n
      | Valid y m => match nat_compare n m with
         | Lt => Valid y m
         | Eq => Invalid m
         | Gt => Valid x n
        end
      | Invalid m => match nat_compare n m with
         | Lt => Invalid m
         | Eq => Invalid m
         | Gt => Valid x n
        end
    end.

Lemma f_majority_comm : forall x y n m a, f_majority y m (f_majority x n a) = f_majority x n (f_majority y m a).
Proof.
intros x y n m [| l r | r]; unfold f_majority.
  + destruct (nat_compare n m) eqn:Hnm.
    - rewrite nat_compare_Eq_comm in Hnm. rewrite Hnm. rewrite nat_compare_eq_iff in Hnm. now subst.
    - rewrite nat_compare_Lt_Gt in Hnm. now rewrite Hnm.
    - rewrite <- nat_compare_Lt_Gt in Hnm. now rewrite Hnm.
  + destruct (nat_compare n r) eqn: Hnr.
    - destruct (nat_compare m r) eqn: Hmr.
        now rewrite Hnr.
        now rewrite Hnr.
        rewrite nat_compare_eq_iff in Hnr. subst r. rewrite <- nat_compare_Lt_Gt in Hmr. now rewrite Hmr.
    - destruct (nat_compare m r) eqn: Hmr.
        now rewrite Hnr.
        now rewrite Hnr.
        rewrite <- nat_compare_lt in Hnr. rewrite <- nat_compare_gt in Hmr.
        assert (Hnm : (n < m)%nat) by (now transitivity r). rewrite nat_compare_lt in Hnm. now rewrite Hnm.
    - destruct (nat_compare m r) eqn: Hmr.
        rewrite nat_compare_eq_iff in Hmr. subst r. rewrite Hnr. rewrite <- nat_compare_Lt_Gt in Hnr. now rewrite Hnr.
        rewrite Hnr. rewrite <- nat_compare_gt in Hnr. rewrite <- nat_compare_lt in Hmr.
        assert (Hmn : (m < n)%nat) by (now transitivity r). rewrite nat_compare_lt in Hmn. now rewrite Hmn.
        destruct (nat_compare n m) eqn:Hnm.
          rewrite nat_compare_Eq_comm in Hnm. rewrite Hnm. rewrite nat_compare_eq_iff in Hnm. now subst.
          rewrite nat_compare_Lt_Gt in Hnm. now rewrite Hnm.
          rewrite <- nat_compare_Lt_Gt in Hnm. now rewrite Hnm.
  + destruct (nat_compare n r) eqn: Hnr.
    - destruct (nat_compare m r) eqn: Hmr.
        now rewrite Hnr.
        now rewrite Hnr.
        rewrite nat_compare_eq_iff in Hnr. subst r. rewrite <- nat_compare_Lt_Gt in Hmr. now rewrite Hmr.
    - destruct (nat_compare m r) eqn: Hmr.
        now rewrite Hnr.
        now rewrite Hnr.
        rewrite <- nat_compare_lt in Hnr. rewrite <- nat_compare_gt in Hmr.
        assert (Hnm : (n < m)%nat) by (now transitivity r). rewrite nat_compare_lt in Hnm. now rewrite Hnm.
    - destruct (nat_compare m r) eqn: Hmr.
        rewrite nat_compare_eq_iff in Hmr. subst r. rewrite Hnr. rewrite <- nat_compare_Lt_Gt in Hnr. now rewrite Hnr.
        rewrite Hnr. rewrite <- nat_compare_gt in Hnr. rewrite <- nat_compare_lt in Hmr.
        assert (Hmn : (m < n)%nat) by (now transitivity r). rewrite nat_compare_lt in Hmn. now rewrite Hmn.
        destruct (nat_compare n m) eqn:Hnm.
          rewrite nat_compare_Eq_comm in Hnm. rewrite Hnm. rewrite nat_compare_eq_iff in Hnm. now subst.
          rewrite nat_compare_Lt_Gt in Hnm. now rewrite Hnm.
          rewrite <- nat_compare_Lt_Gt in Hnm. now rewrite Hnm.
Qed.

Instance f_majority_compat : Proper (M.eq ==> eq ==> eq) (M.fold f_majority).
Proof.
apply M.fold_compat.
  now auto with typeclass_instances.
  now repeat intro; subst.
  exact f_majority_comm.
Qed.

Definition majority_stack (s : spectrum) : stackResult := M.fold f_majority (multiset s) NoResult.

Instance majority_stack_invariant : Proper (@Permutation R ==> eq) majority_stack.
Proof.
intros s1 s2 Hperm. unfold majority_stack. apply M.fold_compat.
  now auto with typeclass_instances.
  now repeat intro; subst.
  exact f_majority_comm.
  now rewrite Hperm.
  reflexivity.
Qed.

Lemma majority_stack_nil : majority_stack nil = NoResult.
Proof. unfold majority_stack. now rewrite multiset_nil, M.fold_empty. Qed.

(* Both Stack and has_dups should be changed to output the position of the highest stack, *if it is unique*.
   This probably requires multisets to define it propertly. *)
Definition Stack pos :=
  exists x, exists n, M.multiplicity x (multiset (nominal_spectrum pos)) = n
  /\ forall y, x <> y -> (M.multiplicity y (multiset (nominal_spectrum pos)) < n)%nat.

Instance Stack_proper : Proper (@PosEq Four Zero ==> iff) Stack.
Proof. intros ? ? Hpos. unfold Stack. now setoid_rewrite Hpos. Qed.


(** Two stack of robots of the same size. **)
Definition is_forbidden (s : spectrum) :=
  match s with
    | nil => false
    | x :: l =>
      match remove Rdec x l with
        | nil => false
        | y :: l' =>
          match remove Rdec y l' with
            | nil => beq_nat (count_occ Rdec s x) (count_occ Rdec s y)
            | _ => false
          end
      end
  end.

Ltac Rdec_full :=
  match goal with
    | |- context[Rdec ?x ?y] =>
      let Heq := fresh "Heq" in let Hneq := fresh "Hneq" in
      destruct (Rdec x y) as [Heq | Hneq]
    | _ => fail
  end.

Lemma majority_stack_NoResult_spec_aux : forall m r, 
  M.fold f_majority m r = NoResult <-> M.Empty m /\ r = NoResult.
Proof.
intros m r. rewrite M.fold_spec, <- M.elements_nil. split; intro H.
+ revert r H. induction (M.elements m); intros r H.
  - simpl in H. now split.
  - exfalso. simpl in H. apply IHl in H. destruct H as [_ H].
    destruct a, r; simpl in H; discriminate H || (destruct (nat_compare n n0); discriminate H).
+ destruct H as [H1 H2]. subst r. rewrite H1. reflexivity.
Qed.

Corollary majority_stack_NoResult_spec : forall m, majority_stack m = NoResult <-> m = nil.
Proof.
intro m. unfold majority_stack. rewrite majority_stack_NoResult_spec_aux. split; intro H.
  destruct m.
    reflexivity.
    destruct H as [H1 H2]. exfalso. cut (0 = S (M.multiplicity r (multiset m)))%nat. omega.
    rewrite <- (H1 r) at 1. rewrite multiset_cons, M.add_spec. omega.
  subst m. split.
    rewrite multiset_nil. apply M.empty_spec.
    reflexivity.
Qed.

Lemma majority_stack_Valid_0_aux : forall x m r, 
  M.fold f_majority m r = Valid x 0 <-> M.Empty m /\ r = Valid x 0.
Proof.
intros x m r. rewrite M.fold_spec. rewrite <- M.elements_nil.
assert (Hm : forall xn, InA M.eq_pair xn (M.elements m) -> M.multiplicity (fst xn) m = snd xn /\ (snd xn > 0)%nat)
by (intro; apply M.elements_spec).
revert r. induction (M.elements m); simpl; intro r.
  now intuition.
  rewrite IHl. clear IHl.
    split; intros [H1 H2]; exfalso.
      subst l. destruct a, r; simpl in H2.
        specialize (Hm (e, n)). inversion H2. subst e n. clear H2. apply (lt_irrefl 0). apply Hm. now left.
        destruct (nat_compare n n0) eqn:Hn.
          discriminate H2.
          inversion H2. subst. clear H2. rewrite <- nat_compare_lt in Hn. now inversion Hn.
          inversion H2. subst. clear H2. rewrite <- nat_compare_gt in Hn. now inversion Hn.
        destruct (nat_compare n n0) eqn:Hn.
          discriminate H2.
          discriminate H2.
          inversion H2. subst. clear H2. rewrite <- nat_compare_gt in Hn. now inversion Hn.
      now inversion H1.
    intros xn Hin. apply Hm. now right. 
Qed.

Corollary majority_stack_Valid_0 : forall m x, majority_stack m <> Valid x 0.
Proof.
unfold majority_stack. intros m x H. rewrite majority_stack_Valid_0_aux in H. destruct H as [_ H]. discriminate H.
Qed.

Lemma majority_stack_Valid_spec_aux : forall x n m r, (n > 0)%nat ->
  (M.fold f_majority m r = Valid x n <->
  (r = Valid x n /\ (forall y, (M.multiplicity y m < n)%nat)
   \/ M.multiplicity x m = n /\ (forall y m, (r = Valid y m \/ r = Invalid m) -> m < n)%nat
      /\ forall y, x <> y -> (M.multiplicity y m < n)%nat)).
Proof.
intros x n m r Hn. rewrite M.fold_spec.
assert (Hm : ((r = Valid x n /\ forall y, (M.multiplicity y m < n)%nat)
          \/ M.multiplicity x m = n /\ (forall y m, (r = Valid y m \/ r = Invalid m) -> m < n)%nat
             /\ forall y, x <> y -> (M.multiplicity y m < n)%nat)
        <-> (r = Valid x n /\ (forall y n', InA M.eq_pair (y, n') (M.elements m) -> n' < n)%nat
             \/ InA M.eq_pair (x, n) (M.elements m) /\ (forall y m, (r = Valid y m \/ r = Invalid m) -> m < n)%nat
             /\ (forall y n', x <> y -> InA M.eq_pair (y, n') (M.elements m) -> n' < n)%nat)).
{ split; intros [[H1 H2] | [H1 [H2 H3]]].
  + left. split.
    - assumption.
    - intros y n' Hin. rewrite M.elements_spec in Hin.
      destruct Hin as [Hin Hpos]. simpl in Hin. rewrite <- Hin. apply H2.
  + right. repeat split.
    - rewrite M.elements_spec. now repeat split.
    - assumption.
    - intros y n' Hneq Hin. rewrite M.elements_spec in Hin. destruct Hin as [Hin Hpos].
      simpl in Hin. rewrite <- Hin. apply H3. assumption.
  + left. split.
    - assumption.
    - intro y. destruct (InA_dec pair_dec (y, M.multiplicity y m) (M.elements m)) as [Hin | Hin].
        now apply (H2 y (M.multiplicity y m)).
        rewrite M.elements_spec in Hin.
        assert (M.multiplicity y m = 0%nat). {cut (~M.multiplicity y m > 0)%nat. clear. omega. now auto. }
        now rewrite H.
  + right. repeat split.
    - rewrite M.elements_spec in H1. now destruct H1.
    - assumption.
    - intros y Hneq. destruct (InA_dec pair_dec (y, M.multiplicity y m) (M.elements m)) as [Hin | Hin].
        now apply (H3 y (M.multiplicity y m)).
        rewrite M.elements_spec in Hin.
        assert (M.multiplicity y m = 0%nat). {cut (~M.multiplicity y m > 0)%nat. clear. omega. now auto. }
        now rewrite H. }
rewrite Hm. clear Hm.
assert (Hdup := M.elements_NoDupA m).
revert r. induction (M.elements m) as [| [x' n'] l]; intro r.
* simpl. split; intro H.
    left. split. assumption. intros p Habs. now inversion Habs.
    destruct H as [[H _] | [H _]]. assumption. now inversion H.
* simpl. inversion_clear Hdup. rename H into Hnin. rename H0 into Hdup.
  rewrite IHl; trivial. clear IHl. split; intros [[H1 H2] | [H1 [H2 H3]]].
  + destruct r eqn:Hr; simpl in H1.
    - right. destruct (pair_dec (x, n) (x', n')) as [Heq | Hneq].
        repeat split.
          now left.
          intros ? ? [H | H]; discriminate H.
          intros y p Hxy Hin. inversion_clear Hin.
            exfalso. apply Hxy. now compute in H, Heq; destruct H, Heq; subst.
            now apply (H2 y).
        elim Hneq. compute. inversion_clear H1. now split.
    - destruct (nat_compare n' n0) eqn:Hnn.
        now inversion_clear H1.
        inversion H1. subst l0 n0. clear H1. left. rewrite <- nat_compare_lt in Hnn. split.
          reflexivity.
          intros y p Hin. inversion_clear Hin.
            destruct H as [_ H]. compute in H. now subst n'.
            now apply (H2 y).
        inversion H1. subst x' n'. clear H1. right. repeat split.
          now left.
          intros y p [Habs | Habs]; inversion Habs. subst l0 n0. clear Habs. now rewrite <- nat_compare_gt in Hnn.
          intros y p Hneq Hin. inversion_clear Hin.
          destruct H as [H _]. compute in H. now elim Hneq.
          now apply (H2 y).
    - right. destruct (nat_compare n' n0) eqn:Hnn.
        now inversion_clear H1.
        now inversion_clear H1.
        inversion H1. subst x' n'. clear H1. repeat split.
          now left.
          intros ? ? [H | H]. discriminate H. inversion H. subst m0. clear H. now rewrite <- nat_compare_gt in Hnn.
          intros y p Hneq Hin. inversion_clear Hin.
            compute in H. destruct H. now elim Hneq.
            now apply (H2 y).
  + destruct r eqn:Hr; simpl in H1.
    - right. destruct (pair_dec (x, n) (x', n')) as [Heq | Hneq].
        repeat split.
          now left.
          intros ? ? [H | H]; discriminate H.
          intros y p Hxy Hin. inversion_clear Hin.
            exfalso. apply Hxy. now compute in H, Heq; destruct H, Heq; subst.
            now apply (H3 y).
        repeat split. 
          now right.
          intros ? ? [H | H]; discriminate H.
          intros y p Hxy Hin. inversion_clear Hin.
            compute in H; destruct H; subst. simpl in H2. apply (H2 x'). now left.
            now apply (H3 y).
    - simpl in H2. destruct (nat_compare n' n0) eqn:Hnn.
        right. rewrite nat_compare_eq_iff in Hnn. subst n0. repeat split.
          now right.
          intros y m' [Heq | Habs].
            inversion Heq. subst m' l0. clear Heq. apply (H2 y). now right.
            now inversion Habs.
          intros y p Hxy Hin. inversion_clear Hin.
            compute in H; destruct H; subst. apply (H2 x'). now right.
            now apply (H3 y). 
        rewrite <- nat_compare_lt in Hnn. destruct (pair_dec (x, n) (l0, n0)) as [Heq | Hneq].
          compute in Heq; destruct Heq; subst. elim (lt_irrefl n0). apply (H2 l0). now left.
          right. repeat split.
            now right.
            intros y p [Hin | Hin]; inversion Hin. subst l0 n0. clear Hin. apply (H2 y). now left.
            intros y p Hxy Hin. inversion_clear Hin.
              compute in H; destruct H; subst. transitivity n0. assumption. apply (H2 l0). now left.
              now apply (H3 y).
        rewrite <- nat_compare_gt in Hnn. right. repeat split.
          now right.
          intros y p [Hin | Hin]; inversion Hin. subst. transitivity n'. assumption. apply (H2 x'). now left.
          intros y p Hxy Hin. inversion_clear Hin.
            compute in H; destruct H; subst. apply (H2 x'). now left.
            now apply (H3 y).
    - right. repeat split.
        now right.
        intros y p [Hin | Hin]; inversion Hin; subst; clear Hin. simpl in H2. destruct (nat_compare n' p) eqn:Hnp.
          apply (H2 y). now right.
          apply (H2 y). now right.
          transitivity n'.
            now rewrite <- nat_compare_gt in Hnp.
            apply (H2 x'). now left.
        intros y p Hxy Hin. simpl in H2. destruct (nat_compare n' n0) eqn:Hnn.
          rewrite nat_compare_eq_iff in Hnn. subst n0. inversion_clear Hin.
            compute in H; destruct H; subst. apply (H2 x'). now right.
            now apply (H3 y).
          rewrite <- nat_compare_lt in Hnn. inversion_clear Hin.
            compute in H; destruct H; subst. transitivity n0.
              assumption.
              apply (H2 x'). now right.
            now apply (H3 y).
          rewrite <- nat_compare_gt in Hnn. inversion_clear Hin.
            compute in H; destruct H; subst. apply (H2 x'). now left.
            now apply (H3 y).
  + subst r. simpl. 
    assert (Hnn : nat_compare n' n = Lt). { rewrite <- nat_compare_lt. apply (H2 x'). now left. }
    rewrite Hnn. left. split.
      reflexivity.
      intros y p Hin. apply (H2 y). now right.
  + destruct r eqn:Hr; simpl.
    - destruct (pair_dec (x, n) (x', n')) as [Heq | Hneq].
        left. compute in Heq; destruct Heq; subst n' x'. split.
          reflexivity.
          intros y p Hin. destruct (Rdec x y).
            subst y. elim Hnin. apply (@InA_eqA _ M.eq_key _ l (x, p)).
              reflexivity.
              revert Hin. apply InA_impl_compat; trivial. now intros ? ? [? ?].
            apply (H3 y). assumption. now right.
        inversion_clear H1.
          contradiction.
          right. repeat split.
            assumption.
            intros y p [Hin | Hin]; inversion Hin; subst y p; clear Hin.
            assert (x <> x').
            { intro Habs. subst x'. apply Hnin. apply (@InA_eqA _ _ _ l (x, n)).
                reflexivity.
                revert H. apply InA_impl_compat; trivial. now intros ? ? [? ?]. }
            apply (H3 x'). assumption. now left.
            intros y p Hxy Hin. apply (H3 y). assumption. now right.
    - destruct (nat_compare n' n0) eqn:Hnn.
        right. rewrite nat_compare_eq_iff in Hnn. subst n0. destruct (eq_nat_dec n n') as [Habs | Hnn].
          subst n'. elim (lt_irrefl n). apply (H2 l0). now left.
          inversion_clear H1. elim Hnn. now destruct H. repeat split.
            assumption.
            intros y p [Hin | Hin]; inversion Hin; subst n'; clear Hin. apply (H2 l0). now left.
            intros y p Hxy Hin. apply (H3 y). assumption. now right.
        rewrite <- nat_compare_lt in Hnn. right. inversion_clear H1.
          compute in H; destruct H; subst x' n'. elim (lt_irrefl n). transitivity n0.
            assumption.
            apply (H2 l0). now left.
          repeat split.
            assumption.
            intros y p [Hin | Hin]; inversion Hin; subst l0 n0; clear Hin. apply (H2 y). now left.
            intros y p Hxy Hin. apply (H3 y). assumption. now right.
        destruct (pair_dec (x, n) (x', n')) as [Heq | Hneq].
          left. clear H1 H2. compute in Heq; destruct Heq; subst x' n'. split.
            reflexivity.
            intros y p Hin. destruct (Rdec x y).
              subst y. elim Hnin. apply (@InA_eqA _ _ _ _ (x, p)).
                reflexivity.
                revert Hin. apply InA_impl_compat; trivial. now intros ? ? [? ?].
              apply (H3 y). assumption. now right.
          right. inversion_clear H1.
            contradiction.
            repeat split.
              assumption.
              intros y p [Hin | Hin]; inversion Hin; subst y p; clear Hin. apply (H3 x').
                intro Habs. subst x'. apply Hnin. apply (@InA_eqA _ _ _ _ (x, n)).
                  reflexivity.
                  revert H. apply InA_impl_compat; trivial. now intros ? ? [? ?].
                now left.
              intros y p Hxy Hin. apply (H3 y). assumption. now right.
    - destruct (nat_compare n' n0) eqn:Hnn.
        rewrite nat_compare_eq_iff in Hnn. subst n0.
        assert (Hnn : (n' < n)%nat). { apply (H2 x). now right. }
        right. repeat split.
          inversion_clear H1.
            compute in H; destruct H; subst x' n'. now elim (lt_irrefl n).
            assumption.
          intros y p [Hin | Hin]; inversion Hin; subst p; clear Hin. assumption.
          intros y p Hxy Hin. apply (H3 y). assumption. now right.
        rewrite <- nat_compare_lt in Hnn.
        assert (Hlt : (n' < n)%nat). { transitivity n0. assumption. apply (H2 x). now right. }
        right. repeat split.
          inversion_clear H1.
            compute in H; destruct H; subst x' n'. now elim (lt_irrefl n).
            assumption.
          intros y p [Hin | Hin]; inversion Hin; subst p; clear Hin. apply (H2 x). now right.
          intros y p Hxy Hin. apply (H3 y). assumption. now right.
        destruct (pair_dec (x, n) (x', n')) as [Heq | Hneq].
          left. clear H1 H2. compute in Heq; destruct Heq; subst x' n'. split.
            reflexivity.
            intros y p Hin. destruct (Rdec x y).
              subst y. elim Hnin. apply (@InA_eqA _ _ _ _ (x, p)).
                reflexivity.
                revert Hin. apply InA_impl_compat; trivial. now intros ? ? [? ?].
              apply (H3 y). assumption. now right.
          right. inversion_clear H1.
            contradiction.
            repeat split.
              assumption.
              intros y p [Hin | Hin]; inversion Hin; subst y p; clear Hin. apply (H3 x').
                intro Habs. subst x'. apply Hnin. apply (@InA_eqA _ _ _ _ (x, n)).
                  reflexivity.
                  revert H. apply InA_impl_compat; trivial. now intros ? ? [? ?].
                now left.
              intros y p Hxy Hin. apply (H3 y). assumption. now right.
Qed.

Corollary majority_stack_Valid_spec : forall l x n,
  (majority_stack l = Valid x n
   <-> (M.multiplicity x (multiset l) = n /\ forall y, x <> y -> M.multiplicity y (multiset l) < n)%nat).
Proof.
intros l x n. destruct n.
+ split; intro H.
  - apply majority_stack_Valid_0 in H. elim H.
  - destruct H as [_ H]. specialize (H _ (succ_neq x)). omega.
+ unfold majority_stack. rewrite majority_stack_Valid_spec_aux. split; intro H.
  - destruct H as [[Habs _] | [H1 [H2 H3]]].
      discriminate Habs.
      now split.
  - destruct H as [H1 H2]. right. repeat split.
      assumption.
      intros ? ? [Habs | Habs]; discriminate Habs.
      assumption.
  - omega.
Qed.

Theorem majority_stack_spec : forall pos,
  (exists x n, majority_stack (nominal_spectrum pos) = Valid x n) <-> Stack pos.
Proof. intro pos. setoid_rewrite majority_stack_Valid_spec. unfold Stack. reflexivity. Qed.

Lemma majority_stack_Invalid_0_aux : forall m r, 
  M.fold f_majority m r = Invalid 0 <-> M.Empty m /\ r = Invalid 0.
Proof.
intros m r. rewrite M.fold_spec. rewrite <- M.elements_nil.
assert (Hm : forall xn, InA M.eq_pair xn (M.elements m) -> M.multiplicity (fst xn) m = snd xn /\ (snd xn > 0)%nat)
by (intro; apply M.elements_spec).
revert r. induction (M.elements m); simpl; intro r.
  now intuition.
  rewrite IHl. clear IHl.
    split; intros [H1 H2]; exfalso.
      subst l. destruct a, r; simpl in H2.
        discriminate H2.
        destruct (nat_compare n n0) eqn:Hn; try discriminate H2.
        inversion H2. rewrite nat_compare_eq_iff in Hn. subst. clear H2.
        apply (gt_irrefl 0). apply (Hm (e, 0%nat)). now left.
        destruct (nat_compare n n0) eqn:Hn.
          inversion H2. rewrite nat_compare_eq_iff in Hn. subst. clear H2.
          apply (gt_irrefl 0). apply (Hm (e, 0%nat)). now left.
          inversion H2. rewrite <- nat_compare_lt in Hn. subst. now inversion Hn.
          discriminate H2.
      discriminate H1.
    intros xn Hin. apply (Hm xn). now right.
Qed.

Corollary majority_stack_Invalid_0 : forall m, majority_stack m <> Invalid 0.
Proof.
unfold majority_stack. intros m H. rewrite majority_stack_Invalid_0_aux in H. destruct H as [_ H]. discriminate H.
Qed.

Lemma majority_stack_Invalid_spec_aux : forall l n r, n > 0 ->
  List.fold_left (fun acc xn => f_majority (fst xn) (snd xn) acc) (M.elements (multiset l)) r = Invalid n ->
  r = Invalid n /\ (forall z p, InA M.eq_pair (z, p) (M.elements (multiset l)) -> p < n)
  \/ exists x y, InA M.eq_pair (x, n) (M.elements (multiset l))
                /\ (r = Valid y n
                    \/ r = Invalid n
                    \/ InA M.eq_pair (y, n) (M.elements (multiset l))
                       /\ (forall y m, (r = Valid y m \/ r = Invalid m) -> m < n)
                       /\ x <> y)
                /\ (forall z p, InA M.eq_pair (z, p) (M.elements (multiset l)) -> p <= n).
Proof.
intros l' n r Hn. revert r.
assert (Hdup := M.elements_NoDupA (multiset l')).
induction (M.elements (multiset l')) as [| [x' n'] l]; clear l'; simpl; intros r Hl.
  left. split. assumption. intros ? ? Habs. now inversion Habs.
  inversion_clear Hdup. apply IHl in Hl; trivial. clear IHl.
  destruct r eqn:Hr.
  * destruct Hl as [[Hl1 Hl2] | [x [y [Hx [Hy Hle]]]]]; simpl in *.
    + discriminate Hl1.
    + right. exists x. exists y. repeat split.
        now right.
        do 2 right. destruct Hy as [Hy | [Hy | [Hy1 [Hy2 Hxy]]]].
          inversion Hy. subst. clear Hy. repeat split.
            now left.
            intros z p [Habs | Habs]; discriminate Habs.
            intro. subst y. apply H. revert Hx. now apply (InA_impl_compat _).
          now inversion Hy.
          repeat split.
            now right.
            intros z p [Habs | Habs]; discriminate Habs.
            assumption.
        intros z p Hin. inversion_clear Hin.
          compute in H1; destruct H1; subst x' n'. destruct Hy as [Hy | [Hy | [Hy1 [Hy2 Hxy]]]].
            now inversion_clear Hy.
            now inversion_clear Hy.
            apply lt_le_weak. apply (Hy2 z). now left.
          now apply (Hle z).
  * destruct Hl as [[Hl1 Hl2] | [x [y [Hx [Hy Hle]]]]]; simpl in *.
    + destruct (nat_compare n' n0) eqn:Hnn; try discriminate Hl1.
      rewrite nat_compare_eq_iff in Hnn. inversion Hl1. subst n0 n'. clear Hl1.
      right. exists x'. exists l0. repeat split.
        now left.
        now left.
        intros z p Hin. inversion_clear Hin.
          compute in H1. now intuition.
          apply lt_le_weak. now apply (Hl2 z).
    + right. destruct (nat_compare n' n0) eqn:Hnn.
      - rewrite nat_compare_eq_iff in Hnn. subst n0.
        destruct Hy as [Hy | [Hy | [Hy1 [Hy2 Hxy]]]].
          discriminate Hy.
          inversion Hy. subst n'. clear Hy. exists x. exists l0. repeat split.
            now right.
            now left.
            intros z p Hin. inversion_clear Hin.
              compute in H1. destruct H1. subst. reflexivity.
              now apply (Hle z).
          exists x. exists y. repeat split.
            now right.
            do 2 right. repeat split.
              now right.
              intros z p [Habs | Habs].
                apply (Hy2 z). right. now inversion Habs.
                discriminate Habs.
              assumption.
            intros z p Hin. inversion_clear Hin.
              compute in H1; destruct H1; subst x' n'. apply lt_le_weak, (Hy2 z). now right.
              now apply (Hle z).
      - rewrite <- nat_compare_lt in Hnn. exists x. exists y.
        destruct Hy as [Hy | [Hy | [Hy1 [Hy2 Hxy]]]].
          inversion Hy. subst n0 l0. clear Hy. repeat split.
            now right.
            now left.
            intros z p Hin. inversion_clear Hin.
              compute in H1; destruct H1; subst. now apply lt_le_weak. 
              now apply (Hle z).
          discriminate Hy.
          repeat split.
            now right.
            do 2 right. repeat split.
              now right.
              intros z p [Hin | Hin].
                apply (Hy2 l0). left. now inversion Hin.
                discriminate Hin.
              assumption.
              intros z p Hin. inversion_clear Hin.
                compute in H1; destruct H1; subst x' n'. apply lt_le_weak. transitivity n0.
                  assumption.
                  apply (Hy2 l0). now left.
            now apply (Hle z).
      - rewrite <- nat_compare_gt in Hnn. exists x. exists y.
        destruct Hy as [Hy | [Hy | [Hy1 [Hy2 Hxy]]]].
          inversion Hy. subst x' n'. clear Hy. repeat split.
            now right.
            do 2 right. repeat split.
              now left.
              intros z p [Hin | Hin].
                inversion Hin. subst n0 l0. clear Hin. assumption.
                discriminate Hin.
              intro. subst y. apply H. revert Hx. now apply (InA_impl_compat _).
            intros z p Hin. inversion_clear Hin.
              compute in H1. now intuition.
              now apply (Hle z).
          discriminate Hy.
          repeat split.
            now right.
            do 2 right. repeat split.
              now right.
              intros z p [Hin | Hin].
                inversion Hin. subst n0 l0. clear Hin. transitivity n'.
                  assumption.
                  apply (Hy2 x'). now left.
                discriminate Hin.
              assumption.
            intros z p Hin. inversion_clear Hin.
              compute in H1. destruct H1. subst. apply lt_le_weak, (Hy2 x'). now left.
              now apply (Hle z).
  * destruct Hl as [[Hl1 Hl2] | [x [y [Hx [Hy Hle]]]]]; simpl in *.
    + destruct (nat_compare n' n0) eqn:Hnn; try discriminate Hl1.
      - rewrite nat_compare_eq_iff in Hnn. inversion Hl1. subst n0 n'. clear Hl1.
        right. exists x'. exists x'. repeat split.
          now left.
          now right; left.
          intros z p Hin. inversion_clear Hin.
            compute in H1. now intuition.
            apply lt_le_weak. now apply (Hl2 z).
      - rewrite <- nat_compare_lt in Hnn. inversion Hl1. subst n0. clear Hl1.
        left. split. reflexivity.
        intros z p Hin. inversion_clear Hin.
          compute in H1. now intuition.
          now apply (Hl2 z).
    + right. exists x. exists y. destruct (nat_compare n' n0) eqn:Hnn.
      - rewrite nat_compare_eq_iff in Hnn. subst n0.
        destruct Hy as [Hy | [Hy | [Hy1 [Hy2 Hxy]]]].
          discriminate Hy.
          inversion Hy. subst n'. clear Hy. repeat split.
            now right.
            now right; left.
            intros z p Hin. inversion_clear Hin.
              compute in H1. destruct H1. subst. reflexivity.
              now apply (Hle z).
          repeat split.
            now right.
            do 2 right. repeat split.
              now right.
              intros z p [Habs | Habs].
                discriminate Habs.
                apply (Hy2 z). now right.
              assumption.
            intros z p Hin. inversion_clear Hin.
              compute in H1; destruct H1; subst x' n'. apply lt_le_weak, (Hy2 z). now right.
              now apply (Hle z).
      - rewrite <- nat_compare_lt in Hnn.
        destruct Hy as [Hy | [Hy | [Hy1 [Hy2 Hxy]]]].
          discriminate Hy.
          inversion Hy. subst n0. clear Hy. repeat split.
            now right.
            now right; left.
            intros z p Hin. inversion_clear Hin.
              compute in H1; destruct H1; subst. now apply lt_le_weak. 
              now apply (Hle z).
          repeat split.
            now right.
            do 2 right. repeat split.
              now right.
              intros z p [Hin | Hin].
                discriminate Hin.
                apply (Hy2 y). now right.
              assumption.
              intros z p Hin. inversion_clear Hin.
                compute in H1; destruct H1; subst x' n'. apply lt_le_weak. transitivity n0.
                  assumption.
                  apply (Hy2 y). now right.
            now apply (Hle z).
      - rewrite <- nat_compare_gt in Hnn.
        destruct Hy as [Hy | [Hy | [Hy1 [Hy2 Hxy]]]].
          inversion Hy. subst x' n'. clear Hy. repeat split.
            now right.
            do 2 right. repeat split.
              now left.
              intros z p [Hin | Hin].
                discriminate Hin.
                inversion Hin. subst n0. clear Hin. assumption.
              intro. subst y. apply H. revert Hx. now apply (InA_impl_compat _).
            intros z p Hin. inversion_clear Hin.
              compute in H1. now intuition.
              now apply (Hle z).
          discriminate Hy.
          repeat split.
            now right.
            do 2 right. repeat split.
              now right.
              intros z p [Hin | Hin].
                discriminate Hin.
                inversion Hin. subst n0. clear Hin. transitivity n'.
                  assumption.
                  apply (Hy2 x'). now left.
              assumption.
            intros z p Hin. inversion_clear Hin.
              compute in H1. destruct H1. subst. apply lt_le_weak, (Hy2 x'). now left.
              now apply (Hle z).
Qed.

Corollary majority_stack_Invalid_correct : forall l n,
  majority_stack l = Invalid n ->
  n > 0 /\ exists x, exists y, M.multiplicity x (multiset l) = n /\ M.multiplicity y (multiset l) = n
                                /\ x <> y /\ forall z, M.multiplicity z (multiset l) <= n.
Proof.
intros l n H.
assert (Hn : n > 0) by (destruct n; omega || elim (majority_stack_Invalid_0 H)).
split. assumption.
unfold majority_stack in H. rewrite M.fold_spec in H.
apply (majority_stack_Invalid_spec_aux _ _ Hn) in H.
destruct H as [[Habs _] | [x [y [Hx [Hy Hle]]]]].
  discriminate Habs.
  exists x. exists y. destruct Hy as [Habs | [Habs | [Hy [_ Hxy]]]]; try discriminate Habs.
  rewrite M.elements_spec in *. simpl in *. destruct Hx, Hy. repeat split; trivial.
  intros z. destruct (M.multiplicity z (multiset l)) eqn:Hz.
    omega.
    rewrite <- Hz. apply (Hle z). rewrite M.elements_spec. split. reflexivity. rewrite Hz. simpl. omega.
Qed.

Theorem majority_stack_Invalid_spec : forall l n,
  majority_stack l = Invalid n <->
  n > 0 /\ exists x, exists y, M.multiplicity x (multiset l) = n /\ M.multiplicity y (multiset l) = n
                                /\ x <> y /\ forall z, M.multiplicity z (multiset l) <= n.
Proof.
intros l n. split; intro H.
+ now apply majority_stack_Invalid_correct.
+ destruct H as [Hn [x [ y [ H1 [H2 [H3 H4]]]]]]. destruct (majority_stack l) as [| pt p | p] eqn:Hmaj.
  - rewrite majority_stack_NoResult_spec in Hmaj. subst l. rewrite multiset_nil in *.
    rewrite M.empty_spec in H1. subst n. now elim (lt_irrefl 0).
  - rewrite majority_stack_Valid_spec in Hmaj. destruct Hmaj as [Hmaj1 Hmaj2].
    destruct (Rdec pt x).
      subst pt. rewrite H1 in Hmaj1. subst p. elim (lt_irrefl n). rewrite <- H2 at 1. now apply (Hmaj2 y).
      elim (lt_irrefl p). apply le_lt_trans with n.
        rewrite <- Hmaj1. now apply H4.
        rewrite <- H1. now apply (Hmaj2 x).
  - f_equal. apply majority_stack_Invalid_correct in Hmaj. destruct Hmaj as [Hp [x' [y' [Hx [ Hy [_ Hle]]]]]].
     apply le_antisym.
       rewrite <- Hx. now apply H4.
       rewrite <- H1. now apply Hle.
Qed.

Definition list_rect2 : forall A P, P nil -> (forall a : A, P (a :: nil)) ->
                              (forall a b l, P l -> P (a :: b :: l)) ->
                              forall l, P l :=
  fun A P Pnil Pone Prec =>
  fix F (l : list A) : P l :=
  match l as l return (P l) with
  | nil => Pnil
  | x :: nil => Pone x
  | x :: y :: l0 => Prec x y l0 (F l0)
  end.

Lemma majority_stack_Invalid_1 : forall l, majority_stack l = Invalid 1 -> NoDup l.
Proof.
intros l Hl. induction l using list_rect2.
- constructor.
- constructor. apply in_nil. constructor.
- rewrite majority_stack_Invalid_spec in Hl. destruct Hl as [_ [x [y [Hx [Hy [Hxy Hle]]]]]].
  do 2 rewrite multiset_cons in *.
  assert (Hab : b <> a).
  { intro. subst b. cut (2 <= 1). omega. transitivity (M.multiplicity a (M.add a 1 (M.add a 1 (multiset l)))).
      do 2 rewrite M.add_spec. omega.
      do 2 rewrite <- multiset_cons. apply Hle. }
  assert (~In a l).
  { specialize (Hle a). do 2 rewrite multiset_cons in Hle. rewrite M.add_spec, M.add_spec' in Hle; auto.
    rewrite plus_comm in Hle. apply le_S_n in Hle. apply le_n_0_eq in Hle. rewrite <- multiset_In. omega. }
  assert (~In b l).
  { specialize (Hle b). do 2 rewrite multiset_cons in Hle. rewrite M.add_spec', M.add_spec in Hle; auto.
    rewrite plus_comm in Hle. apply le_S_n in Hle. apply le_n_0_eq in Hle. rewrite <- multiset_In. omega. }
  constructor.
    intros [ | ]; contradiction.
    constructor. assumption.
Admitted.


Ltac Rdec_aux H :=
  match type of H with
    | context[Rdec ?x ?y] =>
      let Heq := fresh "Heq" in let Hneq := fresh "Hneq" in
      destruct (Rdec x y) as [Heq | Hneq]
    | _ => fail
  end.


(**  Back to the proof  **)

Lemma remove_alls_2 : forall x y l n, remove Rdec x l = alls y (S n) -> forall z, In z (x :: l) <-> z = x \/ z = y.
Proof.
intros x y l n Hl z. split; intro Hin.
- destruct (Rdec z x). now left. right.
  rewrite <- (remove_in_out Rdec x) in Hin.
  simpl in Hin. Rdec. rewrite Hl in Hin.
  now apply alls_In with (S n). auto.
- destruct (Rdec z x). subst. now left. destruct Hin. contradiction. subst.
  right. rewrite <- (remove_in_out Rdec x). rewrite Hl. now left. auto.
Qed.

Theorem is_forbidden_correct : forall pos,
  is_forbidden (nominal_spectrum pos) = true -> forbidden pos.
Proof.
unfold is_forbidden. intros pos H.
destruct (nominal_spectrum pos) eqn:Hnom; try discriminate H.
destruct (remove Rdec r s) as [| r' s'] eqn:Hs; try discriminate H.
destruct (remove Rdec r' s') eqn:Hs'; try discriminate H.
apply remove_nil in Hs'. destruct Hs' as [n Hs']. subst s'.
assert (Hin : forall x, In x (r :: s) <-> x = r \/ x = r'). { intro. now apply remove_alls_2 with n. }
assert (Hneq : r <> r'). { intro. subst r'. apply (remove_In Rdec s r). rewrite Hs. now left. }
assert (Hr : count_occ Rdec (r :: s) r = S n).
{ symmetry in H. apply beq_nat_eq in H. rewrite H. rewrite <- (count_occ_remove_out r Hneq).
  simpl. Rdec. rewrite Hs. simpl. Rdec. now rewrite count_occ_alls_in. }
exists r. exists r'. exists (S n). split; trivial.
rewrite Hnom. clear Hnom. rewrite (remove_count_occ_restore Rdec r). simpl remove. Rdec. now rewrite Hr, Hs.
Qed.

(* In the general case, we also need the hypothesis that G contains at least 2 elements. *)
Theorem is_forbidden_complete : forall pos, @forbidden Four Zero pos -> is_forbidden (nominal_spectrum pos) = true.
Proof.
unfold is_forbidden. intros pos H.
destruct H as [pt1 [pt2 [n [Hneq Hperm]]]].
destruct (nominal_spectrum pos) as [| r [| r' s]] eqn:Hnom.
(* the hypothesis on G is used in the next 2 lines *)
+ rewrite nominal_spectrum4 in Hnom. discriminate Hnom.
+ rewrite nominal_spectrum4 in Hnom. discriminate Hnom.
+ destruct n. simpl in Hperm. symmetry in Hperm. apply Permutation_nil in Hperm. discriminate Hperm.
  assert (Hin : forall x, In x (nominal_spectrum pos) <-> x = pt1 \/ x = pt2).
  { intro x. rewrite Hnom, Hperm, in_app_iff. split; intros [Hin | Hin]; subst.
      left. now apply (alls_In pt1 x (S n)).
      right. now apply (alls_In pt2 x (S n)).
      now do 2 left.
      now right; left. }
  assert (Heqr : r = pt1 \/ r = pt2). { rewrite <- Hin, Hnom. now left. }
  assert (Heqr' : r' = pt1 \/ r' = pt2). { rewrite <- Hin, Hnom. now right; left. }
  { destruct Heqr, Heqr'; subst r r'; simpl remove at 1; Rdec.
  (* Four main cases *)
  * destruct (remove Rdec pt1 s) eqn:Hrem1.
    + elim (@in_nil _ pt2). rewrite <- Hrem1.
      replace (remove Rdec pt1 s) with (remove Rdec pt1 (pt1 :: pt1 :: s)) by now simpl; Rdec.
      rewrite Hperm. rewrite remove_app. apply in_or_app. right. rewrite remove_in_out. now left. assumption.
    + assert (Heqr : r = pt2).
      { assert (Hr : r <> pt1). { intro. subst r. apply (remove_In Rdec s pt1). rewrite Hrem1. now left. }
        assert (Hrin : In r (nominal_spectrum pos)).
        { rewrite Hnom. do 2 right. rewrite <- (remove_in_out Rdec pt1). rewrite Hrem1. now left. auto. }
        rewrite Hin in Hrin. now destruct Hrin. }
      subst r. destruct (remove Rdec pt2 l) eqn:Hrem2.
      - rewrite Hperm. do 2 rewrite count_occ_app. repeat rewrite count_occ_alls_in, count_occ_alls_out.
        rewrite beq_nat_true_iff. now auto.
        assumption. auto.
      - assert (r <> pt2). { intro. subst r. apply (remove_In Rdec l pt2). rewrite Hrem2. now left. }
        assert (r <> pt1).
        { intro. subst r. apply (remove_In Rdec s pt1). rewrite Hrem1. right.
          rewrite <- (remove_in_out Rdec pt2). rewrite Hrem2. now left. auto. }
        assert (Habs : r = pt1 \/ r = pt2).
        { rewrite <- Hin, Hnom. do 2 right. rewrite <- (remove_in_out Rdec pt1); auto. rewrite Hrem1. right.
          rewrite <- (remove_in_out Rdec pt2); auto. rewrite Hrem2. now left. }
        now destruct Habs.
  * destruct (Rdec pt1 pt2) eqn:Hpt; try contradiction.
    assert (Hc1 : count_occ Rdec (pt1 :: pt2 :: s) pt1 = S n).
    { rewrite Hperm. rewrite count_occ_app. rewrite count_occ_alls_in, count_occ_alls_out. auto. auto. }
    assert (Hc2 : count_occ Rdec (pt1 :: pt2 :: s) pt2 = S n).
    { rewrite Hperm. rewrite count_occ_app. rewrite count_occ_alls_in, count_occ_alls_out. auto. auto. }
    destruct (remove Rdec pt1 s) eqn:Hrem1.
    + simpl. Rdec. rewrite Hpt. destruct (Rdec pt2 pt1) eqn:Htp. now elim Hneq.
      simpl in Hc1, Hc2. Rdec. rewrite Htp in Hc1. rewrite Hpt in Hc2. rewrite Hc1, Hc2. now rewrite <- beq_nat_refl.
    + simpl remove. destruct (Rdec pt2 r).
      - subst r. destruct (remove Rdec pt2 l) eqn:Hrem2.
          rewrite Hc1, Hc2. now rewrite <- beq_nat_refl.
          assert (r <> pt2). { intro. subst r. apply (remove_In Rdec l pt2). rewrite Hrem2. now left. }
          assert (r <> pt1).
          { intro. subst r. apply (remove_In Rdec s pt1). rewrite Hrem1. right.
            rewrite <- (remove_in_out Rdec pt2). rewrite Hrem2. now left. auto. }
          assert (Habs : r = pt1 \/ r = pt2).
          { rewrite <- Hin, Hnom. do 2 right. rewrite <- (remove_in_out Rdec pt1); auto. rewrite Hrem1. right.
            rewrite <- (remove_in_out Rdec pt2); auto. rewrite Hrem2. now left. }
          now destruct Habs.
      - assert (r <> pt1). { intro. subst r. apply (remove_In Rdec s pt1). rewrite Hrem1. now left. }
        assert (Habs : r = pt1 \/ r = pt2).
        { rewrite <- Hin, Hnom. do 2 right. rewrite <- (remove_in_out Rdec pt1); auto. rewrite Hrem1. now left. }
        destruct Habs; auto.
  * destruct (Rdec pt2 pt1) eqn:Htp; try now elim Hneq.
    assert (Hc1 : count_occ Rdec (pt2 :: pt1 :: s) pt1 = S n).
    { rewrite Hperm. rewrite count_occ_app. rewrite count_occ_alls_in, count_occ_alls_out. auto. auto. }
    assert (Hc2 : count_occ Rdec (pt2 :: pt1 :: s) pt2 = S n).
    { rewrite Hperm. rewrite count_occ_app. rewrite count_occ_alls_in, count_occ_alls_out. auto. auto. }
    destruct (remove Rdec pt2 s) eqn:Hrem1.
    + simpl. Rdec. rewrite Htp. destruct (Rdec pt1 pt2) eqn:Hpt. now elim Hneq.
      simpl in Hc1, Hc2. Rdec. rewrite Htp in Hc1. rewrite Hpt in Hc2. rewrite Hc1, Hc2. now rewrite <- beq_nat_refl.
    + simpl remove. destruct (Rdec pt1 r).
      - subst r. destruct (remove Rdec pt1 l) eqn:Hrem2.
          rewrite Hc1, Hc2. now rewrite <- beq_nat_refl.
          assert (r <> pt1). { intro. subst r. apply (remove_In Rdec l pt1). rewrite Hrem2. now left. }
          assert (r <> pt2).
          { intro. subst r. apply (remove_In Rdec s pt2). rewrite Hrem1. right.
            rewrite <- (remove_in_out Rdec pt1). rewrite Hrem2. now left. auto. }
          assert (Habs : r = pt1 \/ r = pt2).
          { rewrite <- Hin, Hnom. do 2 right. rewrite <- (remove_in_out Rdec pt2); auto. rewrite Hrem1. right.
            rewrite <- (remove_in_out Rdec pt1); auto. rewrite Hrem2. now left. }
          now destruct Habs.
      - assert (r <> pt2). { intro. subst r. apply (remove_In Rdec s pt2). rewrite Hrem1. now left. }
        assert (Habs : r = pt1 \/ r = pt2).
        { rewrite <- Hin, Hnom. do 2 right. rewrite <- (remove_in_out Rdec pt2); auto. rewrite Hrem1. now left. }
        destruct Habs; auto.
  * destruct (remove Rdec pt2 s) eqn:Hrem1.
    + elim (@in_nil _ pt1). rewrite <- Hrem1.
      replace (remove Rdec pt2 s) with (remove Rdec pt2 (pt2 :: pt2 :: s)) by now simpl; Rdec.
      rewrite Hperm. rewrite remove_app. apply in_or_app. left. rewrite remove_in_out. now left. auto.
    + assert (Heqr : r = pt1).
      { assert (Hr : r <> pt2). { intro. subst r. apply (remove_In Rdec s pt2). rewrite Hrem1. now left. }
        assert (Hrin : In r (nominal_spectrum pos)).
        { rewrite Hnom. do 2 right. rewrite <- (remove_in_out Rdec pt2). rewrite Hrem1. now left. auto. }
        rewrite Hin in Hrin. now destruct Hrin. }
      subst r. destruct (remove Rdec pt1 l) eqn:Hrem2.
      - rewrite Hperm. do 2 rewrite count_occ_app. repeat rewrite count_occ_alls_in, count_occ_alls_out.
        rewrite beq_nat_true_iff. now auto.
        auto. assumption.
      - assert (r <> pt1). { intro. subst r. apply (remove_In Rdec l pt1). rewrite Hrem2. now left. }
        assert (r <> pt2).
        { intro. subst r. apply (remove_In Rdec s pt2). rewrite Hrem1. right.
          rewrite <- (remove_in_out Rdec pt1). rewrite Hrem2. now left. auto. }
        assert (Habs : r = pt1 \/ r = pt2).
        { rewrite <- Hin, Hnom. do 2 right. rewrite <- (remove_in_out Rdec pt2); auto. rewrite Hrem1. right.
          rewrite <- (remove_in_out Rdec pt1); auto. rewrite Hrem2. now left. }
        now destruct Habs. }
Qed.

Corollary is_forbidden_true : forall pos, is_forbidden (@nominal_spectrum Four Zero pos) = true <-> forbidden pos.
Proof. intro pos. split; intro H. now apply is_forbidden_correct. now apply is_forbidden_complete. Qed.

Corollary is_forbidden_false : forall pos, is_forbidden (nominal_spectrum pos) = false <-> ~forbidden pos.
Proof.
intro pos. assert (Hp := is_forbidden_true pos).
destruct (is_forbidden (nominal_spectrum pos)); rewrite <- Hp; intuition.
Qed.

Lemma is_forbidden_alls : forall pt n, is_forbidden (alls pt n) = false.
Proof. intros pt [| n]. reflexivity. unfold is_forbidden. simpl. Rdec. now rewrite remove_alls. Qed.

Instance is_forbidden_Permutation_proper : Proper (@Permutation R ==> eq) is_forbidden.
Proof.
intros [| r l] [| r' l'] Hperm.
reflexivity. apply Permutation_nil in Hperm. discriminate Hperm.
symmetry in Hperm. apply Permutation_nil in Hperm. discriminate Hperm.
unfold is_forbidden at 1. simpl remove. Rdec. destruct (remove Rdec r l) as [| r1 l1] eqn:Hrem.
+ unfold is_forbidden. apply remove_nil in Hrem. destruct Hrem as [n Hn].
  rewrite Hn in Hperm. symmetry in Hperm. change (r :: alls r n) with (alls r (S n)) in Hperm.
  apply Permutation_alls in Hperm. rewrite Hperm. inversion Hperm. subst. now rewrite remove_alls.
+ simpl count_occ. Rdec. destruct (Permutation_cons_inside Hperm) as [l2 [l3 [H1 H2]]].
  destruct (Rdec r r1) as [| Hneq]. subst r. exfalso. elim (remove_In Rdec l r1). rewrite Hrem. now left.
  destruct (remove Rdec r1 l1) as [| r4 l4] eqn:Hrem2.
  - apply remove_nil in Hrem2. destruct Hrem2 as [n Hn]. subst l1.
     assert (Heq : count_occ Rdec l r1 = S n).
    { rewrite <- (count_occ_remove_out r Hneq). rewrite Hrem. simpl. Rdec. now rewrite count_occ_alls_in. }
    rewrite Heq.
    (* there are only two differents elements inside l *)
    assert (Hl : forall x, In x (r :: l) <-> x = r \/ x = r1).
    { apply remove_alls_2 with n. simpl in Hrem. Rdec. apply Hrem. }
    (* the same goes for l' as it is a permutation of l *)
    assert (Hl' : forall x, In x (r' :: l') <-> x = r \/ x = r1). { intro x. rewrite <- Hl. now rewrite Hperm. }
    assert (Hr' : r' = r \/ r' = r1). { rewrite <- Hl'. now left. }
    destruct (Rdec r' r) as [| Hrr'].
    (* the first elements in both lists are the same *)
    * subst r'. unfold is_forbidden.
      assert (Hr : remove Rdec r l' = alls r1 (S n)).
      { apply Permutation_alls. simpl alls. rewrite <- Hrem. apply Permutation_cons_inv in Hperm. now rewrite Hperm. }
      rewrite Hr. simpl. rewrite remove_alls. Rdec. destruct (Rdec r r1) as [| _]; try contradiction.
      rewrite <- (count_occ_remove_out r Hneq).
      assert (Hr2 : remove Rdec r l' = alls r1 (S n)). { revert Hr. simpl. Rdec. auto. }
      rewrite Hr2. rewrite count_occ_alls_in. simpl.
      apply Permutation_cons_inv in Hperm. f_equal. now rewrite Hperm.
    (* the first elements in both lists are differents *)
    * destruct Hr'. contradiction. subst r'. unfold is_forbidden. simpl remove. Rdec.
      destruct (remove Rdec r1 l') eqn:Hrem2.
        apply remove_nil in Hrem2. destruct Hrem2  as [m ?]. subst l'.
        elim Hrr'. symmetry. SearchAbout In alls. apply alls_In with (S m).
        simpl alls. rewrite <- Hperm. now left.
        destruct (Rdec r1 r0). subst. elim (remove_In Rdec l' r0). rewrite Hrem2. now left.
        assert (r0 = r).
        { cut (r0 = r \/ r0 = r1). intro H. destruct H; assumption || (symmetry in H; contradiction).
          rewrite <- Hl'. right. rewrite  <- (remove_in_out Rdec r1). rewrite Hrem2. now left. assumption. }
        subst r0.
        simpl in Hrem. Rdec. destruct (remove Rdec r l0) eqn:Hrem1.
          rewrite H2, H1. repeat rewrite count_occ_app. simpl. Rdec.
          destruct l2. inversion H2. contradiction. simpl in H2. inversion H2. subst. simpl. Rdec.
          destruct (Rdec r0 r). contradiction. destruct (Rdec r r0). now elim Hrr'.
          rewrite <- plus_n_Sm. simpl. rewrite NPeano.Nat.eqb_sym. f_equal.
          apply eq_add_S. rewrite <- count_occ_app.
          transitivity (count_occ Rdec ((r0 :: l2) ++ l3) r0). rewrite <- H1.
          rewrite <- (count_occ_remove_out r).
          rewrite Hrem. simpl. Rdec. now rewrite count_occ_alls_in. assumption. simpl. now Rdec.
          assert (r0 <> r /\ r0 <> r1).
          { split; intro; subst r0.
              apply (remove_In Rdec l0 r). rewrite Hrem1. now left.
              apply (remove_In Rdec l' r1). rewrite Hrem2. right.
              rewrite <- (remove_in_out Rdec r). rewrite Hrem1. now left. assumption. }
          exfalso. apply (Classical_Prop.and_not_or _ _ H). rewrite <- Hl'. destruct H. right.
          rewrite <- (remove_in_out Rdec r1). rewrite Hrem2. right.
          rewrite <- (remove_in_out Rdec r). rewrite Hrem1. now left. auto. auto.
  - unfold is_forbidden. simpl. Rdec.
    destruct (remove Rdec r' l') eqn:Hrem3; try reflexivity.
    destruct (remove Rdec r0 l0) eqn:Hrem4; try reflexivity.
    apply remove_nil in Hrem4. destruct Hrem4 as [n Hn]. subst l0. exfalso.
    (* 3 differents elements (r, r1, r4) are in l, whereas only two are possible for l' *)
    assert (r4 <> r1). { intro. subst. apply (remove_In Rdec l1 r1). rewrite Hrem2. now left. }
    assert (r4 <> r).
    { intro. subst. apply (remove_In Rdec l r). rewrite Hrem.
      right. rewrite <- (remove_in_out Rdec r1). rewrite Hrem2. now left. auto. }
    assert (Heq : r0 = r /\ r1 = r' \/ r' = r /\ r1 = r0).
    { destruct (Rdec r0 r) as [| Hr0r].
      + subst r0. left. split. reflexivity.
        assert (Hr1 : In r1 (r :: l)).
        { right. rewrite <- (remove_in_out Rdec r). rewrite Hrem. now left. assumption. }
        change (r :: alls r n) with (alls r (S n)) in Hrem3. rewrite Hperm in Hr1.
        rewrite (@remove_alls_2 r' r _ n) in Hr1. destruct Hr1. assumption. now elim Hneq. assumption.
      + right. assert (r' = r). 
        { assert (Hr1 : In r (r' :: l')). { rewrite <- Hperm. now left. }
          destruct (Rdec r r'). now symmetry. destruct Hr1 as [| Hr]. assumption.
          rewrite <- (remove_in_out Rdec r') in Hr. rewrite Hrem3 in Hr.
          destruct Hr as [| Hr]. contradiction. apply alls_In in Hr. now elim Hr0r. auto. }
        subst r'. apply Permutation_cons_inv in Hperm. split; trivial.
        apply (alls_In _ _ (S n)). simpl alls. rewrite <- Hrem3.
        rewrite <- Hperm. rewrite Hrem. now left. }
    destruct Heq as [[] | []]; subst.
      assert (Habs : r4 = r' \/ r4 = r).
      { rewrite <- (remove_alls_2 _ _ Hrem3). rewrite <- Hperm. right.
        rewrite <- (remove_in_out Rdec r). rewrite Hrem. right.
        rewrite <- (remove_in_out Rdec r'). rewrite Hrem2. now left.
        auto. auto. }
      destruct Habs; auto.
      apply Permutation_cons_inv in Hperm.
      assert (Habs : r4 = r \/ r4 = r0).
      { rewrite <- (remove_alls_2 _ _ Hrem3). rewrite <- Hperm. right.
        rewrite <- (remove_in_out Rdec r). rewrite Hrem. right.
        rewrite <- (remove_in_out Rdec r0). rewrite Hrem2. now left.
        auto. auto. }
      destruct Habs; auto.
Qed.

Open Scope R_scope.
Definition range b1 b2 (s : spectrum) :=
  List.Forall (fun x => b1 <= x <= b2) s.

Lemma range_compat : Proper (eq ==> eq ==> @Permutation R ==> iff) range.
Proof.
intros inf1 inf2 ? sup1 sup2 ? s1 s2 Hs. subst.
unfold range. split; apply Forall_Perm_trans; trivial. reflexivity. reflexivity. now symmetry.
Qed.

Lemma range_split : forall b1 b2 s,
  range b1 b2 s <-> (List.Forall (fun x => b1 <= x) s /\ List.Forall (fun x => x <= b2) s).
Proof.
intros b1 b2 s. unfold range. setoid_rewrite List.Forall_forall.
intuition; apply (H _ H0).
Qed.

Definition extremal r (s : spectrum) :=
  exists b, range b r s \/ range r b s.

(*
Parameter is_extremal : ident Four Zero -> position Four Zero -> bool.
Hypothesis is_extremal_correct : forall r pos, is_extremal r pos = true <-> extremal r pos.
*)

Definition is_extremal r (s : spectrum) :=
  if Rdec r (List.hd r (sort s)) then true else
  if Rdec r (List.last (sort s) r) then true else false.

Theorem is_extremal_correct : forall r (s : spectrum),
  List.In r s -> (is_extremal r s = true <-> extremal r s).
Proof.
unfold is_extremal,extremal. intros r s Hin.
repeat Rdec_full; split; intro H; try (reflexivity || discriminate H);
try solve [reflexivity | discriminate H | right; now intros [] | left; now intros []].
+ clear H. rewrite Heq. exists (List.last (sort s) r). right.
  rewrite range_split. split;
  rewrite List.Forall_forall; apply sort_min || apply sort_max.
+ clear H. exists (List.hd r (sort s)). left. rewrite Heq.
  rewrite range_split. split;
  rewrite List.Forall_forall; apply sort_min || apply sort_max.
+ exfalso. destruct H as [b [Hb | Hb]].
  - elim (Rlt_irrefl r). apply Rlt_le_trans with (List.last (sort s) r).
      revert Hneq0. generalize (sort_max s r r Hin). apply Rle_neq_lt.
      apply range_split in Hb. destruct Hb as [_ Hb]. rewrite List.Forall_forall in Hb.
      apply Hb. rewrite (Permuted_sort s) at 2. apply last_In.
      rewrite (Permuted_sort s) in Hin. destruct (sort s).
      inversion Hin. discriminate.
  - elim (Rlt_irrefl r). apply Rle_lt_trans with (List.hd r (sort s)).
      apply range_split in Hb. destruct Hb as [Hb _]. rewrite List.Forall_forall in Hb.
      apply Hb. rewrite (Permuted_sort s) at 2.
      rewrite (Permuted_sort s) in Hin. destruct (sort s).
      inversion Hin. now left.
      assert (Hneq' : List.hd r (sort s) <> r). { intro. apply Hneq. now symmetry. }
      revert Hneq'. generalize (sort_min s r r Hin). apply Rle_neq_lt.
Qed.

Instance is_extremal_perm_invariant : Proper (eq ==> @Permutation R ==> eq) is_extremal.
Proof.
intros x y ? s s' Hs. subst. unfold is_extremal. 
assert (Heq : sort s = sort s'). now rewrite Hs. now rewrite Heq.
Qed.

Definition monotonic {A B : Type} (RA : relation A) (RB : relation B) (f : A -> B) :=
  Proper (RA ==> RB) f \/ Proper (RA --> RB) f.

Notation injective f := (forall x y, f x = f y -> x = y).

Lemma similarity_monotonic : forall k t, monotonic Rleb Rleb (fun x => k * (x - t)).
Proof.
intros k t. destruct (total_order_T 0 k) as [[Hlt | H0] | Hlt].
+ left. repeat intro. hnf in *. rewrite Rleb_spec in *. apply Rmult_le_compat_l; lra.
+ subst k. left. repeat intro. setoid_rewrite Rmult_0_l. hnf. rewrite Rleb_spec. apply Rle_refl.
+ right. repeat intro. hnf in *. rewrite Rleb_spec in *. apply Ropp_le_cancel.
  replace (- (k * (y - t))) with ((- k) * (y - t)) by ring.
  replace (- (k * (x - t))) with ((- k) * (x - t)) by ring.
  apply Rmult_le_compat_l; lra.
Qed.

Lemma similarity_injective : forall k t, k <> 0 -> injective (fun x => k * (x - t)).
Proof. intros k t Hk x y. now rewrite local_invert. Qed.


Lemma is_extremal_map_monotonic_invariant : forall f, monotonic Rleb Rleb f -> injective f -> 
  forall x l, is_extremal (f x) (map f l) = is_extremal x l.
Proof.
intros f Hfmon Hfinj x l. unfold is_extremal. destruct Hfmon as [Hfinc | Hfdec].
+ rewrite (sort_map_increasing Hfinc). rewrite map_hd, map_last.
  repeat Rdec_full; reflexivity || (apply Hfinj in Heq; contradiction)
                     || (now rewrite Heq in Hneq at 1; auto) || (rewrite Heq in Hneq0 at 1; auto).
+ rewrite (sort_map_decreasing Hfdec). rewrite hd_rev_last, last_rev_hd, map_hd, map_last.
  repeat Rdec_full; reflexivity || (apply Hfinj in Heq; contradiction)
                     || (now rewrite Heq in Hneq at 1; auto) || (rewrite Heq in Hneq0 at 1; auto).
Qed.

Corollary is_extremal_similarity_invariant : forall k t pos r, k <> 0 ->
  is_extremal (k * (r - t)) (nominal_spectrum (⟦k, t⟧ pos)) = is_extremal r (nominal_spectrum pos).
Proof.
intros k t pos r Hk. rewrite nominal_spectrum_similarity.
now rewrite (is_extremal_map_monotonic_invariant (similarity_monotonic k t) (similarity_injective Hk)).
Qed.

Definition extreme_center (s : spectrum) :=
  (List.hd 0 (sort s) + List.last (sort s) 0) / 2.
(* When there is no robot (s is empty), the center is 0. *)

Instance extreme_center_perm_invariant : Proper (@Permutation R ==> eq) extreme_center.
Proof. intros s s' Hs. unfold extreme_center. now rewrite Hs. Qed.

Lemma extreme_center_map_similarity_invariant : forall k t, k <> 0 ->
  forall l, l <> nil -> extreme_center (map (fun x => k * (x - t)) l) = k * (extreme_center l - t).
Proof.
intros k t Hk l Hl. destruct (similarity_monotonic k t) as [Hinc | Hdec].
+ unfold extreme_center. rewrite (sort_map_increasing Hinc). generalize 0.
  assert (Hperm := Permuted_sort l). destruct (sort l) as [| x l']; intro r.
    symmetry in Hperm. apply Permutation_nil in Hperm. contradiction.
    clear l Hl Hperm. simpl hd. cut (x :: l' <> nil). generalize (x :: l'). intro l.
    revert r. induction l; intros r Hl.
      now elim Hl.
      simpl. destruct l.
        simpl. field.
        rewrite <- IHl. reflexivity. discriminate. discriminate.
+ unfold extreme_center. rewrite (sort_map_decreasing Hdec).
  rewrite last_rev_hd, hd_rev_last. generalize 0.
  assert (Hperm := Permuted_sort l). destruct (sort l) as [| x l']; intro r.
    symmetry in Hperm. apply Permutation_nil in Hperm. contradiction.
    clear l Hl Hperm. simpl hd. cut (x :: l' <> nil). generalize (x :: l'). intro l.
    revert r. induction l; intros r Hl.
      now elim Hl.
      simpl. destruct l.
        simpl. field.
        rewrite <- IHl. reflexivity. discriminate. discriminate.
Qed.

Lemma extreme_center_similarity_invariant : forall k t pos, k <> 0 ->
  extreme_center (nominal_spectrum (⟦k, t⟧ pos)) = k * (extreme_center (nominal_spectrum pos) - t).
Proof.
intros k t pos Hk. rewrite nominal_spectrum_similarity, extreme_center_map_similarity_invariant; trivial.
rewrite nominal_spectrum4. discriminate.
Qed.
(* it requires to notice that similarity is monotonous and therefore may only reverse the order *)


Definition robogram (s : spectrum) : location :=
  if is_forbidden s then 0 else
  match majority_stack s with
    | NoResult => 0 (* there is no robots anyway in this case *)
    | Valid p n => p
    | Invalid n => if is_extremal 0 s then 0 else extreme_center s end.

Print Assumptions robogram.

(** The robogram is invariant by permutation of spectra. *)
Instance robogram_invariant : Proper (@Permutation R ==> eq) robogram.
Proof.
unfold robogram. intros s s' Hperm. rewrite Hperm.
destruct (is_forbidden s') eqn:Hforbidden.
- reflexivity.
- rewrite Hperm. destruct (majority_stack s'); trivial. now do 2 rewrite Hperm.
Qed.
Print Assumptions robogram_invariant.


Lemma nominal_spectrum_alls : forall pt,
  nominal_spectrum (@lift_gp Four (fun _ => pt)) = alls pt 4.
Proof.
intro pt. unfold lift_gp, nominal_spectrum, fold_left. simpl.
now repeat (rewrite fold_left_from_equation; simpl).
Qed.

Lemma forbidden_similarity_invariant : forall pos k t, forbidden ((⟦k, t⟧) pos) -> forbidden pos.
Proof.
intros [gp bp] k t [p1 [p2 [n [Hneq Hperm]]]]. destruct (Rdec k 0).
+ subst. assert (Heq : PosEq (lift_gp (fun _ => 0)) (⟦0, t⟧ {| gp := gp; bp := bp |})).
  { split; simpl. intro. now rewrite Rmult_0_l. intros []. }
  rewrite <- Heq in Hperm. clear Heq. rewrite nominal_spectrum_alls in Hperm.
  symmetry in Hperm. apply Permutation_alls in Hperm.
  destruct n as [| [| [| [| [| n]]]]]; simpl in Hperm; inversion Hperm. subst. now elim Hneq.
+ exists (p1 / k + t). exists (p2 / k + t). exists n. split.
  clear -Hneq n0. intro Habs. apply Hneq. apply Rdiv_reg with k. assumption.
  apply Rplus_eq_reg_l with t. now setoid_rewrite Rplus_comm.
  clear Hneq. rewrite <- (@similarity_inverse _ _ k t); trivial. unfold similarity at 1.
  replace (p1 / k + t) with (/k * (p1 - - k * t)) by now field.
  change (/k * (p1 - - k * t)) with ((fun x => /k * (x - - k * t)) p1). rewrite <- map_alls.
  replace (p2 / k + t) with (/k * (p2 - - k * t)) by now field.
  change (/k * (p2 - - k * t)) with ((fun x => /k * (x - - k * t)) p2). rewrite <- map_alls.
  rewrite nominal_spectrum_map. rewrite <- map_app. now apply Permutation_map.
Qed.

Corollary forbidden_similarity_iff : forall k t pos, k <> 0 -> (forbidden (⟦k, t⟧ pos) <-> forbidden pos).
Proof.
intros k t pos Hk. split.
+ apply forbidden_similarity_invariant.
+ rewrite <- is_forbidden_true. rewrite <- (similarity_inverse t pos Hk) at 1.
  rewrite is_forbidden_true. apply forbidden_similarity_invariant.
Qed.

Corollary is_forbidden_similarity_invariant : forall k t pos, k <> 0 ->
  is_forbidden (nominal_spectrum (⟦k, t⟧ pos)) = is_forbidden (nominal_spectrum pos).
Proof.
intros k t pos Hk. destruct (is_forbidden (nominal_spectrum pos)) eqn:Hpos.
  now rewrite is_forbidden_true, forbidden_similarity_iff, <- is_forbidden_true.
  now rewrite is_forbidden_false, forbidden_similarity_iff, <- is_forbidden_false.
Qed.

(** If [k = 0], then all robots are collapsed on a single location and any position ⟦k, t⟧ pos is not fobidden. **)

Lemma forbidden_still : forall (da : demonic_action Four Zero) pos,
  forbidden pos -> PosEq (lift_gp (round robogram da pos.(gp))) pos.
Proof.
intros [] pos Hforbidden. assert (Hdes := Hforbidden). destruct Hdes as [p1 [p2 [Hneq Hperm]]].
split; intro n; try now destruct n. unfold round. simpl.
destruct (Rdec (frame n) 0). reflexivity.
rewrite <- Rplus_0_r. f_equal. erewrite <- Rmult_0_r. f_equal.
unfold robogram.
rewrite spectrum_ok.
assert (is_forbidden (nominal_spectrum ((⟦frame n, gp pos n⟧) {| gp := gp pos; bp := locate_byz |}))
        = is_forbidden (nominal_spectrum {| gp := gp pos; bp := locate_byz |})) as Heq.
{ case_eq (is_forbidden (nominal_spectrum ((⟦frame n, gp pos n⟧) {| gp := gp pos; bp := locate_byz |}))); intro Heq.
  - rewrite is_forbidden_true in Heq. rewrite forbidden_similarity_iff in Heq; trivial.
    now rewrite <- is_forbidden_true in Heq.
  - rewrite is_forbidden_false in Heq. rewrite forbidden_similarity_iff in Heq; trivial.
    now rewrite <- is_forbidden_false in Heq. }
rewrite Heq. clear Heq. rewrite <- is_forbidden_true in Hforbidden.
assert (Hpos : PosEq ({| gp := gp pos; bp := locate_byz |}) pos). { split; now intros || now intros []. }
rewrite Hpos. clear Hpos. now rewrite Hforbidden.
Qed.

(*
Theorem forbidden_round : forall (da : demonic_action Four Zero) pos,
  forbidden (lift_gp (round robogram da pos.(gp))) <-> forbidden pos.
Proof.
intros da pos. split; intro Hpos.
+ destruct Hpos as [p1 [p2 [n [Hneq Hp]]]]. unfold robogram in *.
  
+ rewrite <- is_forbidden_true. rewrite (forbidden_still da Hpos). now rewrite is_forbidden_true.
Qed.
*)
Theorem never_forbidden : forall (da : demonic_action Four Zero) pos,
  ~forbidden pos -> ~forbidden (lift_gp (round robogram da pos.(gp))).
Proof.
intros da pos Hpos.
assert (ExtEq (round robogram da (gp pos)) 
              (fun g : Four =>
              if Rdec (frame da g) 0 then gp pos g
              else gp pos g + / frame da g * robogram (nominal_spectrum
            ((⟦frame da g, gp pos g⟧) {| gp := gp pos; bp := locate_byz da |})))).
{ intro n. unfold round. destruct (Rdec (frame da n) 0). reflexivity. now rewrite spectrum_ok. }
rewrite H.
Admitted.

Definition equiv_by (f : R -> R) r r' :=
  match r, r' with
    | NoResult, NoResult => True
    | Valid y m, Valid x n => y = f x /\ m = n
    | Invalid m, Invalid n => m = n
    | _, _ => False
  end.

Lemma majority_stack_inj_compat_aux : forall f l x n r r',
  injective f -> equiv_by f r r' ->
  (List.fold_left (fun acc xn => f_majority (fst xn) (snd xn) acc)
                  (map (fun xn => (f (fst xn), snd xn)) l) r = Valid (f x) n
  <-> List.fold_left (fun acc xn => f_majority (fst xn) (snd xn) acc) l r' = Valid x n).
Proof.
intros f l x n r r' Hf. revert r r'. induction l; intros r r' Hr; simpl.
+ split; intro; (subst r; destruct r') || (subst r'; destruct r); simpl in Hr; try now elim Hr.
    destruct Hr as [Hr1 Hr2]. apply Hf in Hr1. now subst.
    destruct Hr. now subst.
+ apply IHl. destruct a as [y m], r, r'; simpl; simpl in Hr; try now elim Hr.
    destruct Hr. subst. now destruct (nat_compare m n1).
    subst. now destruct (nat_compare m n1).
Qed.

Instance PermutationA_compat A eqA (HeqA : @Equivalence A eqA) :
  Proper (PermutationA eqA ==> PermutationA eqA ==> iff) (PermutationA eqA).
Proof. intros l1 l2 Hl12 l3 l4 Hl34. now rewrite Hl12, Hl34. Qed.

Lemma majority_stack_inj_map_Valid_compat : forall f l x n, injective f ->
  (majority_stack (map f l) = Valid (f x) n <-> majority_stack l = Valid x n).
Proof.
intros f l x n Hf. do 2 rewrite majority_stack_Valid_spec. split; intros [Hn Hle]; split.
+ clear Hle. revert n Hn. induction l; simpl; intros n Hn.
    now rewrite multiset_nil, M.empty_spec in *.
    destruct (Rdec a x) as [| Hneq].
      subst a. rewrite multiset_cons, M.add_spec in *. destruct n. omega.
      rewrite plus_comm in *; simpl in *. f_equal. apply eq_add_S in Hn. now apply IHl.
      assert (f a <> f x) by auto.
      rewrite multiset_cons, M.add_spec' in *; trivial. now apply IHl.
+ clear Hn. intros y Hxy. assert (Hn : f x <> f y) by auto. apply Hle in Hn. revert Hn. clear Hle Hxy.
  revert n y. induction l; simpl; intros n y Hin.
    now rewrite multiset_nil, M.empty_spec in *.
    rewrite multiset_cons in *. destruct (Rdec a y).
      subst a. rewrite M.add_spec in *. destruct n. omega.
      rewrite plus_comm in *; simpl in *. apply lt_n_S. apply lt_S_n in Hin. now apply IHl.
      assert (f a <> f y) by auto. rewrite M.add_spec' in *; trivial. now apply IHl.
+ clear Hle. revert n Hn. induction l; simpl; intros n Hn.
    now rewrite multiset_nil, M.empty_spec in *.
    destruct (Rdec a x) as [| Hneq].
      subst a. rewrite multiset_cons, M.add_spec in *. destruct n. omega.
      rewrite plus_comm in *; simpl in *. f_equal. apply eq_add_S in Hn. now apply IHl.
      assert (f a <> f x) by auto.
      rewrite multiset_cons, M.add_spec' in *; trivial. now apply IHl.
+ clear Hn. intros y Hxy. destruct (in_dec Rdec y (map f l)) as [Hin | Hin].
  - rewrite in_map_iff in Hin. destruct Hin as [z [Hyz Hin]]. subst y.
    assert (Hxz : x <> z). { intro. subst z. now apply Hxy. }
    apply Hle in Hxz. clear Hle Hxy Hin. revert n z Hxz. induction l; intros n z Hin.
      now rewrite multiset_nil, M.empty_spec in *.
      simpl. rewrite multiset_cons in *. destruct (Rdec a z).
        subst a. rewrite M.add_spec in *. destruct n. omega.
        rewrite plus_comm in *; simpl in *. apply lt_n_S. apply lt_S_n in Hin. now apply IHl.
        assert (f a <> f z) by auto. rewrite M.add_spec' in *; trivial. now apply IHl.
  - destruct n.
      specialize (Hle _ (succ_neq x)). omega.
      rewrite <- multiset_In in Hin. omega.
Qed.

Lemma majority_stack_Valid_similarity : forall k t pos x n, k <> 0 -> 
  (majority_stack (nominal_spectrum ((⟦k, t⟧) pos)) = Valid (k * (x - t)) n
  <-> majority_stack (nominal_spectrum pos) = Valid x n).
Proof.
intros k t pos x n Hk. rewrite nominal_spectrum_similarity.
assert (Hf := fun x y => proj1 (@local_invert k t x y Hk)).
now rewrite (majority_stack_inj_map_Valid_compat _ _ _ _ Hf).
Qed.

Lemma majority_stack_Invalid_similarity : forall k t pos n, k <> 0 -> 
  (majority_stack (nominal_spectrum ((⟦k, t⟧) pos)) = Invalid n
  <-> majority_stack (nominal_spectrum pos) = Invalid n).
Proof.
intros k t pos n Hk. rewrite nominal_spectrum_similarity. generalize (nominal_spectrum pos). clear pos.
intro s. do 2 rewrite majority_stack_Invalid_spec. split; intros [Hn [x [y [Hx [Hy [Hxy Hle]]]]]].
* split. assumption. exists (/k * x + t). exists (/k * y + t). repeat split.
  + clear y Hxy Hy Hle. revert n Hn Hx. induction s; simpl; intros n Hn Hx.
      now rewrite multiset_nil, M.empty_spec in *.
      rewrite multiset_cons in *. destruct (Rdec (k * (a - t)) x) as [Heq | Hneq].
      - subst x. assert (/k * (k * (a - t)) + t = a) by now field. rewrite H in *.
        rewrite M.add_spec in *. destruct n. omega. rewrite plus_comm in *. simpl in *.
        f_equal. apply eq_add_S in Hx. destruct n.
          assert (Hin : ~In (k * (a - t)) (map (fun x : R => k * (x - t)) s)). { rewrite <- multiset_In. omega. }
          rewrite in_map_iff in Hin. destruct (in_dec Rdec a s) as [| Hnin].
            elim Hin. exists a. now split.
            rewrite <- multiset_In in Hnin. omega.
          apply IHs. omega. assumption.
      - assert (a <> /k * x + t). { intro. subst a. apply Hneq. admit. } (* PB pour avoir field sur M.elt = R *)
        rewrite M.add_spec' in *; trivial. now apply IHs.
  + clear x Hxy Hx Hle. revert n Hn Hy. induction s; simpl; intros n Hn Hy.
      now rewrite multiset_nil, M.empty_spec in *.
      rewrite multiset_cons in *. destruct (Rdec (k * (a - t)) y) as [Heq | Hneq].
      - subst y. assert (/k * (k * (a - t)) + t = a) by now field. rewrite H in *.
        rewrite M.add_spec in *. destruct n. omega. rewrite plus_comm in *. simpl in *.
        f_equal. apply eq_add_S in Hy. destruct n.
          assert (Hin : ~In (k * (a - t)) (map (fun x : R => k * (x - t)) s)). { rewrite <- multiset_In. omega. }
          rewrite in_map_iff in Hin. destruct (in_dec Rdec a s) as [| Hnin].
            elim Hin. exists a. now split.
            rewrite <- multiset_In in Hnin. omega.
          apply IHs. omega. assumption.
      - assert (a <> /k * y + t). { intro. subst a. apply Hneq. admit. } (* PB pour avoir field sur M.elt = R *)
        rewrite M.add_spec' in *; trivial. now apply IHs.
  + rewrite <- (local_invert t _ _ Hk). intro Heq. field_simplify in Heq; auto. apply Hxy.
    assert (x / 1 = x) by field. rewrite <- H, Heq. now assert (y / 1 = y) by field.
  + clear x y Hx Hy Hxy. intro z. specialize (Hle (k * (z - t))).
    revert n Hn Hle. induction s; simpl; intros n Hn Hle.
      rewrite multiset_nil, M.empty_spec. omega.
      rewrite multiset_cons in *. destruct (Rdec a z).
      - subst z. rewrite M.add_spec in *. destruct n. omega. rewrite plus_comm in *. simpl in *.
        apply le_n_S. apply le_S_n in Hle. destruct n.
          assert (Hin : ~In (k * (a - t)) (map (fun x : R => k * (x - t)) s)). { rewrite <- multiset_In. omega. }
          rewrite in_map_iff in Hin. destruct (in_dec Rdec a s) as [| Hnin].
            elim Hin. exists a. now split.
            rewrite <- multiset_In in Hnin. omega.
          apply IHs. omega. assumption.
      - assert (k * (a - t) <> k * (z - t)) by now rewrite local_invert.
        rewrite M.add_spec' in *; trivial. now apply IHs.
* split. assumption. exists (k * (x - t)). exists (k * (y - t)). repeat split.
  + clear y Hxy Hy Hle. revert n Hn Hx. induction s; simpl; intros n Hn Hx.
      now rewrite multiset_nil, M.empty_spec in *.
      rewrite multiset_cons in *. destruct (Rdec a x) as [Heq | Hneq].
      - subst x. rewrite M.add_spec in *. destruct n. omega. rewrite plus_comm in *. simpl in *.
        f_equal. apply eq_add_S in Hx. destruct n.
          assert (Hnin : ~In a s). { rewrite <- multiset_In. omega. } 
          assert (Hin : ~In (k * (a -t)) (map (fun x : R => k * (x - t)) s)).
          { rewrite in_map_iff. intros [x [Heq Hin]]. apply Hnin. rewrite local_invert in Heq; trivial. now subst a. }
          rewrite <- multiset_In in Hin. omega.
          apply IHs. omega. assumption.
      - assert (k * (a - t) <> k * (x - t)) by now rewrite local_invert.
        rewrite M.add_spec' in *; trivial. now apply IHs.
  + clear x Hxy Hx Hle. revert n Hn Hy. induction s; simpl; intros n Hn Hy.
      now rewrite multiset_nil, M.empty_spec in *.
      rewrite multiset_cons in *. destruct (Rdec a y) as [Heq | Hneq].
      - subst y. rewrite M.add_spec in *. destruct n. omega. rewrite plus_comm in *. simpl in *.
        f_equal. apply eq_add_S in Hy. destruct n.
          assert (Hnin : ~In a s). { rewrite <- multiset_In. omega. } 
          assert (Hin : ~In (k * (a -t)) (map (fun x : R => k * (x - t)) s)).
          { rewrite in_map_iff. intros [x [Heq Hin]]. apply Hnin. rewrite local_invert in Heq; trivial. now subst a. }
          rewrite <- multiset_In in Hin. omega.
          apply IHs. omega. assumption.
      - assert (k * (a - t) <> k * (y - t)) by now rewrite local_invert.
        rewrite M.add_spec' in *; trivial. now apply IHs.
  + now rewrite (local_invert t _ _ Hk).
  + clear x y Hx Hy Hxy. intro z. specialize (Hle (/k * z + t)).
    revert n Hn Hle. induction s; simpl; intros n Hn Hle.
      rewrite multiset_nil, M.empty_spec. omega.
      rewrite multiset_cons in *. destruct (Rdec (k * (a - t)) z) as [| Hneq].
      - subst z. assert (/ k * (k * (a - t)) + t = a) by now field. rewrite H in *.
        rewrite M.add_spec in *. destruct n. omega. rewrite plus_comm in *. simpl in *.
        apply le_n_S. apply le_S_n in Hle. destruct n.
          assert (Hnin : ~In a s). { rewrite <- multiset_In. omega. }
          assert (Hin : ~In (k * (a -t)) (map (fun x : R => k * (x - t)) s)).
          { rewrite in_map_iff. intros [x [Heq Hin]]. apply Hnin. rewrite local_invert in Heq; trivial. now subst a. }
          rewrite <- multiset_In in Hin. omega.
          apply IHs. omega. assumption.
      - assert (a <> /k * z + t).
        { intro Habs. rewrite <- (local_invert t _ _ Hk) in Habs. apply Hneq. rewrite Habs. now field. }
        rewrite M.add_spec' in *; trivial. now apply IHs.
Qed.

Theorem robogram_similarity_invariant : forall k t pos, k <> 0 ->
  robogram (nominal_spectrum (⟦k, t⟧ pos)) = k * (robogram (nominal_spectrum (⟦1, t⟧ pos))).
Proof.
intros k t pos Hk. unfold robogram.
rewrite is_forbidden_similarity_invariant; trivial.
rewrite is_forbidden_similarity_invariant; try now apply R1_neq_R0.
destruct (is_forbidden (nominal_spectrum pos)). ring.
destruct (majority_stack (nominal_spectrum  (⟦k, t⟧ pos))) eqn:Hmaj.
+ rewrite majority_stack_NoResult_spec, nominal_spectrum4 in Hmaj. discriminate Hmaj.
+ assert (Hl : l = k * ((/k * l + t) - t)) by now field.
  rewrite Hl, majority_stack_Valid_similarity in Hmaj; trivial. clear Hl.
  destruct (majority_stack (nominal_spectrum  (⟦1, t⟧ pos))) eqn:Hmaj1.
  - rewrite majority_stack_NoResult_spec, nominal_spectrum4 in Hmaj1. discriminate Hmaj1.
  - replace l0 with (1 * (l0 + t - t)) in Hmaj1 by ring. rewrite majority_stack_Valid_similarity in Hmaj1.
    rewrite Hmaj1 in Hmaj. inversion Hmaj. subst n0. clear Hmaj1 Hmaj.
    setoid_rewrite Rplus_comm in H0. apply Rplus_eq_reg_l in H0. subst l0. now field. apply R1_neq_R0.
  - rewrite majority_stack_Invalid_similarity in Hmaj1; try exact R1_neq_R0.
    rewrite Hmaj1 in Hmaj. discriminate Hmaj.
+ rewrite majority_stack_Invalid_similarity in Hmaj; trivial.
  rewrite <- (@majority_stack_Invalid_similarity 1) in Hmaj; try exact R1_neq_R0. rewrite Hmaj.
  assert (H0 : forall k, k * (t - t) = 0) by (intro; ring). rewrite <- (H0 k) at 1. rewrite <- (H0 1) at 2.
  repeat rewrite is_extremal_similarity_invariant; exact R1_neq_R0 || trivial.
  destruct (is_extremal t (nominal_spectrum pos)). ring.
  repeat rewrite extreme_center_similarity_invariant; exact R1_neq_R0 || trivial. ring.
Qed.
Print Assumptions robogram_similarity_invariant.

(*
(* This inductive expresses that there will be a stack (in the sense of [Stack] and [has_dups]).
   It does not express that all robots are stacked (it is the purpose of Gather). *)
Inductive Will_stack (e : execution Four) :=
  | AlreadyStacked : Stack (lift_gp (execution_head e)) -> Will_stack e
  | After :  Will_stack (execution_tail e) -> Will_stack e.
*)

(* To simplify proofs in a first pass. *)
Axiom active : forall da n, @frame Four Zero da n <> 0. 

Theorem Will_stack : forall da pos, ~forbidden pos -> ~Stack pos ->
  Stack (lift_gp (round (B:=Zero) robogram da pos.(gp))).
Proof.
intros da pos Hok Hyet.
rewrite <- majority_stack_spec in Hyet.
assert (exists n, majority_stack (nominal_spectrum pos) = Invalid n).
{ destruct (majority_stack (nominal_spectrum pos)) eqn:Hpos.
  - rewrite majority_stack_NoResult_spec in Hpos. rewrite nominal_spectrum4 in Hpos. discriminate Hpos.
  - elim Hyet. exists l. exists n. reflexivity. 
  - exists n. reflexivity. }
destruct H as [n Hn]. clear Hyet.
(* We express more directly the position after one round *)
assert (Heq : ExtEq (round robogram da (gp pos))
             (fun g => if is_extremal (gp pos g) (nominal_spectrum pos)
                       then gp pos g else extreme_center (nominal_spectrum pos))).
{ intro g. unfold round. destruct (Rdec (frame da g) 0) as [| Hframe]. now elim (active da g).
  rewrite (spectrum_ok da). rewrite robogram_similarity_invariant; trivial. field_simplify; trivial. clear Hframe.
  unfold robogram.
  rewrite is_forbidden_similarity_invariant; try exact R1_neq_R0. rewrite <- is_forbidden_false in Hok.
  rewrite (lift_gp_equiv {| gp := gp pos; bp := locate_byz da |}). simpl. rewrite <- lift_gp_equiv.
  rewrite Hok.
  rewrite (lift_gp_equiv {| gp := gp pos; bp := locate_byz da |}). simpl. rewrite <- lift_gp_equiv.
  rewrite <- (@majority_stack_Invalid_similarity 1) in Hn; try exact R1_neq_R0. rewrite Hn.
  assert (H0 : 1 * (gp pos g - gp pos g) = 0) by ring.
  rewrite <- H0 at 1. rewrite is_extremal_similarity_invariant; try exact R1_neq_R0.
  rewrite (lift_gp_equiv {| gp := gp pos; bp := locate_byz da |}). simpl. rewrite <- lift_gp_equiv.
  destruct (is_extremal (gp pos g) (nominal_spectrum pos)). field.
  rewrite extreme_center_similarity_invariant; try exact R1_neq_R0. field_simplify.
  rewrite (lift_gp_equiv {| gp := gp pos; bp := locate_byz da |}). simpl. rewrite <- lift_gp_equiv.
  reflexivity. }
(* Because we have only four robots and the position is not forbidden, we have n = 1. *)
assert (Heqn : n = 1%nat).
{ destruct n as [| [| n]].
  - elim (majority_stack_Invalid_0 Hn).
  - reflexivity.
  - rewrite majority_stack_Invalid_spec in Hn. destruct Hn as [_ [x [y [Hx [Hy [Hxy Hle]]]]]]. exfalso.
    apply multiset_Permutation in Hx. destruct Hx as [l [Hinx Hpermx]].
    rewrite Hpermx, multiset_app, M.union_spec, multiset_alls, M.singleton_spec in Hy; try omega.
    destruct (Rdecidable.eq_dec y x). now elim Hxy. simpl in Hy.
    apply multiset_Permutation in Hy. destruct Hy as [l' [Hiny Hpermy]].
    assert (Hperm : Permutation (nominal_spectrum pos) (alls x (S (S n)) ++ (alls y (S (S n)) ++ l'))).
    { transitivity (alls x (S (S n)) ++ l). assumption. now apply Permutation_app_head. }
    assert (n = 0 /\ length l' = 0)%nat.
    { apply Permutation_length in Hperm. do 2 rewrite app_length, alls_length in Hperm.
      rewrite nominal_spectrum4 in Hperm. simpl in Hperm. omega. }
      destruct H as [? Hl']. subst n.
      elim Hok. exists x. exists y. exists 2%nat. split. assumption.
      destruct l'. now rewrite app_nil_r in Hperm. simpl in Hl'. omega. }
subst n.
apply majority_stack_Invalid_1 in Hn. rename Hn into Hdup.
assert (Hl : length (sort (nominal_spectrum pos)) = 4%nat).
{ rewrite (Permutation_length (symmetry (Permuted_sort _))). now rewrite nominal_spectrum4. }
assert (Hperm := Permuted_sort (nominal_spectrum pos)).
assert (Hsort := Sorted_sort (nominal_spectrum pos)).
destruct (sort (nominal_spectrum pos)) as [| x [| y [| z [| t [| ]]]]] eqn:Hs; try discriminate Hl. clear Hl.
inversion_clear Hsort. inversion_clear H. inversion_clear H1. clear H. unfold is_true in *. rewrite Rleb_spec in *.
assert (Hd := Hdup). rewrite Hperm in Hd. inversion_clear Hd. inversion_clear H1. inversion_clear H5.
assert (Hxy : x < y). { apply Rle_neq_lt. assumption. intro. subst y. apply H. now left. }
assert (Hyz : y < z). { apply Rle_neq_lt. assumption. intro. subst y. apply H4. now left. }
assert (Hzt : z < t). { apply Rle_neq_lt. assumption. intro. subst z. apply H1. now left. }
clear H H0 H1 H2 H3 H4 H6.
assert (Hdiff : forall g1 g2, gp pos g1 = gp pos g2 -> g1 = g2).
{ intros g1 g2 Hg. rewrite nominal_spectrum4 in Hperm, Hdup. inversion_clear Hdup.
  assert (gp pos Four4 <> gp pos Three4 /\ gp pos Four4 <> gp pos Two4 /\ gp pos Four4 <> gp pos One4).
  { repeat split; intro Habs; apply H; rewrite Habs; intuition. }
  clear H. inversion_clear H0.
  assert (gp pos Three4 <> gp pos Two4 /\ gp pos Three4 <> gp pos One4).
  { repeat split; intro Habs; apply H; rewrite Habs; intuition. }
  clear H. inversion_clear H2.
  assert (gp pos Two4 <> gp pos One4). { intro Habs; apply H; rewrite Habs; intuition. }
  clear H.
  destruct g1, g2; reflexivity || contradict Hg; intuition. }
assert (Hxt : x <> t). { apply Rlt_not_eq. apply Rlt_trans with y. assumption. now apply Rlt_trans with z. }
assert (Permutation (nominal_spectrum (lift_gp (round robogram da (gp pos)))) (x :: (x+t)/2 :: (x+t)/2 :: t :: nil)).
{ rewrite Heq. unfold is_extremal, extreme_center. rewrite Hs. simpl.
  rewrite nominal_spectrum4 in Hperm |- *. simpl. repeat Rdec_full; subst;
  try match goal with | H : gp pos ?X = gp pos ?Y |- _ => apply Hdiff in H; discriminate H end.
  (* 21 cases to consider *)
  - constructor 2. etransitivity. constructor 3. constructor 2. constructor 3.
  - do 2 constructor 2. constructor 3.
  - reflexivity.
  - assert (Hin : In t (gp pos Four4 :: y :: z :: t :: nil)) by intuition.
    rewrite <- Hperm in Hin. destruct Hin as [| [| [| [| ]]]]; contradiction.
  - etransitivity. constructor 3. constructor 2. etransitivity. constructor 3. repeat constructor.
  - etransitivity. apply Permutation_rev. simpl. etransitivity. constructor 3. reflexivity.
  - etransitivity. apply Permutation_rev. reflexivity.
  - assert (Hin : In x (x :: y :: z :: gp pos Four4 :: nil)) by intuition.
    rewrite <- Hperm in Hin. destruct Hin as [| [| [| [| ]]]]; contradiction.
  - etransitivity. constructor 3. repeat constructor.
  - etransitivity. constructor 3. repeat constructor.
  - assert (Hin : In t (gp pos Three4 :: y :: z :: t :: nil)) by intuition.
    rewrite <- Hperm in Hin. destruct Hin as [| [| [| [| ]]]]; contradiction.
  - symmetry. etransitivity. constructor 3. constructor 2. etransitivity. apply Permutation_rev. simpl.
    repeat constructor.
  - etransitivity. apply Permutation_rev. simpl. repeat constructor.
  - assert (Hin : In x (x :: y :: z :: gp pos Three4 :: nil)) by intuition.
    rewrite <- Hperm in Hin. destruct Hin as [| [| [| [| ]]]]; contradiction.
  - symmetry. etransitivity. constructor 3. repeat constructor.
  - assert (Hin : In t (gp pos Two4 :: y :: z :: t :: nil)) by intuition.
    rewrite <- Hperm in Hin. destruct Hin as [| [| [| [| ]]]]; contradiction.
  - etransitivity. apply Permutation_rev. simpl. repeat constructor. apply Permutation_rev.
  - assert (Hin : In x (x :: y :: z :: gp pos Two4 :: nil)) by intuition.
    rewrite <- Hperm in Hin. destruct Hin as [| [| [| [| ]]]]; contradiction.
  - assert (Hin : In t (gp pos One4 :: y :: z :: t :: nil)) by intuition.
    rewrite <- Hperm in Hin. destruct Hin as [| [| [| [| ]]]]; contradiction.
  - assert (Hin : In x (x :: y :: z :: gp pos One4 :: nil)) by intuition.
    rewrite <- Hperm in Hin. destruct Hin as [| [| [| [| ]]]]; contradiction.
  - assert (Hin : In x (x :: y :: z :: t :: nil)) by intuition.
    rewrite <- Hperm in Hin. destruct Hin as [| [| [| [| ]]]]; contradiction. }
assert (x <> (x + t) / 2) by lra. assert (t <> (x + t) / 2) by lra.
exists (extreme_center (nominal_spectrum pos)). exists 2%nat. split.
+ unfold is_extremal, extreme_center. rewrite Hs, H. simpl. repeat rewrite multiset_cons.
  now rewrite M.add_spec', M.add_spec, M.add_spec, M.add_spec', multiset_nil, M.empty_spec.
+ unfold is_extremal, extreme_center. intro pt. rewrite Hs, H. simpl. repeat rewrite multiset_cons.
  intro Hy. destruct (Rdec x pt).
    subst pt. now rewrite M.add_spec, M.add_spec', M.add_spec', M.add_spec', multiset_nil, M.empty_spec; auto.
    destruct (Rdec t pt).
      subst pt. now rewrite M.add_spec', M.add_spec', M.add_spec', M.add_spec, multiset_nil, M.empty_spec; auto.
      now rewrite M.add_spec', M.add_spec', M.add_spec', M.add_spec', multiset_nil, M.empty_spec; auto.
Qed.


Lemma gathered_at_PosEq : forall (gp : Four -> R) pt, gathered_at gp pt -> ExtEq gp (fun _ => pt).
Proof. intros gp pt Hgather. intro n. apply Hgather. Qed.

Theorem gathered_at_round : forall pt gp (da : demonic_action Four Zero),
  gathered_at gp pt -> gathered_at (round robogram da gp) pt.
Proof.
intros pt gp [] Hgather. unfold round. simpl.
intro g. destruct (Rdec (frame g) 0). now apply Hgather.
rewrite Hgather. rewrite <- Rplus_0_r. f_equal. rewrite <- (Rmult_0_r (/ frame g)). f_equal.
unfold similarity. simpl. rewrite (spectrum_exteq g _ (lift_gp (fun _ => 0))). unfold robogram.
assert (spectrum_of g (lift_gp (fun _ => 0)) = alls 0 4) as Heq.
{ apply Permutation_alls.
  transitivity (nominal_spectrum (lift_gp (fun _ : Four => 0))).
    apply spectrum_ok.
    now rewrite nominal_spectrum_alls. }
rewrite Heq. rewrite is_forbidden_alls. unfold majority_stack.
rewrite multiset_alls, M.fold_singleton; simpl; try omega. reflexivity. now repeat intro; subst.
split; (now intros []) || intro x; simpl. rewrite Hgather, Rminus_diag_eq. now rewrite Rmult_0_r. reflexivity.
Qed.

Lemma gathered_at_Gather : forall pt (d : demon Four Zero) gp, gathered_at gp pt ->
  Gather pt (execute robogram d gp).
Proof.
intro pt. cofix gather. intros d gp Hgather. constructor. apply Hgather.
rewrite execute_tail. apply gather. now apply gathered_at_round.
Qed.

Theorem stack_sol : forall k (d : demon Four Zero), kFair k d ->
  forall gp : Four -> R, ~forbidden (lift_gp gp) ->
  Stack (lift_gp gp) ->
  exists pt, WillGather pt (execute robogram d gp).
Proof.
intros k [da d] Hfair gp Hok Hstack.
assert (Hs := Hstack). rewrite <- majority_stack_spec in Hs. destruct Hs as [pt [n Hpt]].
exists pt. constructor 2. constructor 1.
rewrite execute_tail. cofix gathered. constructor. clear gathered. simpl. unfold gathered_at.
intro g. unfold round.
pose (s := spectrum_of da g ((⟦frame da g, gp g⟧) {| gp := gp; bp := locate_byz da |})). fold s.
destruct (Rdec (frame da g) 0).
  now elim (active da g). (* Stalling case *)
  unfold robogram.
  assert (Hfor : is_forbidden s = false).
  { unfold s. rewrite spectrum_ok. rewrite is_forbidden_false. intro Habs. apply Hok.
    revert Habs. setoid_rewrite lift_gp_equiv at 2. simpl. apply forbidden_similarity_invariant. }
  rewrite Hfor. clear Hfor.
  assert (Hperm : Permutation s (nominal_spectrum (⟦frame da g, gp g⟧ {| gp := gp; bp := locate_byz da |})))
  by apply da.(spectrum_ok).
  rewrite <- is_forbidden_false in Hok. rewrite Hperm. setoid_rewrite lift_gp_equiv at 2.
  simpl. rewrite <- (majority_stack_Valid_similarity (gp g) _ _ _ (active da g)) in Hpt.
  rewrite Hpt. now field.
(* back to coinduction *)
apply gathered. (* je comprends toujours pas comment ça marche... ill-formed recursive definition *)
Admitted.

Theorem meeting4 :
  forall d : demon Four Zero, forall k, kFair k d -> solGathering robogram d.
Proof.
intros d k Hfair gp Hok.
destruct (majority_stack (nominal_spectrum (lift_gp gp))) as [| r n | n] eqn:Hdup.
  (* there is no robot *)
  rewrite majority_stack_NoResult_spec in Hdup. rewrite nominal_spectrum4 in Hdup. discriminate Hdup.
  (* there is a stack *)
  apply (stack_sol Hfair Hok). rewrite <- majority_stack_spec. now exists r; exists n.
  (* there is not stack, it will be created at the next step *)
  inversion_clear Hfair as [_ Htfair].
  destruct (stack_sol Htfair (@never_forbidden (demon_head d) _ Hok)) as [pt Hpt].
    apply Will_stack. assumption. rewrite <- majority_stack_spec.
    intros [x [m Habs]]. rewrite Hdup in Habs. discriminate Habs.
    exists pt. constructor 2. rewrite execute_tail. exact Hpt.
Qed.
Print Assumptions meeting4.

