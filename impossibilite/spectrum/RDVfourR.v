Require Import Bool.
Require Import Reals.
Require Import ConvergentFormalismR.
Require Import EqualitiesR.
Require Import FiniteSumR.
Require Import Morphisms.
Require Import Psatz.
Import Permutation.

Set Implicit Arguments.

Lemma le_neq_lt : forall m n : nat, (n <= m -> n <> m -> n < m)%nat.
Proof. intros n m Hle Hneq. now destruct (le_lt_or_eq _ _ Hle). Qed.

Lemma Rle_neq_lt : forall m n : R, n <= m -> n <> m -> n < m.
Proof. intros n m Hle Hneq. now destruct (Rle_lt_or_eq_dec _ _ Hle). Qed.


(* ************************************* *)
(** * Some necessary results on Reals.   *)
(* ************************************* *)

(** Small dedicated decision tactic for reals handling 1<>0 and r=r *)
Ltac Rdec := repeat
  match goal with
    | |- context[Rdec ?x ?x] =>
        let Heq := fresh "Heq" in destruct (Rdec x x) as [Heq | Heq];
        [clear Heq | exfalso; elim Heq; reflexivity]
    | |- context[Rdec 1 0] => 
        let Heq := fresh "Heq" in destruct (Rdec 1 0) as [Heq | Heq];
        [now elim R1_neq_R0 | clear Heq]
  end.

(** *  The Gathering Problem  **)

(** Vocabulary: we call a [location] the coordinate of a robot. We
    call a [position] a function from robots to position. An
    [execution] is an infinite (coinductive) stream of [position]s. A
    [demon] is an infinite stream of [demonic_action]s. *)

(** ** Some properties related to the gathering problem *)
(** [gathered_at pos pt] means that in position [pos] all robots
    are at the same location [pt] (exactly). *)
Definition gathered_at {G} (pos:G -> location) (pt:location) := forall r:G, pos r = pt.

(** [Gather pt e] means that at all rounds of (infinite) execution
    [e], robots are gathered at the same position [pt]. *)
CoInductive Gather {G} (pt: location) (e : execution G) : Prop :=
  Gathering : gathered_at (execution_head e) pt -> Gather pt (execution_tail e) -> Gather pt e.

(** [WillGather pt e] means that (infinite) execution [e] is
    *eventually* [Gather]ed. *)
Inductive WillGather {G} (pt : location) (e : execution G) : Prop :=
  | Now : Gather pt e -> WillGather pt e
  | Later : WillGather pt (execution_tail e) -> WillGather pt e.

(** [solGathering r d] means that any possible (infinite)
    execution, generated by demon [d] and robogram [r] and any intial
    position, will *eventually* be [Gather]ed. *)
Definition solGathering {G B} (r : robogram) (d : demon G B) :=
  forall (gp : G -> location), exists pt : location, WillGather pt (execute r d gp).

(** [Split p] means that position [p] contains to bijective sets of
    robots that do not share positions. *)
Definition Split {G} (p: (G ⊎ G) -> R) :=
  forall x y:G, p (inl x) <> p (inr y).

(** [Always_Split e] means that (infinite) execution [e] is [Split]
    forever. We will prove that with [bad_demon], robots are always
    apart. *)
CoInductive Always_Split {G} (e : execution (G ⊎ G)) :=
  CAD : Split (execution_head e) ->
        Always_Split (execution_tail e) -> Always_Split e.

(** ** Linking the different properties *)

Theorem different_no_gathering : forall (G : finite) (e:execution (G ⊎ G)),
  inhabited G -> Always_Split e -> forall pt, ~WillGather pt e.
Proof.
  intros G e [g] He pt Habs.
  induction Habs.
  - inversion H. inversion He. elim (H2 g g). now do 2 rewrite H0.
  - inversion He. now apply IHHabs.
Qed.

Lemma Always_Split_compat G : forall e1 e2,
  eeq e1 e2 -> @Always_Split G e1 -> Always_Split e2.
Proof.
  coinduction diff.
  - unfold Split in *. intros. rewrite <- H. now destruct H0.
  - destruct H. apply (diff _ _ H1). now destruct H0.
Qed.

Lemma Always_Split_compat_iff G : Proper (eeq ==> iff) (@Always_Split G).
Proof.
  intros e1 e2 He; split; intro.
  - now apply (Always_Split_compat He).
  - now apply (Always_Split_compat (symmetry He)).
Qed.


(** * Framework of the impossibility proof  **)

(** ** Framework for the empty set of byzantine robots **)

(** [Zero] is the (finite) empty set.  *)
Definition Zero : finite.
refine {|
  name := False;
  next := fun fo => match fo with | None => None | Some f => match f with end end;
  prev := fun fo => match fo with | None => None | Some f => match f with end end |}.
Proof.
abstract (now intros [ [] | ] [ [] | ]).
abstract (intros []).
abstract (intros []).
Defined.

(** [Four] is a finite set of size four.  *)

Inductive Four_state :=
  | One4 : Four_state
  | Two4 : Four_state
  | Three4 : Four_state
  | Four4 : Four_state.

Definition Four_next fo := 
  match fo with
    | None => Some One4
    | Some One4 => Some Two4
    | Some Two4 => Some Three4
    | Some Three4 => Some Four4
    | Some Four4 => None
  end.

Definition Four_prev fo := 
  match fo with
    | None => Some Four4
    | Some Four4 => Some Three4
    | Some Three4 => Some Two4
    | Some Two4 => Some One4
    | Some One4 => None
  end.

Lemma Four_NextPrev :
  forall x y : option Four_state, Four_next x = y <-> Four_prev y = x.
Proof. intros [[] |] [[] |]; split; intro H; reflexivity || discriminate H. Qed.

(*Lemma RecNext : forall z : name, Acc NextRel z;
    RecPrev : forall z : name, Acc PrevRel z*)
Lemma Acc_next_1 : Acc (fun x y => Four_next (Some x) = Some y) One4.
Proof. apply Acc_intro. intros [] H; discriminate H. Qed.

Lemma Acc_next_2 : Acc (fun x y => Four_next (Some x) = Some y) Two4.
Proof.
apply Acc_intro. intros [] H; try discriminate H.
exact Acc_next_1.
Qed.

Lemma Acc_next_3 : Acc (fun x y => Four_next (Some x) = Some y) Three4.
Proof.
apply Acc_intro. intros [] H; try discriminate H.
exact Acc_next_2.
Qed.

Lemma Acc_next_4 : Acc (fun x y => Four_next (Some x) = Some y) Four4.
Proof.
apply Acc_intro. intros [] H; try discriminate H.
exact Acc_next_3.
Qed.

Theorem Acc_next : forall f : Four_state, Acc (fun x y => Four_next (Some x) = Some y) f.
Proof.
intros [];
solve[apply Acc_next_1
     | apply Acc_next_2
     | apply Acc_next_3
     | apply Acc_next_4].
Qed.

Lemma Acc_prev_4 : Acc (fun x y => Four_prev (Some x) = Some y) Four4.
Proof. apply Acc_intro. intros [] H; discriminate H. Qed.

Lemma Acc_prev_3 : Acc (fun x y => Four_prev (Some x) = Some y) Three4.
Proof.
apply Acc_intro. intros [] H; try discriminate H.
exact Acc_prev_4.
Qed.

Lemma Acc_prev_2 : Acc (fun x y => Four_prev (Some x) = Some y) Two4.
Proof.
apply Acc_intro. intros [] H; try discriminate H.
exact Acc_prev_3.
Qed.

Lemma Acc_prev_1 : Acc (fun x y => Four_prev (Some x) = Some y) One4.
Proof.
apply Acc_intro. intros [] H; try discriminate H.
exact Acc_prev_2.
Qed.

Theorem Acc_prev : forall f : Four_state, Acc (fun x y => Four_prev (Some x) = Some y) f.
Proof.
intros [];
solve[apply Acc_prev_1
     | apply Acc_prev_2
     | apply Acc_prev_3
     | apply Acc_prev_4].
Qed.

Definition Four : finite := {|
  name := Four_state;
  next := Four_next;
  prev := Four_prev;
  NextPrev := Four_NextPrev;
  RecNext := Acc_next;
  RecPrev := Acc_prev
  |}.

Theorem Four_dec : forall x y : Four, {x = y} + {x <> y}.
Proof. decide equality. Defined.


(** This is the unique function from [Zero] to anything. *)
Definition Zero_fun X : Zero -> X := fun fo => match fo with end.

(** ** Lifting notions from good robots to (good,∅). *)

(** [lift_function f g] lifts two renaming functions, one for good and
    one for bad robots, into a renaming function for any robot. *)
Definition lift_function {G H I J : finite}
  (f : G -> H) (g : I -> J) (id : ident G I): ident H J :=
  match id with
    | Good g => Good H J (f g)
    | Byz b => Byz H J (g b)
  end.

(** Renaming if the set of bad robots is empty.  *)
Definition lift_with_Zero {G H : finite} (f : G -> H) :=
  lift_function f (Zero_fun Zero).

Definition lift_automorphism {G} (σ : automorphism (name G)) :
  automorphism (ident G Zero).
refine {| section := lift_with_Zero σ.(section);
retraction := lift_with_Zero σ.(retraction);
Inversion := _ |}.
Proof.
abstract (intros [x | []] [y | []];
          simpl; split; intro H;
          f_equal; injection H; apply σ.(Inversion)).
Defined.


(** *  Lemmas on Permutations  **)

Lemma permutation_inj : forall T (σ : permutation T) (x y : T), σ x = σ y -> x = y.
Proof.
intros T [σ σ' Hσ] x y Heq. simpl in Heq.
rewrite Hσ in Heq. subst x. now rewrite <- Hσ.
Qed.

Definition permutation_inverse {T} (σ : permutation T) : permutation T.
refine ({|
  section := σ.(retraction);
  retraction := σ.(section)|}).
  abstract (intros; rewrite σ.(Inversion); reflexivity).
Defined.
(*
Notation "σ ⁻¹" := (permutation_inverse σ) (at level 10).

Definition compose {T U V : Type} (f : U -> V) (g : T -> U) := fun x => f (g x).

Instance compose_compat T U V : Proper (ExtEq ==> ExtEq ==> ExtEq) (@compose T U V).
Proof. intros f1 f2 Hf g1 g2 Hg x. unfold compose. now rewrite Hf, Hg. Qed.

Definition compose_perm {T} (σ' σ : permutation T) : permutation T.
refine ({|
  section := fun x => σ' (σ x);
  retraction := fun x => σ⁻¹ (σ'⁻¹ x)|}).
abstract (intros x y; rewrite Inversion; change (retraction σ') with (section (σ' ⁻¹));
rewrite (σ⁻¹).(Inversion); change (retraction (σ ⁻¹)) with (section σ); intuition).
Defined.

Notation "σ₂ '∘∘' σ₁" := (compose_perm σ₂ σ₁) (at level 10).
*)
Definition PermEq {T : Set} (σ σ' : permutation T) := ExtEq σ σ'.

Instance PermEq_equiv T : Equivalence (@PermEq T).
Proof. unfold PermEq. split.
 intro. reflexivity.
 intros ? ? ?. now symmetry.
 intros ? ? ? ? ?. etransitivity; eassumption.
Qed.

Instance ExtEq_perm_bisim (T : Set) : Bisimulation (@permutation T).
Proof. exists PermEq. apply PermEq_equiv. Defined.
(*
Theorem compose_perm_assoc T : forall σ₁ σ₂ σ₃ : permutation T, σ₁ ∘∘ (σ₂ ∘∘ σ₃) ≈ (σ₁ ∘∘ σ₂) ∘∘ σ₃.
Proof. intros ? ? ? ?. reflexivity. Qed.

Theorem compose_inverse_r G B : forall σ, PermEq (σ ∘∘ (σ⁻¹)) (id_perm G B).
Proof. intros σ x. simpl. now rewrite σ.(Inversion). Qed.

Theorem compose_inverse_l G B : forall σ, PermEq (σ⁻¹ ∘∘ σ) (id_perm G B).
Proof. intros σ x. simpl. now rewrite <- σ.(Inversion). Qed.

Theorem compose_id_perm_r G B : forall σ, PermEq (σ ∘∘ (id_perm G B)) σ.
Proof. now intros σ [n | n]. Qed.

Theorem compose_id_perm_l G B : forall σ, PermEq ((id_perm G B) ∘∘ σ) σ.
Proof. now intros σ [n | n]. Qed.
*)
Identity Coercion idPerm : PermEq >-> ExtEq.

Instance PermEq_ExtEq T : Proper (PermEq ==> ExtEq) (@section T).
Proof. intros σ σ' Hσ x. apply Hσ. Qed.

Definition project_without_Zero {G} (f : ident G Zero -> ident G Zero) :=
  fun x => match f (Good G Zero x) with | Good y => y | Byz y => match y with end end.

Instance project_without_Zero_compat G : Proper (ExtEq ==> ExtEq) (@project_without_Zero G).
Proof. intros f g Hfg x. unfold project_without_Zero. now rewrite Hfg. Qed.

Lemma project_without_Zero_lemma G : forall (σ : permutation (ident G Zero)) (x y : G),
project_without_Zero σ x = y <-> project_without_Zero (retraction σ) y = x.
Proof.
intros σ x y. destruct σ. simpl.
unfold project_without_Zero. case_eq (retraction (Good _ _ y)); [intros n Hn | intros []].
rewrite <- Inversion in Hn. split; intro.
case_eq (section (Good _ _ x)); [intros m Hm | intros []]. rewrite Hm in H. subst. rewrite <- Hm in Hn.
cut (Good _ _ n = Good _ Zero x). intro H. now injection H.
apply (permutation_inj {| section := section; retraction := retraction; Inversion := Inversion|}). now simpl.
subst. now rewrite Hn.
Qed.

Definition permutation_without_Zero {G} (σ : permutation (ident G Zero)) := {|
  section := project_without_Zero σ;
  retraction := project_without_Zero σ.(retraction);
  Inversion := project_without_Zero_lemma σ |}.

Instance permutation_without_Zero_compat G : Proper (PermEq ==> PermEq) (@permutation_without_Zero G).
Proof. intros σ σ' Hσ x. unfold permutation_without_Zero. simpl. unfold project_without_Zero. now rewrite Hσ. Qed.

(** *  Definitions for 4 robots **)

Definition forbidden (s : spectrum) := exists p1, exists p2, Permutation s (p1 :: p1 :: p2 :: p2 :: List.nil).


Definition center4 (s : spectrum) := List.fold_left Rplus s 0.

(** Are robots on a stack **)
Function has_dups (l : list R) : option R :=
  match l with
    | List.nil => None
    | _ :: List.nil => None
    | h :: t => if List.in_dec Rdec h t then Some h else has_dups t
  end.

Ltac Rdec_full :=
  match goal with
    | |- context[Rdec ?x ?y] =>
      let Heq := fresh "Heq" in let Hneq := fresh "Hneq" in
      destruct (Rdec x y) as [Heq | Hneq]
    | _ => fail
  end.

Ltac rewrite_eqs := match goal with | H : ?x = ?y |- _ => rewrite H in *; move H at top end.

Ltac Rdec_aux H :=
  match type of H with
    | context[Rdec ?x ?y] =>
      let Heq := fresh "Heq" in let Hneq := fresh "Hneq" in
      destruct (Rdec x y) as [Heq | Hneq]
    | _ => fail
  end.

(* PC: j'ai mis des inférieurs stricts ici, sans quoi le lemme
   has_dups_spec2 est faux pour une valeur par défaut mal choisie. Il
   y avait une raison pour mettre des <= ? *)
Definition Stack (s : spectrum) :=
  exists n1 n2, (n1 < List.length s)%nat /\ (n2 < List.length s)%nat /\
                n1 <> n2 /\ List.nth n1 s 0 = List.nth n2 s 0.

(* Stack does not exhibit the first repeated occurrence of a location,
   so this is not trivial to prove. *)
Lemma has_dups_spec : forall (s : spectrum),
  (exists r, has_dups s = Some r) -> Stack s.
Proof.
induction s.
+ intro Habs. 
  exfalso. destruct Habs as [? Habs]. now inversion Habs.
+ intros h.
  destruct h as [x h].
  simpl in h.
  destruct s.
    { inversion h. }
    { destruct (List.in_dec Rdec a (r :: s)).
      - unfold Stack.
        exists 0%nat.
        assert (hInnth:exists n, (n < List.length (r::s))%nat
                          /\ forall default, List.nth n (r::s) default = a).
        { admit. }
        destruct hInnth as [y hInnth].
        destruct hInnth as [hInnth1 hInnth2].
        exists (S y);intuition;auto.
        + simpl in hInnth1.
          simpl.
          omega.
        + simpl in hInnth1.
          simpl.
          omega.
        + simpl.
          simpl in hInnth2.
          symmetry.
          apply hInnth2.
      - assert (hstack:Stack (r::s)).
        { apply IHs.
          exists x.
          assumption. }
        unfold Stack in hstack.
        decompose [ex and] hstack.
        clear hstack.
        exists (S x0).
        exists (S x1).
        intuition;auto.
        + simpl in H,H0.
          simpl.
          omega.
        + simpl in H,H0.
          simpl.
          omega. }
Qed.


Lemma Stack_nonempty : forall s, Stack s -> s <> List.nil.
Proof.
  intros s H.
  unfold Stack in H.
  destruct H.
  destruct H.
  destruct H.
  intro abs.
  rewrite abs in H.
  simpl in H.
  omega.
Qed.

Lemma No_Stack_nil : ~ Stack Datatypes.nil.
Proof.
  intro abs.
  apply Stack_nonempty with Datatypes.nil;auto.
Qed.

(* Stack does not exhibit the first repeated occurrence of a location,
   so this is not trivial to prove. *)
Lemma has_dups_spec2 : forall (s : spectrum),
  Stack s -> exists r, has_dups s = Some r.
Proof.
  intros s.
  induction s.
  - intro.
    exfalso.
    apply No_Stack_nil;auto.
  - intros has.
    destruct (List.in_dec Rdec a s) eqn:heq.
    + exists a.
      simpl.
      destruct s.
      * inversion i.
      * rewrite heq.
        reflexivity.
    + assert (hstacks:Stack s).
      { unfold Stack in has.
        decompose [and ex] has.
        clear has.
        (* x cannot be 0 since a is not repeated in s. *)
        destruct x.
        { exfalso.
          simpl List.nth in H3 at 1.
          destruct x0.
          { omega. }
          simpl in H3.
          apply n.
          rewrite H3.
          apply List.nth_In.
          simpl in H0.
          omega. }
        (* x0 cannot be 0 since a is not repeated in s. *)
        destruct x0.
        { exfalso.
          simpl List.nth in H3 at 1.
          simpl in H3.
          apply n.
          rewrite <- H3.
          apply List.nth_In.
          simpl in H.
          omega. }
        simpl in H3.
        exists x.
        exists x0.
        intuition;auto. }
      specialize (IHs hstacks).
      destruct IHs.
      exists x.
      simpl.
      destruct s.
      * exfalso.
        apply No_Stack_nil;auto.
      * rewrite heq.
        assumption.
Qed.


(*
(** ** Sorting 3 and 4 elements **)
Definition Sorted3 abc :=
  let '(a, b, c) := abc in a <= b <= c.
Definition Sorted4 abcd :=
  let '(a, b, c, d) := abcd in a <= b <= c /\ c <= d.

Definition sort3 (Tle_dec : forall x y : R, {x <= y} + {y < x}) a b c :=
  if Tle_dec a b then (* a ≤ b *)
    if Tle_dec b c then (a, b, c)
    else (* a ≤ b, c < b *)
      if Tle_dec a c then (a, c, b) else (c, a, b)
  else (* b < a *)
    if Tle_dec a c then (b, a, c)
    else (* b < a, c < a *)
      if Tle_dec b c then (b, c, a) else (c, b, a).

Ltac Rle_dec :=
  match goal with
    | |- context[Rle_lt_dec ?x ?y] =>
      let Heq := fresh "Heq" in let Hneq := fresh "Hneq" in
      destruct (Rle_lt_dec x y) as [Heq | Hneq]
    | _ => fail
  end.

(*
Definition mk_perm n m p a b c :=
  fun x =>
    if Rdec x a then (* we want the new value at the pos of a *)
      if eq_nat_dec n 1 then a else
      if eq_nat_dec n 2 then b else
      if eq_nat_dec n 3 then c else 0
    else if Rdec x b then (* we want the new value at the pos of b *)
      if eq_nat_dec m 1 then a else
      if eq_nat_dec m 2 then b else
      if eq_nat_dec m 3 then c else 0
    else if Rdec x c then (* we want the new value at the pos of c *)
      if eq_nat_dec p 1 then a else
      if eq_nat_dec p 2 then b else
      if eq_nat_dec p 3 then c else 0
    else 0.

Definition mk_perm_inv n m p a b c :=
  fun x =>
    if Rdec x a then (* we want the new value at the pos of a *)
      if beq_nat n 1 then a else
      if beq_nat m 1 then b else
      if beq_nat m 1 then c else 0
    else if Rdec x b then (* we want the new value at the pos of b *)
      if beq_nat n 2 then a else
      if beq_nat m 2 then a else
      if beq_nat p 2 then c else 0
    else if Rdec x c then (* we want the new value at the pos of c *)
      if beq_nat n 3 then a else
      if beq_nat m 3 then b else
      if beq_nat p 3 then c else 0
    else 0.

Theorem mk_perm_involutive : forall n m p,
  (n = 1 \/ n = 2 \/ n = 3)%nat ->
  (m = 1 \/ m = 2 \/ m = 3)%nat ->
  (p = 1 \/ p = 2 \/ p = 3)%nat ->
  forall a b c x, (x = a \/ x = b \/ x = c) ->
    mk_perm_inv n m p a b c (mk_perm n m p a b c x) = x.
Proof.
intros n m p [ | [ | ]] [ | [ | ]] [ | [ | ]] a b c x [? | [? | ?]];
subst n m p x; unfold mk_perm, mk_perm_inv; simpl.
repeat (reflexivity || subst || match goal with
  | H : ?x <> ?x |- _ => elim H; reflexivity
  | H : context[Rdec ?x ?y] |- _ => destruct (Rdec x y)
  | |- context[Rdec ?x ?y] => destruct (Rdec x y)
end).

Qed.
*)

Theorem sort3_Sorted : forall a b c,
  let '(x, y, z) := sort3 Rle_lt_dec a b c in
  Sorted3 (x, y, z).
(*  /\ exists σ : permutation R, σ a = x /\ σ b = y /\ σ z = c.*)
Proof.
intros a b c. unfold sort3.
repeat Rle_dec; unfold Sorted3; intuition. (*(split; [unfold Sorted3; intuition |]).
+ Definition σ : permutation R.
  refine ({| section := fun x => x; retraction := fun x => x |}).
  abstract intuition. Defined.
  exists σ. intuition.
+ Definition σ : permutation R.
  refine ({| section := fun x => x; retraction := fun x => x |}).
  abstract intuition. Defined.*)
Qed.

Definition sort4 (Tle_dec : forall x y : R, {x <= y} + {y < x}) a b c d :=
  let '(x, y, z) := sort3 Rle_lt_dec a b c in (* x ≤ y ≤ z *)
  if Tle_dec y d then (* y ≤ d *)
    if Tle_dec z d then (x, y, z, d) else (x, y, d, z)
  else (* d < y *)
    if Tle_dec x d then (x, d, y, z) else (d, x, y, z).

Theorem sort4_Sorted : forall a b c d,
  let '(x, y, z, t) := sort4 Rle_lt_dec a b c d in
  Sorted4 (x, y, z, t).
Proof.
intros a b c d. unfold sort4.
assert (H3 := sort3_Sorted a b c).
destruct (sort3 Rle_lt_dec a b c) as [[α β] γ].
destruct H3.
repeat Rle_dec; unfold Sorted4; intuition.
Qed.

Theorem sort4_perm : forall pos, exists σ : permutation (ident Four Zero),
  ((pos ∘ σ).(gp) One4, (pos ∘ σ).(gp) Two4, (pos ∘ σ).(gp) Three4, (pos ∘ σ).(gp) Four4) 
  = sort4 Rle_lt_dec (pos.(gp) One4) (pos.(gp) Two4) (pos.(gp) Three4) (pos.(gp) Four4).
Proof. Admitted.
*)
Import Mergesort.
Print Module Mergesort.
Print Module Type Orders.TotalLeBool.

Definition Rleb (x y : R) := if Rle_lt_dec x y then true else false.

Lemma Rleb_spec : forall x y, Rleb x y = true <-> Rle x y.
Proof.
intros x y; unfold Rleb; destruct (Rle_lt_dec x y); split; intro H; trivial. inversion H. elim (Rlt_not_le _ _ r H).
Qed.

Corollary Rleb_total : forall x y, Rleb x y = true \/ Rleb y x = true.
Proof.
intros x y. unfold Rleb. destruct (Rle_lt_dec x y).
  now left.
  right. destruct (Rle_lt_dec y x). reflexivity. elim (Rlt_irrefl x). now apply Rlt_trans with y.
Qed.
Local Coercion is_true : bool >-> Sortclass.

Corollary Rleb_trans : Transitive Rleb.
Proof. intros ? ? ?. unfold is_true. setoid_rewrite Rleb_spec. apply Rle_trans. Qed.

Module Rletot : Orders.TotalLeBool with Definition t := R
                                   with Definition leb := Rleb.
  Definition t := R.
  Definition leb := Rleb.
  Definition leb_total := Rleb_total.
End Rletot.

Import Sorted.
Module Rsort := Mergesort.Sort(Rletot).
Print Module Rsort.
Import Rsort.

Corollary sort_min : forall (s : spectrum) (d x : R), List.In x s ->
  List.hd d (sort s) <= x.
Proof.
intros s d x Hin.
assert (Hsort := StronglySorted_sort s Rleb_trans).
assert (Hperm := Permuted_sort s).
destruct (sort s).
- symmetry in Hperm. apply Permutation_nil in Hperm. subst. now inversion Hin.
- simpl. apply (Permutation_in _ Hperm) in Hin. destruct Hin. subst. apply Rle_refl.
  apply StronglySorted_inv in Hsort. destruct Hsort as [Hsort Hmin].
  rewrite List.Forall_forall in Hmin. rewrite <- Rleb_spec. now apply Hmin.
Qed.

Corollary sort_max : forall (s : spectrum) (d x : R), List.In x s ->
  x <= List.last (sort s) d.
Proof.
intros s d x Hin.
assert (Hsort := StronglySorted_sort s Rleb_trans).
assert (Hperm := Permuted_sort s).
apply (Permutation_in _ Hperm) in Hin. revert Hsort x Hin. clear Hperm. generalize (sort s).
apply (@StronglySorted_ind R _ (fun l => forall x : R, List.In x l -> x <= List.last l d)).
now intros ? [].
intros a l Hsorted HP Hle x Hin. destruct Hin.
- subst. destruct l. simpl. apply Rle_refl.
  apply Rle_trans with r. inversion_clear Hle. now rewrite <- Rleb_spec. apply HP. now left.
- destruct l. inversion H. now apply HP.
Qed.

Definition is_forbidden (s : spectrum) :=
  match sort s with
    | List.nil =>  true
    | _ :: List.nil => true
    | _ :: _ :: List.nil => true
    | _ :: _ :: _ :: List.nil => true
    | x :: y :: z :: t :: List.nil => 
      if Rdec x y then if Rdec z t then if Rdec y z then false else true else false else false
    | _ => true
  end.

Theorem is_forbidden_true : forall pos, is_forbidden pos = true <-> forbidden pos.
Proof. Admitted.

Corollary is_forbidden_false : forall pos, is_forbidden pos = false <-> ~forbidden pos.
Proof. intro pos. assert (Hp := is_forbidden_true pos). destruct (is_forbidden pos); rewrite <- Hp; intuition. Qed.
Print round.

Definition range b1 b2 (s : spectrum) :=
  List.Forall (fun x => b1 <= x <= b2) s.

Lemma Forall_Perm_trans A : forall (l1 l2 : list A) (P Q : A -> Prop),
  (eq ==> iff)%signature P Q -> Permutation l1 l2 -> List.Forall P l1 -> List.Forall Q l2.
Proof.
intros l1 l2 P Q HPQ Hperm Hfor. 
rewrite List.Forall_forall in *. intros. rewrite <- (HPQ _ _ eq_refl). 
apply Hfor. revert H. apply Permutation_in. now symmetry.
Qed.

Lemma Forall_Permutation_compat {A} : Proper ((eq ==> iff) ==> @Permutation A ==> iff) List.Forall.
Proof.
intros f g Hfg l1 l2 Hl. split; apply Forall_Perm_trans; easy || now symmetry.
Qed.

Lemma range_compat : Proper (eq ==> eq ==> @Permutation R ==> iff) range.
Proof.
intros inf1 inf2 ? sup1 sup2 ? s1 s2 Hs. subst.
unfold range. split; apply Forall_Perm_trans; trivial. reflexivity. reflexivity. now symmetry.
Qed.

Lemma range_split : forall b1 b2 s,
  range b1 b2 s <-> (List.Forall (fun x => b1 <= x) s /\ List.Forall (fun x => x <= b2) s).
Proof.
intros b1 b2 s. unfold range. setoid_rewrite List.Forall_forall.
intuition; apply (H _ H0).
Qed.

Lemma last_In : forall A l (x : A), l <> List.nil -> List.In (List.last l x) l.
Proof.
intro A. induction l; intros x Hx. now elim Hx.
destruct l. now left. 
change (List.In (List.last (a0 :: l) x) (a :: a0 :: l)).
right. apply IHl. discriminate.
Qed.

Definition extremal r (s : spectrum) :=
  exists b, range b r s \/ range r b s.

(*
Parameter is_extremal : ident Four Zero -> position Four Zero -> bool.
Hypothesis is_extremal_correct : forall r (pos : position Four Zero),
  is_extremal r pos = true <-> extremal r pos.
*)

Definition is_extremal r (s : spectrum) :=
  if Rdec r (List.hd r (sort s)) then true else
  if Rdec r (List.last (sort s) r) then true else false.

Theorem is_extremal_correct : forall r (s : spectrum),
  List.In r s -> (is_extremal r s = true <-> extremal r s).
Proof.
unfold is_extremal,extremal. intros r s Hin.
repeat Rdec_full; split; intro H; try (reflexivity || discriminate H);
try solve [reflexivity | discriminate H | right; now intros [] | left; now intros []].
+ clear H. rewrite Heq. exists (List.last (sort s) r). right.
  rewrite range_split. split;
  rewrite List.Forall_forall; apply sort_min || apply sort_max.
+ clear H. exists (List.hd r (sort s)). left. rewrite Heq.
  rewrite range_split. split;
  rewrite List.Forall_forall; apply sort_min || apply sort_max.
+ exfalso. destruct H as [b [Hb | Hb]].
  - elim (Rlt_irrefl r). apply Rlt_le_trans with (List.last (sort s) r).
      revert Hneq0. generalize (sort_max s r r Hin). apply Rle_neq_lt.
      apply range_split in Hb. destruct Hb as [_ Hb]. rewrite List.Forall_forall in Hb.
      apply Hb. apply (Permutation_in _ (symmetry (Permuted_sort s))). apply last_In.
      apply (Permutation_in _ (Permuted_sort s)) in Hin. destruct (sort s).
      inversion Hin. discriminate.
  - elim (Rlt_irrefl r). apply Rle_lt_trans with (List.hd r (sort s)).
      apply range_split in Hb. destruct Hb as [Hb _]. rewrite List.Forall_forall in Hb.
      apply Hb. apply (Permutation_in _ (symmetry (Permuted_sort s))).
      apply (Permutation_in _ (Permuted_sort s)) in Hin. destruct (sort s).
      inversion Hin. now left.
      assert (Hneq' : List.hd r (sort s) <> r). { intro. apply Hneq. now symmetry. }
      revert Hneq'. generalize (sort_min s r r Hin). apply Rle_neq_lt.
Qed.

Definition extreme_center (s : spectrum) :=
  (List.hd 0 (sort s) + List.last (sort s) 0) / 2.
(* When there is no robot (s is empty), the center is 2. *)

Definition robogram (s : spectrum) : location :=
  if is_forbidden s then 0 else
  match has_dups s with
    | Some p => p
    | None => if is_extremal 0 s then 0 else extreme_center s end.

Print Assumptions robogram.


Definition Stacked (pos:Four -> R) :=
  exists l, forall r, pos r = l.

Inductive Will_stack (e : execution Four) :=
  | AlreadyStacked : Stacked (execution_head e) -> Will_stack e
  | After :  Will_stack (execution_tail e) -> Will_stack e.

Theorem stack_4 : forall d : demon Four Zero, forall k, kFair k d ->
  forall pos, ~ is_forbidden pos -> Will_stack (execute robogram d pos).
Proof.

Admitted.

Theorem stack_sol : forall d : demon Four Zero, forall k, kFair k d ->
  forall pos, Stack pos -> solGathering (execute robogram d pos).

Theorem meeting4 :
  forall d : demon Four Zero, forall k, kFair k d -> solGathering robogram d.
Proof.
intros d k Hfair gp.
induction (stack_4 Hfair gp).
+ destruct s as [n1 [n2 [Hneq Heq]]].
  exists (execution_head e n1).
  induction
  
+ 
Qed.
