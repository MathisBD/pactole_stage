Require Import Bool.
Require Import Arith.Div2.
Require Import Rbase.
Require Import List.
Require Import FMultisetFacts.
Require Import FMultisetMap.
Require Import Preliminary.
Require Import ConvergentFormalismR.
Require Import EqualitiesR.
Require Import Morphisms.
Require Import Psatz.
Import Permutation.
Import Datatypes. (* to overshadow Rlist and its constructors [nil] and [cons] *)
Require FMapWeakList. (* to build an actual implementation of multisets *)

Set Implicit Arguments.
Close Scope R_scope.


Module Rdecidable : DecidableType with Definition t := R
                                  with Definition eq := @Logic.eq R
                                  with Definition eq_dec := Rdec.
  Definition t := R.
  Definition eq := @Logic.eq R.
  Definition eq_refl : forall x : t, eq x x := reflexivity.
  Definition eq_sym : forall x y : t, eq x y -> eq y x := symmetry.
  Definition eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z := transitivity.
  Definition eq_dec : forall x y : t, {eq x y} + {~ eq x y} := Rdec.
End Rdecidable.
Transparent Rdecidable.eq_dec.

(** Small dedicated decision tactic for reals handling 1<>0 and r=r *)
Ltac Rdec := unfold Rdecidable.eq_dec; repeat
  match goal with
    | |- context[Rdec ?x ?x] =>
        let Heq := fresh "Heq" in destruct (Rdec x x) as [Heq | Heq];
        [clear Heq | exfalso; elim Heq; reflexivity]
    | |- context[Rdec 1 0] =>
        let Heq := fresh "Heq" in destruct (Rdec 1 0) as [Heq | Heq];
        [now elim R1_neq_R0 | clear Heq]
    | H : context[Rdec ?x ?x] |- _ =>
        let Heq := fresh "Heq" in destruct (Rdec x x) as [Heq | Heq];
        [clear Heq | exfalso; elim Heq; reflexivity]
  end.

Ltac Rdec_full := unfold Rdecidable.eq_dec;
  match goal with
    | |- context[Rdec ?x ?y] =>
      let Heq := fresh "Heq" in let Hneq := fresh "Hneq" in
      destruct (Rdec x y) as [Heq | Hneq]
    | _ => fail
  end.

(** *  The Gathering Problem  **)

(** Vocabulary: we call a [location] the coordinate of a robot. We
    call a [position] a function from robots to position. An
    [execution] is an infinite (coinductive) stream of [position]s. A
    [demon] is an infinite stream of [demonic_action]s. *)

(** ** Framework for the empty set of byzantine robots **)

(** [Zero] is the (finite) empty set.  *)

(** This is the unique function from [Zero] to anything. *)
Definition Zero_fun X : Fin.t 0 -> X := Fin.case0 (fun _ => X).

Lemma Zero_fun_equiv X : forall f : Fin.t 0 -> X, ExtEq f (Zero_fun X).
Proof. intros f x. now apply Fin.case0. Qed.

Lemma ExtEq_Zero_PosEq {nG} : forall pos1 pos2 : position nG 0, ExtEq pos1.(gp) pos2.(gp) -> PosEq pos1 pos2.
Proof. intros pos1 pos2 Hext. split; intro n. apply Hext. now apply Fin.case0. Qed.

(** *** Lifting notions from good robots to (good,∅). *)

(** [lift_function f g] lifts two renaming functions, one for good and
    one for bad robots, into a renaming function for any robot. *)
Definition lift_gp {nG} (f : G nG -> R) := {| gp := f; bp := Zero_fun R |}.
(* It would be great to have it as a coercion between G → location and position,
   but I do not know how to make it work. *)

Instance lift_gp_compat nG : Proper (ExtEq ==> @PosEq nG 0) lift_gp.
Proof. intros f g Hfg. split. apply Hfg. intro. now apply Fin.case0. Qed.

(** As there is no byzantine robots, a position is caracterized by the locations of good robots only. *)
Lemma lift_gp_equiv  {nG} : forall pos : position nG 0, PosEq pos (lift_gp pos.(gp)).
Proof. intros [gp bp]. split; simpl. now intro. intro. now apply Fin.case0. Qed.

(** ** Some properties related to the gathering problem *)

(** [gathered_at pos pt] means that in position [pos] all robots
    are at the same location [pt] (exactly). *)
Definition gathered_at {nG} (pos : G nG -> location) (pt:location) := forall r : G nG, pos r = pt.

(** [Gather pt e] means that at all rounds of (infinite) execution
    [e], robots are gathered at the same position [pt]. *)
CoInductive Gather {nG} (pt: location) (e : execution nG) : Prop :=
  Gathering : gathered_at (execution_head e) pt -> Gather pt (execution_tail e) -> Gather pt e.

(** [WillGather pt e] means that (infinite) execution [e] is
    *eventually* [Gather]ed. *)
Inductive WillGather {nG} (pt : location) (e : execution nG) : Prop :=
  | Now : Gather pt e -> WillGather pt e
  | Later : WillGather pt (execution_tail e) -> WillGather pt e.

(** When all robots are on two piles od the same height,
    there is no solution to the gathering problem.
    Therefore, we define these positions as [forbidden]. *)
Definition forbidden {nG nB} (pos : position nG nB) :=
  exists p1, exists p2, exists n, p1 <> p2 /\ Permutation (nominal_spectrum pos) (alls p1 n ++ alls p2 n).

(** [solGathering r d] means that any possible (infinite)
    execution, generated by demon [d] and robogram [r] and any intial
    position not [forbidden], will *eventually* be [Gather]ed. *)
Definition solGathering {nG} (r : robogram) (d : demon nG 0) :=
  forall (gp : G nG -> location), ~forbidden (lift_gp gp) -> exists pt : location, WillGather pt (execute r d gp).
(*
(** [Split p] means that position [p] contains to bijective sets of
    robots that do not share positions. *)
Definition Split {nG} (p: (G ⊎ G) -> R) :=
  forall x y:G, p (inl x) <> p (inr y).

(** [Always_Split e] means that (infinite) execution [e] is [Split]
    forever. We will prove that with [bad_demon], robots are always
    apart. *)
CoInductive Always_Split {G} (e : execution (G ⊎ G)) :=
  CAD : Split (execution_head e) ->
        Always_Split (execution_tail e) -> Always_Split e.

(** ** Linking the different properties *)

Theorem different_no_gathering : forall (G : finite) (e:execution (G ⊎ G)),
  inhabited G -> Always_Split e -> forall pt, ~WillGather pt e.
Proof.
  intros G e [g] He pt Habs.
  induction Habs.
  - inversion H. inversion He. elim (H2 g g). now do 2 rewrite H0.
  - inversion He. now apply IHHabs.
Qed.

Lemma Always_Split_compat G : forall e1 e2,
  eeq e1 e2 -> @Always_Split G e1 -> Always_Split e2.
Proof.
  coinduction diff.
  - unfold Split in *. intros. rewrite <- H. now destruct H0.
  - destruct H. apply (diff _ _ H1). now destruct H0.
Qed.

Lemma Always_Split_compat_iff G : Proper (eeq ==> iff) (@Always_Split G).
Proof.
  intros e1 e2 He; split; intro.
  - now apply (Always_Split_compat He).
  - now apply (Always_Split_compat (symmetry He)).
Qed.
*)

(** * Framework of the impossibility proof: a finite set with at leasts two elements.  **)

Parameter nG : nat.
Hypothesis size_G : nG >= 2.

Definition g1 : G nG.
destruct nG eqn:HnG. generalize size_G. abstract omega.
rewrite S_pred with (S n) 0. apply (@Fin.F1 n). abstract omega.
Defined.

Definition g2 : G nG.
destruct nG as [| [| n]] eqn:HnG; try (abstract (generalize size_G; omega)).
rewrite S_pred with (S n) 0. apply (Fin.FS Fin.F1). abstract omega.
Defined.

Lemma g1_g2 : g1 <> g2.
Proof. Admitted.

Corollary nominal_spectrum_nil : forall pos : position nG 0, ~nominal_spectrum pos = nil.
Proof.
intros pos Habs. destruct nG eqn:HnG. generalize size_G. omega.
assert (Hin : In (locate pos (Good _ Fin.F1)) (nominal_spectrum pos)) by apply In_spectrum.
rewrite Habs in Hin. inversion Hin.
Qed.

(** *  Some result about sorting  *)

Import Mergesort.
Print Module Mergesort.
Print Module Type Orders.TotalLeBool.

Definition Rleb (x y : R) := if Rle_lt_dec x y then true else false.

Lemma Rleb_spec : forall x y, Rleb x y = true <-> Rle x y.
Proof.
intros x y; unfold Rleb; destruct (Rle_lt_dec x y); split; intro H; trivial. inversion H. elim (Rlt_not_le _ _ r H).
Qed.

Corollary Rleb_total : forall x y, Rleb x y = true \/ Rleb y x = true.
Proof.
intros x y. unfold Rleb. destruct (Rle_lt_dec x y).
  now left.
  right. destruct (Rle_lt_dec y x). reflexivity. elim (Rlt_irrefl x). now apply Rlt_trans with y.
Qed.
Local Coercion is_true : bool >-> Sortclass.

Corollary Rleb_trans : Transitive Rleb.
Proof. intros ? ? ?. unfold is_true. setoid_rewrite Rleb_spec. apply Rle_trans. Qed.

Module Rletot : Orders.TotalLeBool with Definition t := R
                                   with Definition leb := Rleb.
  Definition t := R.
  Definition leb := Rleb.
  Definition leb_total := Rleb_total.
End Rletot.

Import Sorted.
Module Rsort := Mergesort.Sort(Rletot).
Print Module Rsort.
Import Rsort.

Ltac Rle_dec :=
  match goal with
    | |- context[Rle_lt_dec ?x ?y] =>
      let Heq := fresh "Heq" in let Hneq := fresh "Hneq" in
      destruct (Rle_lt_dec x y) as [Heq | Hneq]
    | _ => fail
  end.

Theorem StronglySorted_uniq :
  forall l l', StronglySorted Rleb l -> StronglySorted Rleb l' -> Permutation l l' -> l = l'.
Proof.
intros l l' Hl. revert l Hl l'.
apply (StronglySorted_ind (fun l => forall l' : list R, StronglySorted Rleb l' -> Permutation l l' -> l = l')).
+ intros l' _ Hperm. symmetry. now apply Permutation_nil.
+ intros a l Hl IHl Hle l' Hl' Hperm. destruct l' as [| b l'].
  - apply Permutation_nil. now symmetry.
  - assert (a = b).
    { destruct (Req_dec a b); trivial. apply Rle_antisym.
      - rewrite List.Forall_forall in Hle. rewrite <- Rleb_spec. apply Hle.
        cut (List.In b (a :: l)). now intros [|].
        rewrite Hperm. now left.
      - apply StronglySorted_inv in Hl'. destruct Hl' as [_ Hl'].
        rewrite List.Forall_forall in Hl'. rewrite <- Rleb_spec. apply Hl'.
        cut (List.In a (b :: l')). now intros [Hin | Hin]; try symmetry in Hin.
        rewrite <- Hperm. now left. }
    subst. f_equal. apply IHl. now apply StronglySorted_inv in Hl'.
    now apply Permutation_cons_inv with b.
Qed.

Instance sort_uniq : Proper (@Permutation R ==> eq) sort.
Proof.
intros l l' Hl. apply StronglySorted_uniq.
- apply StronglySorted_sort. exact Rleb_trans.
- apply StronglySorted_sort. exact Rleb_trans.
- transitivity l. symmetry. apply Permuted_sort. transitivity l'. assumption. apply Permuted_sort.
Qed.

Instance sort_uniqA : Proper (PermutationA eq ==> eq) sort.
Proof. intros ? ?. rewrite PermutationA_Leibniz. apply sort_uniq. Qed.

Corollary StronglySorted_sort_identity : forall l, StronglySorted Rleb l -> sort l = l.
Proof.
intros l Hl. apply StronglySorted_uniq.
apply StronglySorted_sort. apply Rleb_trans.
assumption.
symmetry. apply Permuted_sort.
Qed.

Corollary sort_idempotent : forall l, sort (sort l) = sort l.
Proof. intros l. apply StronglySorted_sort_identity. apply StronglySorted_sort. apply Rleb_trans. Qed.

Lemma StronglySorted_alls : forall x n, StronglySorted Rleb (alls x n).
Proof.
intros x n. induction n. constructor.
apply SSorted_cons. assumption.
rewrite List.Forall_forall. intros e Hin. apply alls_In in Hin. subst.
unfold is_true. rewrite Rleb_spec. apply Rle_refl.
Qed.

Lemma sort_alls : forall pt n, sort (alls pt n) = alls pt n.
Proof. intros. apply StronglySorted_sort_identity. apply StronglySorted_alls. Qed.

Open Scope R_scope.

Theorem sort_min : forall (s : spectrum) (d x : R), List.In x s ->
  (List.hd d (sort s) <= x)%R.
Proof.
intros s d x Hin.
assert (Hsort := StronglySorted_sort s Rleb_trans).
assert (Hperm := Permuted_sort s).
destruct (sort s).
- symmetry in Hperm. apply Permutation_nil in Hperm. subst. now inversion Hin.
- simpl. rewrite Hperm in Hin. destruct Hin. subst. apply Rle_refl.
  apply StronglySorted_inv in Hsort. destruct Hsort as [Hsort Hmin].
  rewrite List.Forall_forall in Hmin. rewrite <- Rleb_spec. now apply Hmin.
Qed.

Theorem sort_max : forall (s : spectrum) (d x : R), List.In x s ->
  (x <= List.last (sort s) d)%R.
Proof.
intros s d x Hin.
assert (Hsort := StronglySorted_sort s Rleb_trans).
assert (Hperm := Permuted_sort s).
rewrite Hperm in Hin. revert Hsort x Hin. clear Hperm. generalize (sort s).
apply (@StronglySorted_ind R _ (fun l => forall x : R, List.In x l -> x <= List.last l d)).
now intros ? [].
intros a l Hsorted HP Hle x Hin. destruct Hin.
- subst. destruct l. simpl. apply Rle_refl.
  apply Rle_trans with r. inversion_clear Hle. now rewrite <- Rleb_spec. apply HP. now left.
- destruct l. inversion H. now apply HP.
Qed.

Existing Instance Permutation_map_aux_Proper.

Lemma StronglySorted_map_increasing : forall A B (RA : relation A) (RB : relation B) f, Proper (RA ==> RB) f ->
  forall l, StronglySorted RA l -> StronglySorted RB (map f l).
Proof.
intros A B RA RB f Hf l Hl. induction Hl; simpl; constructor.
  assumption.
  induction H; simpl; constructor.
    now apply Hf.
    apply IHForall.
      now inversion_clear Hl.
      now inversion_clear IHHl.
Qed.

Corollary sort_map_increasing : forall f, Proper (Rleb ==> Rleb) f -> forall l, sort (map f l) = map f (sort l).
Proof.
intros f Hf l. rewrite (Permuted_sort l) at 1.
apply StronglySorted_sort_identity, (StronglySorted_map_increasing Hf), (StronglySorted_sort l Rleb_trans).
Qed.

Lemma StronglySorted_map_decreasing : forall A B (RA : relation A) (RB : relation B) f,
  Proper (RA --> RB) f -> Transitive RB ->
  forall l, StronglySorted RA l -> StronglySorted RB (rev (map f l)).
Proof.
intros A B RA RB f Hf HB l Hl. rewrite <- map_rev. induction Hl; simpl.
  now constructor. rewrite map_app.
  apply Sorted_StronglySorted. now apply HB. apply (@sort_app _ _ eq eq _ _).
  (* BUG?: if I don't give eq, it guesses it but then has a dangling existential variable of type nat ! *)
    now apply StronglySorted_Sorted.
    now repeat constructor.
    intros x y Hx Hy. inversion_clear Hy.
      subst y. rewrite (in_map_iff f _ _) in Hx.
        destruct Hx as [z [Heq Hin]]. subst x. rewrite <- (In_rev _) in Hin. apply Hf. unfold flip.
        rewrite Forall_forall in H. now apply H.
      now inversion H0.
Qed.

Corollary sort_map_decreasing : forall f, Proper (Rleb --> Rleb) f -> forall l, sort (map f l) = rev (map f (sort l)).
Proof.
intros f Hf l. rewrite (Permuted_sort l) at 1. rewrite (Permutation_rev (map f (sort l))) at 1.
apply StronglySorted_sort_identity, (StronglySorted_map_decreasing Hf), (StronglySorted_sort l Rleb_trans).
apply Rleb_trans.
Qed.

Close Scope R_scope.

(** *  Definitions for 4 robots **)

Implicit Type pos : position nG 0.

(* It needs to be defined on positions and not only on spectra.
   It is more natural and does not depend on a demon. *)

Instance forbidden_invariant : Proper (@PosEq nG 0 ==> iff) forbidden.
Proof.
intros p1 p2 Heq. split; intros [pt1 [pt2 [n [Hneq Hpt]]]];
exists pt1; exists pt2; exists n; split; trivial; now rewrite <- Hpt, Heq.
Qed.

Definition center4 (s : spectrum) := List.fold_left Rplus s R0.

(** **  Are robots on a stack?  **)

Module Mraw : FMultisetsOn Rdecidable := FMultisets FMapWeakList.Make Rdecidable.
Module M := FMultisetFacts.Make Rdecidable Mraw.
Notation "m1  [=]  m2" := (M.eq m1 m2) (at level 70).
Notation "m1  [<=]  m2" := (M.Subset m1 m2) (at level 70).

Lemma pair_dec : forall xn ym : R * nat, {M.eq_pair xn ym} + {~M.eq_pair xn ym}.
Proof.
unfold M.eq_pair. intros [x n] [y m]. compute.
destruct (Rdec x y).
  destruct (eq_nat_dec n m).
    left. now split.
    right. now intros [? ?].
  right. now intros [? ?].
Qed.

Definition Melt_field_struct : @field_theory M.elt _ _ _ _ _ _ _ _ _ := Rfield.
Add Field Melt_field : Melt_field_struct.

Inductive stackResult :=
  | NoResult (** No robots **)
  | Valid (l : location) (n : nat) (** One majoritary stack of size [n] at location [l]. **)
  | Invalid (n : nat) (** One majoritary stack of size [n] seen at least twice **).

Lemma stackResult_dec : forall x y : stackResult, {x = y} + {x <> y}.
Proof. decide equality. apply eq_nat_dec. apply Rdec. apply eq_nat_dec. Qed.


Definition multiset (s : spectrum) : M.t := List.fold_left (fun acc x => M.add x 1 acc) s M.empty.

Lemma multiset_nil : multiset nil [=] M.empty.
Proof. reflexivity. Qed.

Lemma multiset_cons_aux : forall s x m,
  List.fold_left (fun acc y => M.add y 1 acc) (x :: s) m [=]
  M.add x 1 (List.fold_left (fun acc x => M.add x 1 acc) s m).
Proof.
intro s. induction s; intros x m.
  reflexivity.
  simpl. intro.
  assert (Hf : Proper (M.eq ==> eq ==> M.eq) (fun (acc : M.t) (y : M.elt) => M.add y 1 acc)).
  { clear. intros s1 s2 Hs x y Hxy. now rewrite Hxy, Hs. }
  rewrite (@fold_left_start _ _ Logic.eq M.eq _ _ _ Hf s _ (M.add x 1 (M.add a 1 m)) (M.add_comm _ _ _ _ _)).
  apply IHs.
Qed.

Lemma multiset_cons : forall x s, multiset (x :: s) [=] M.add x 1 (multiset s).
Proof. intros x s y. unfold multiset. now rewrite multiset_cons_aux. Qed.

Lemma multiset_empty : forall l, multiset l [=] M.empty <-> l = nil.
Proof.
intro l. split; intro H.
  destruct l. reflexivity. rewrite multiset_cons in H.
  specialize (H r). rewrite M.add_spec, M.empty_spec in H. omega.
  subst l. apply multiset_nil.
Qed.

Lemma multiset_app : forall s s', multiset (s ++ s') [=] M.union (multiset s) (multiset s').
Proof.
induction s; intros s'; simpl.
  now rewrite M.union_empty_l.
  do 2 rewrite multiset_cons. intro x. destruct (Rdec x a).
    subst a. rewrite M.add_spec. rewrite IHs. repeat rewrite M.union_spec. rewrite M.add_spec. omega.
    rewrite M.add_spec'. rewrite IHs. repeat rewrite M.union_spec. rewrite M.add_spec'. reflexivity. auto. auto.
Qed.

Instance multiset_compat : Proper (@Permutation R ==> M.eq) multiset.
Proof.
intro s1. induction s1 as [| x s1]; intros s2 Hperm.
  apply Permutation_nil in Hperm. now subst.
  assert (Hx := Permutation_in_inside x Hperm). destruct Hx as [l1 [l2 Heq]]. now left. subst s2.
  intro y. rewrite multiset_app, M.union_spec. do 2 rewrite multiset_cons.
  destruct (Rdec x y) as [Heq | Hneq].
    subst y. repeat rewrite M.add_spec. rewrite plus_assoc. f_equal. rewrite <- M.union_spec, <- multiset_app.
    apply IHs1. now apply Permutation_cons_app_inv with x.
    repeat rewrite M.add_spec'; trivial. rewrite <- M.union_spec, <- multiset_app.
    apply IHs1. now apply Permutation_cons_app_inv with x.
Qed.

Lemma multiset_Permutation :
  forall x l n, M.multiplicity x (multiset l) = n -> exists l', ~In x l' /\ Permutation l (alls x n ++ l').
Proof.
intros x l. induction l; intros n Hin.
  exists nil. split. now auto. rewrite multiset_nil, M.empty_spec in Hin. subst n. simpl. reflexivity.
  rewrite multiset_cons in Hin. destruct (Rdec a x).
  - subst a. rewrite M.add_spec in Hin. destruct n. omega.
    rewrite plus_comm in Hin. simpl in Hin. apply eq_add_S in Hin. apply IHl in Hin. destruct Hin as [l' [Hl1 Hl2]].
    exists l'. split. assumption. simpl. now constructor.
  - rewrite M.add_spec' in Hin; trivial. apply IHl in Hin. destruct Hin as [l' [Hl1 Hl2]].
    exists (a :: l'). split. intros [|]; contradiction.
    transitivity (a :: alls x n ++ l'); now constructor || apply Permutation_middle.
Qed.

Lemma multiset_alls : forall x n, multiset (alls x n) [=] M.singleton x n.
Proof.
intros x n. induction n; simpl.
+ now rewrite M.singleton_0, multiset_nil.
+ rewrite multiset_cons. rewrite IHn. intro y. rewrite M.singleton_spec. Rdec_full.
    subst y. rewrite M.add_spec, M.singleton_spec. Rdec. omega.
    rewrite M.add_spec'. rewrite M.singleton_spec. now Rdec_full. auto.
Qed.

Corollary multiset_In : forall x l, M.multiplicity x (multiset l) > 0 <-> In x l.
Proof.
intros x l. split; intro Hl.
- destruct (multiset_Permutation _ (eq_refl (M.multiplicity x (multiset l)))) as [l' [Hl' Hperm]].
  rewrite Hperm. rewrite in_app_iff. left. destruct (M.multiplicity x (multiset l)). omega. now left.
- induction l. now inversion Hl. rewrite multiset_cons. destruct (Rdec a x).
    subst a. rewrite M.add_spec. omega.
    rewrite M.add_spec'; trivial. apply IHl. now inversion_clear Hl.
Qed.

Theorem multiset_map : forall f, injective eq eq f -> forall l, multiset (map f l) [=] M.map f (multiset l).
Proof.
intros f Hf l.
assert (Hf2 : Proper (eq ==> eq) f) by now repeat intro; subst.
induction l; simpl.
   rewrite (M.map_compat f Hf2 (multiset nil)). rewrite multiset_nil. now rewrite M.map_empty. now apply multiset_nil.
   do 2 rewrite multiset_cons. now rewrite M.map_add, IHl.
Qed.

Theorem multiset_spec : forall x l, M.multiplicity x (multiset l) = count_occ Rdec l x.
Proof.
intros x l. induction l; simpl.
  rewrite multiset_nil. now apply M.empty_spec.
  rewrite multiset_cons. destruct (Rdec a x).
    subst a. rewrite M.add_spec. rewrite IHl. omega.
    rewrite M.add_spec'. now apply IHl. assumption.
Qed.

Theorem cardinal_multiset : forall l, M.cardinal (multiset l) = length l.
Proof.
induction l; simpl.
+ now rewrite multiset_nil, M.cardinal_empty.
+ rewrite multiset_cons, M.cardinal_add. apply f_equal, IHl.
Qed.

Definition f_majority :=
  fun x n res =>
    match res with
      | NoResult => Valid x n
      | Valid y m => match nat_compare n m with
         | Lt => Valid y m
         | Eq => Invalid m
         | Gt => Valid x n
        end
      | Invalid m => match nat_compare n m with
         | Lt => Invalid m
         | Eq => Invalid m
         | Gt => Valid x n
        end
    end.

Lemma f_majority_comm : forall x y n m a, f_majority y m (f_majority x n a) = f_majority x n (f_majority y m a).
Proof.
intros x y n m [| l r | r]; unfold f_majority.
  + destruct (nat_compare n m) eqn:Hnm.
    - rewrite nat_compare_Eq_comm in Hnm. rewrite Hnm. rewrite nat_compare_eq_iff in Hnm. now subst.
    - rewrite nat_compare_Lt_Gt in Hnm. now rewrite Hnm.
    - rewrite <- nat_compare_Lt_Gt in Hnm. now rewrite Hnm.
  + destruct (nat_compare n r) eqn: Hnr.
    - destruct (nat_compare m r) eqn: Hmr.
        now rewrite Hnr.
        now rewrite Hnr.
        rewrite nat_compare_eq_iff in Hnr. subst r. rewrite <- nat_compare_Lt_Gt in Hmr. now rewrite Hmr.
    - destruct (nat_compare m r) eqn: Hmr.
        now rewrite Hnr.
        now rewrite Hnr.
        rewrite <- nat_compare_lt in Hnr. rewrite <- nat_compare_gt in Hmr.
        assert (Hnm : (n < m)%nat) by (now transitivity r). rewrite nat_compare_lt in Hnm. now rewrite Hnm.
    - destruct (nat_compare m r) eqn: Hmr.
        rewrite nat_compare_eq_iff in Hmr. subst r. rewrite Hnr. rewrite <- nat_compare_Lt_Gt in Hnr. now rewrite Hnr.
        rewrite Hnr. rewrite <- nat_compare_gt in Hnr. rewrite <- nat_compare_lt in Hmr.
        assert (Hmn : (m < n)%nat) by (now transitivity r). rewrite nat_compare_lt in Hmn. now rewrite Hmn.
        destruct (nat_compare n m) eqn:Hnm.
          rewrite nat_compare_Eq_comm in Hnm. rewrite Hnm. rewrite nat_compare_eq_iff in Hnm. now subst.
          rewrite nat_compare_Lt_Gt in Hnm. now rewrite Hnm.
          rewrite <- nat_compare_Lt_Gt in Hnm. now rewrite Hnm.
  + destruct (nat_compare n r) eqn: Hnr.
    - destruct (nat_compare m r) eqn: Hmr.
        now rewrite Hnr.
        now rewrite Hnr.
        rewrite nat_compare_eq_iff in Hnr. subst r. rewrite <- nat_compare_Lt_Gt in Hmr. now rewrite Hmr.
    - destruct (nat_compare m r) eqn: Hmr.
        now rewrite Hnr.
        now rewrite Hnr.
        rewrite <- nat_compare_lt in Hnr. rewrite <- nat_compare_gt in Hmr.
        assert (Hnm : (n < m)%nat) by (now transitivity r). rewrite nat_compare_lt in Hnm. now rewrite Hnm.
    - destruct (nat_compare m r) eqn: Hmr.
        rewrite nat_compare_eq_iff in Hmr. subst r. rewrite Hnr. rewrite <- nat_compare_Lt_Gt in Hnr. now rewrite Hnr.
        rewrite Hnr. rewrite <- nat_compare_gt in Hnr. rewrite <- nat_compare_lt in Hmr.
        assert (Hmn : (m < n)%nat) by (now transitivity r). rewrite nat_compare_lt in Hmn. now rewrite Hmn.
        destruct (nat_compare n m) eqn:Hnm.
          rewrite nat_compare_Eq_comm in Hnm. rewrite Hnm. rewrite nat_compare_eq_iff in Hnm. now subst.
          rewrite nat_compare_Lt_Gt in Hnm. now rewrite Hnm.
          rewrite <- nat_compare_Lt_Gt in Hnm. now rewrite Hnm.
Qed.

Instance f_majority_compat : Proper (M.eq ==> eq ==> eq) (M.fold f_majority).
Proof.
apply M.fold_compat.
  now auto with typeclass_instances.
  now repeat intro; subst.
  exact f_majority_comm.
Qed.

Definition majority_stack (s : spectrum) : stackResult := M.fold f_majority (multiset s) NoResult.

Instance majority_stack_invariant : Proper (@Permutation R ==> eq) majority_stack.
Proof.
intros s1 s2 Hperm. unfold majority_stack. apply M.fold_compat.
  now auto with typeclass_instances.
  now repeat intro; subst.
  exact f_majority_comm.
  now rewrite Hperm.
  reflexivity.
Qed.

Lemma majority_stack_nil : majority_stack nil = NoResult.
Proof. unfold majority_stack. now rewrite multiset_nil, M.fold_empty. Qed.

Lemma majority_stack_alls : forall x n, n <> 0 -> majority_stack (alls x n) = Valid x n.
Proof.
intros x n Hn. unfold majority_stack. rewrite multiset_alls.
rewrite M.fold_singleton. reflexivity. omega. repeat intro; now subst.
Qed.

Definition Stack_at x pos :=
  exists n, M.multiplicity x (multiset (nominal_spectrum pos)) = n
  /\ forall y, x <> y -> (M.multiplicity y (multiset (nominal_spectrum pos)) < n)%nat.

Instance Stack_at_compat : Proper (Logic.eq ==> @PosEq nG 0 ==> iff) Stack_at.
Proof. intros ? ? ? ? ? Hpos. subst. unfold Stack_at. now setoid_rewrite Hpos. Qed.


(** Two stack of robots of the same size. **)

Lemma majority_stack_NoResult_spec_aux : forall m r,
  M.fold f_majority m r = NoResult <-> M.Empty m /\ r = NoResult.
Proof.
intros m r. rewrite M.fold_spec, <- M.elements_nil. split; intro H.
+ revert r H. induction (M.elements m); intros r H.
  - simpl in H. now split.
  - exfalso. simpl in H. apply IHl in H. destruct H as [_ H].
    destruct a, r; simpl in H; discriminate H || (destruct (nat_compare n n0); discriminate H).
+ destruct H as [H1 H2]. subst r. rewrite H1. reflexivity.
Qed.

Corollary majority_stack_NoResult_spec : forall m, majority_stack m = NoResult <-> m = nil.
Proof.
intro m. unfold majority_stack. rewrite majority_stack_NoResult_spec_aux. split; intro H.
  destruct m.
    reflexivity.
    destruct H as [H1 H2]. exfalso. cut (0 = S (M.multiplicity r (multiset m)))%nat. omega.
    rewrite <- (H1 r) at 1. rewrite multiset_cons, M.add_spec. omega.
  subst m. split.
    rewrite multiset_nil. apply M.empty_spec.
    reflexivity.
Qed.

Lemma majority_stack_Valid_0_aux : forall x m r,
  M.fold f_majority m r = Valid x 0 <-> M.Empty m /\ r = Valid x 0.
Proof.
intros x m r. rewrite M.fold_spec. rewrite <- M.elements_nil.
assert (Hm : forall xn, InA M.eq_pair xn (M.elements m) -> M.multiplicity (fst xn) m = snd xn /\ (snd xn > 0)%nat)
by (intro; apply M.elements_spec).
revert r. induction (M.elements m); simpl; intro r.
  now intuition.
  rewrite IHl. clear IHl.
    split; intros [H1 H2]; exfalso.
      subst l. destruct a, r; simpl in H2.
        specialize (Hm (e, n)). inversion H2. subst e n. clear H2. apply (lt_irrefl 0). apply Hm. now left.
        destruct (nat_compare n n0) eqn:Hn.
          discriminate H2.
          inversion H2. subst. clear H2. rewrite <- nat_compare_lt in Hn. now inversion Hn.
          inversion H2. subst. clear H2. rewrite <- nat_compare_gt in Hn. now inversion Hn.
        destruct (nat_compare n n0) eqn:Hn.
          discriminate H2.
          discriminate H2.
          inversion H2. subst. clear H2. rewrite <- nat_compare_gt in Hn. now inversion Hn.
      now inversion H1.
    intros xn Hin. apply Hm. now right.
Qed.

Corollary majority_stack_Valid_0 : forall m x, majority_stack m <> Valid x 0.
Proof.
unfold majority_stack. intros m x H. rewrite majority_stack_Valid_0_aux in H. destruct H as [_ H]. discriminate H.
Qed.

Lemma majority_stack_Valid_spec_aux : forall x n m r, (n > 0)%nat ->
  (M.fold f_majority m r = Valid x n <->
  (r = Valid x n /\ (forall y, (M.multiplicity y m < n)%nat)
   \/ M.multiplicity x m = n /\ (forall y m, (r = Valid y m \/ r = Invalid m) -> m < n)%nat
      /\ forall y, x <> y -> (M.multiplicity y m < n)%nat)).
Proof.
intros x n m r Hn. rewrite M.fold_spec.
assert (Hm : ((r = Valid x n /\ forall y, (M.multiplicity y m < n)%nat)
          \/ M.multiplicity x m = n /\ (forall y m, (r = Valid y m \/ r = Invalid m) -> m < n)%nat
             /\ forall y, x <> y -> (M.multiplicity y m < n)%nat)
        <-> (r = Valid x n /\ (forall y n', InA M.eq_pair (y, n') (M.elements m) -> n' < n)%nat
             \/ InA M.eq_pair (x, n) (M.elements m) /\ (forall y m, (r = Valid y m \/ r = Invalid m) -> m < n)%nat
             /\ (forall y n', x <> y -> InA M.eq_pair (y, n') (M.elements m) -> n' < n)%nat)).
{ split; intros [[H1 H2] | [H1 [H2 H3]]].
  + left. split.
    - assumption.
    - intros y n' Hin. rewrite M.elements_spec in Hin.
      destruct Hin as [Hin Hpos]. simpl in Hin. rewrite <- Hin. apply H2.
  + right. repeat split.
    - rewrite M.elements_spec. now repeat split.
    - assumption.
    - intros y n' Hneq Hin. rewrite M.elements_spec in Hin. destruct Hin as [Hin Hpos].
      simpl in Hin. rewrite <- Hin. apply H3. assumption.
  + left. split.
    - assumption.
    - intro y. destruct (InA_dec pair_dec (y, M.multiplicity y m) (M.elements m)) as [Hin | Hin].
        now apply (H2 y (M.multiplicity y m)).
        rewrite M.elements_spec in Hin.
        assert (M.multiplicity y m = 0%nat). {cut (~M.multiplicity y m > 0)%nat. clear. omega. now auto. }
        now rewrite H.
  + right. repeat split.
    - rewrite M.elements_spec in H1. now destruct H1.
    - assumption.
    - intros y Hneq. destruct (InA_dec pair_dec (y, M.multiplicity y m) (M.elements m)) as [Hin | Hin].
        now apply (H3 y (M.multiplicity y m)).
        rewrite M.elements_spec in Hin.
        assert (M.multiplicity y m = 0%nat). {cut (~M.multiplicity y m > 0)%nat. clear. omega. now auto. }
        now rewrite H. }
rewrite Hm. clear Hm.
assert (Hdup := M.elements_NoDupA m).
revert r. induction (M.elements m) as [| [x' n'] l]; intro r.
* simpl. split; intro H.
    left. split. assumption. intros p Habs. now inversion Habs.
    destruct H as [[H _] | [H _]]. assumption. now inversion H.
* simpl. inversion_clear Hdup. rename H into Hnin. rename H0 into Hdup.
  rewrite IHl; trivial. clear IHl. split; intros [[H1 H2] | [H1 [H2 H3]]].
  + destruct r eqn:Hr; simpl in H1.
    - right. destruct (pair_dec (x, n) (x', n')) as [Heq | Hneq].
        repeat split.
          now left.
          intros ? ? [H | H]; discriminate H.
          intros y p Hxy Hin. inversion_clear Hin.
            exfalso. apply Hxy. now compute in H, Heq; destruct H, Heq; subst.
            now apply (H2 y).
        elim Hneq. compute. inversion_clear H1. now split.
    - destruct (nat_compare n' n0) eqn:Hnn.
        now inversion_clear H1.
        inversion H1. subst l0 n0. clear H1. left. rewrite <- nat_compare_lt in Hnn. split.
          reflexivity.
          intros y p Hin. inversion_clear Hin.
            destruct H as [_ H]. compute in H. now subst n'.
            now apply (H2 y).
        inversion H1. subst x' n'. clear H1. right. repeat split.
          now left.
          intros y p [Habs | Habs]; inversion Habs. subst l0 n0. clear Habs. now rewrite <- nat_compare_gt in Hnn.
          intros y p Hneq Hin. inversion_clear Hin.
          destruct H as [H _]. compute in H. now elim Hneq.
          now apply (H2 y).
    - right. destruct (nat_compare n' n0) eqn:Hnn.
        now inversion_clear H1.
        now inversion_clear H1.
        inversion H1. subst x' n'. clear H1. repeat split.
          now left.
          intros ? ? [H | H]. discriminate H. inversion H. subst m0. clear H. now rewrite <- nat_compare_gt in Hnn.
          intros y p Hneq Hin. inversion_clear Hin.
            compute in H. destruct H. now elim Hneq.
            now apply (H2 y).
  + destruct r eqn:Hr; simpl in H1.
    - right. destruct (pair_dec (x, n) (x', n')) as [Heq | Hneq].
        repeat split.
          now left.
          intros ? ? [H | H]; discriminate H.
          intros y p Hxy Hin. inversion_clear Hin.
            exfalso. apply Hxy. now compute in H, Heq; destruct H, Heq; subst.
            now apply (H3 y).
        repeat split.
          now right.
          intros ? ? [H | H]; discriminate H.
          intros y p Hxy Hin. inversion_clear Hin.
            compute in H; destruct H; subst. simpl in H2. apply (H2 x'). now left.
            now apply (H3 y).
    - simpl in H2. destruct (nat_compare n' n0) eqn:Hnn.
        right. rewrite nat_compare_eq_iff in Hnn. subst n0. repeat split.
          now right.
          intros y m' [Heq | Habs].
            inversion Heq. subst m' l0. clear Heq. apply (H2 y). now right.
            now inversion Habs.
          intros y p Hxy Hin. inversion_clear Hin.
            compute in H; destruct H; subst. apply (H2 x'). now right.
            now apply (H3 y).
        rewrite <- nat_compare_lt in Hnn. destruct (pair_dec (x, n) (l0, n0)) as [Heq | Hneq].
          compute in Heq; destruct Heq; subst. elim (lt_irrefl n0). apply (H2 l0). now left.
          right. repeat split.
            now right.
            intros y p [Hin | Hin]; inversion Hin. subst l0 n0. clear Hin. apply (H2 y). now left.
            intros y p Hxy Hin. inversion_clear Hin.
              compute in H; destruct H; subst. transitivity n0. assumption. apply (H2 l0). now left.
              now apply (H3 y).
        rewrite <- nat_compare_gt in Hnn. right. repeat split.
          now right.
          intros y p [Hin | Hin]; inversion Hin. subst. transitivity n'. assumption. apply (H2 x'). now left.
          intros y p Hxy Hin. inversion_clear Hin.
            compute in H; destruct H; subst. apply (H2 x'). now left.
            now apply (H3 y).
    - right. repeat split.
        now right.
        intros y p [Hin | Hin]; inversion Hin; subst; clear Hin. simpl in H2. destruct (nat_compare n' p) eqn:Hnp.
          apply (H2 y). now right.
          apply (H2 y). now right.
          transitivity n'.
            now rewrite <- nat_compare_gt in Hnp.
            apply (H2 x'). now left.
        intros y p Hxy Hin. simpl in H2. destruct (nat_compare n' n0) eqn:Hnn.
          rewrite nat_compare_eq_iff in Hnn. subst n0. inversion_clear Hin.
            compute in H; destruct H; subst. apply (H2 x'). now right.
            now apply (H3 y).
          rewrite <- nat_compare_lt in Hnn. inversion_clear Hin.
            compute in H; destruct H; subst. transitivity n0.
              assumption.
              apply (H2 x'). now right.
            now apply (H3 y).
          rewrite <- nat_compare_gt in Hnn. inversion_clear Hin.
            compute in H; destruct H; subst. apply (H2 x'). now left.
            now apply (H3 y).
  + subst r. simpl.
    assert (Hnn : nat_compare n' n = Lt). { rewrite <- nat_compare_lt. apply (H2 x'). now left. }
    rewrite Hnn. left. split.
      reflexivity.
      intros y p Hin. apply (H2 y). now right.
  + destruct r eqn:Hr; simpl.
    - destruct (pair_dec (x, n) (x', n')) as [Heq | Hneq].
        left. compute in Heq; destruct Heq; subst n' x'. split.
          reflexivity.
          intros y p Hin. destruct (Rdec x y).
            subst y. elim Hnin. apply (@InA_eqA _ M.eq_key _ l (x, p)).
              reflexivity.
              revert Hin. apply InA_impl_compat; trivial. now intros ? ? [? ?].
            apply (H3 y). assumption. now right.
        inversion_clear H1.
          contradiction.
          right. repeat split.
            assumption.
            intros y p [Hin | Hin]; inversion Hin; subst y p; clear Hin.
            assert (x <> x').
            { intro Habs. subst x'. apply Hnin. apply (@InA_eqA _ _ _ l (x, n)).
                reflexivity.
                revert H. apply InA_impl_compat; trivial. now intros ? ? [? ?]. }
            apply (H3 x'). assumption. now left.
            intros y p Hxy Hin. apply (H3 y). assumption. now right.
    - destruct (nat_compare n' n0) eqn:Hnn.
        right. rewrite nat_compare_eq_iff in Hnn. subst n0. destruct (eq_nat_dec n n') as [Habs | Hnn].
          subst n'. elim (lt_irrefl n). apply (H2 l0). now left.
          inversion_clear H1. elim Hnn. now destruct H. repeat split.
            assumption.
            intros y p [Hin | Hin]; inversion Hin; subst n'; clear Hin. apply (H2 l0). now left.
            intros y p Hxy Hin. apply (H3 y). assumption. now right.
        rewrite <- nat_compare_lt in Hnn. right. inversion_clear H1.
          compute in H; destruct H; subst x' n'. elim (lt_irrefl n). transitivity n0.
            assumption.
            apply (H2 l0). now left.
          repeat split.
            assumption.
            intros y p [Hin | Hin]; inversion Hin; subst l0 n0; clear Hin. apply (H2 y). now left.
            intros y p Hxy Hin. apply (H3 y). assumption. now right.
        destruct (pair_dec (x, n) (x', n')) as [Heq | Hneq].
          left. clear H1 H2. compute in Heq; destruct Heq; subst x' n'. split.
            reflexivity.
            intros y p Hin. destruct (Rdec x y).
              subst y. elim Hnin. apply (@InA_eqA _ _ _ _ (x, p)).
                reflexivity.
                revert Hin. apply InA_impl_compat; trivial. now intros ? ? [? ?].
              apply (H3 y). assumption. now right.
          right. inversion_clear H1.
            contradiction.
            repeat split.
              assumption.
              intros y p [Hin | Hin]; inversion Hin; subst y p; clear Hin. apply (H3 x').
                intro Habs. subst x'. apply Hnin. apply (@InA_eqA _ _ _ _ (x, n)).
                  reflexivity.
                  revert H. apply InA_impl_compat; trivial. now intros ? ? [? ?].
                now left.
              intros y p Hxy Hin. apply (H3 y). assumption. now right.
    - destruct (nat_compare n' n0) eqn:Hnn.
        rewrite nat_compare_eq_iff in Hnn. subst n0.
        assert (Hnn : (n' < n)%nat). { apply (H2 x). now right. }
        right. repeat split.
          inversion_clear H1.
            compute in H; destruct H; subst x' n'. now elim (lt_irrefl n).
            assumption.
          intros y p [Hin | Hin]; inversion Hin; subst p; clear Hin. assumption.
          intros y p Hxy Hin. apply (H3 y). assumption. now right.
        rewrite <- nat_compare_lt in Hnn.
        assert (Hlt : (n' < n)%nat). { transitivity n0. assumption. apply (H2 x). now right. }
        right. repeat split.
          inversion_clear H1.
            compute in H; destruct H; subst x' n'. now elim (lt_irrefl n).
            assumption.
          intros y p [Hin | Hin]; inversion Hin; subst p; clear Hin. apply (H2 x). now right.
          intros y p Hxy Hin. apply (H3 y). assumption. now right.
        destruct (pair_dec (x, n) (x', n')) as [Heq | Hneq].
          left. clear H1 H2. compute in Heq; destruct Heq; subst x' n'. split.
            reflexivity.
            intros y p Hin. destruct (Rdec x y).
              subst y. elim Hnin. apply (@InA_eqA _ _ _ _ (x, p)).
                reflexivity.
                revert Hin. apply InA_impl_compat; trivial. now intros ? ? [? ?].
              apply (H3 y). assumption. now right.
          right. inversion_clear H1.
            contradiction.
            repeat split.
              assumption.
              intros y p [Hin | Hin]; inversion Hin; subst y p; clear Hin. apply (H3 x').
                intro Habs. subst x'. apply Hnin. apply (@InA_eqA _ _ _ _ (x, n)).
                  reflexivity.
                  revert H. apply InA_impl_compat; trivial. now intros ? ? [? ?].
                now left.
              intros y p Hxy Hin. apply (H3 y). assumption. now right.
Qed.

Corollary majority_stack_Valid_spec : forall l x n,
  (majority_stack l = Valid x n
   <-> (M.multiplicity x (multiset l) = n /\ forall y, x <> y -> M.multiplicity y (multiset l) < n)%nat).
Proof.
intros l x n. destruct n.
+ split; intro H.
  - apply majority_stack_Valid_0 in H. elim H.
  - destruct H as [_ H]. specialize (H _ (succ_neq x)). omega.
+ unfold majority_stack. rewrite majority_stack_Valid_spec_aux. split; intro H.
  - destruct H as [[Habs _] | [H1 [H2 H3]]].
      discriminate Habs.
      now split.
  - destruct H as [H1 H2]. right. repeat split.
      assumption.
      intros ? ? [Habs | Habs]; discriminate Habs.
      assumption.
  - omega.
Qed.

Theorem majority_stack_spec : forall pos x,
  (exists n, majority_stack (nominal_spectrum pos) = Valid x n) <-> Stack_at x pos.
Proof. intro pos. setoid_rewrite majority_stack_Valid_spec. unfold Stack_at. reflexivity. Qed.

Lemma majority_stack_Invalid_0_aux : forall m r,
  M.fold f_majority m r = Invalid 0 <-> M.Empty m /\ r = Invalid 0.
Proof.
intros m r. rewrite M.fold_spec. rewrite <- M.elements_nil.
assert (Hm : forall xn, InA M.eq_pair xn (M.elements m) -> M.multiplicity (fst xn) m = snd xn /\ (snd xn > 0)%nat)
by (intro; apply M.elements_spec).
revert r. induction (M.elements m); simpl; intro r.
  now intuition.
  rewrite IHl. clear IHl.
    split; intros [H1 H2]; exfalso.
      subst l. destruct a, r; simpl in H2.
        discriminate H2.
        destruct (nat_compare n n0) eqn:Hn; try discriminate H2.
        inversion H2. rewrite nat_compare_eq_iff in Hn. subst. clear H2.
        apply (gt_irrefl 0). apply (Hm (e, 0%nat)). now left.
        destruct (nat_compare n n0) eqn:Hn.
          inversion H2. rewrite nat_compare_eq_iff in Hn. subst. clear H2.
          apply (gt_irrefl 0). apply (Hm (e, 0%nat)). now left.
          inversion H2. rewrite <- nat_compare_lt in Hn. subst. now inversion Hn.
          discriminate H2.
      discriminate H1.
    intros xn Hin. apply (Hm xn). now right.
Qed.

Corollary majority_stack_Invalid_0 : forall m, majority_stack m <> Invalid 0.
Proof.
unfold majority_stack. intros m H. rewrite majority_stack_Invalid_0_aux in H. destruct H as [_ H]. discriminate H.
Qed.

Lemma majority_stack_Invalid_spec_aux : forall l n r, n > 0 ->
  List.fold_left (fun acc xn => f_majority (fst xn) (snd xn) acc) (M.elements (multiset l)) r = Invalid n ->
  r = Invalid n /\ (forall z p, InA M.eq_pair (z, p) (M.elements (multiset l)) -> p < n)
  \/ exists x y, InA M.eq_pair (x, n) (M.elements (multiset l))
                /\ (r = Valid y n
                    \/ r = Invalid n
                    \/ InA M.eq_pair (y, n) (M.elements (multiset l))
                       /\ (forall y m, (r = Valid y m \/ r = Invalid m) -> m < n)
                       /\ x <> y)
                /\ (forall z p, InA M.eq_pair (z, p) (M.elements (multiset l)) -> p <= n).
Proof.
intros l' n r Hn. revert r.
assert (Hdup := M.elements_NoDupA (multiset l')).
induction (M.elements (multiset l')) as [| [x' n'] l]; clear l'; simpl; intros r Hl.
  left. split. assumption. intros ? ? Habs. now inversion Habs.
  inversion_clear Hdup. apply IHl in Hl; trivial. clear IHl.
  destruct r eqn:Hr.
  * destruct Hl as [[Hl1 Hl2] | [x [y [Hx [Hy Hle]]]]]; simpl in *.
    + discriminate Hl1.
    + right. exists x. exists y. repeat split.
        now right.
        do 2 right. destruct Hy as [Hy | [Hy | [Hy1 [Hy2 Hxy]]]].
          inversion Hy. subst. clear Hy. repeat split.
            now left.
            intros z p [Habs | Habs]; discriminate Habs.
            intro. subst y. apply H. revert Hx. now apply (InA_impl_compat _).
          now inversion Hy.
          repeat split.
            now right.
            intros z p [Habs | Habs]; discriminate Habs.
            assumption.
        intros z p Hin. inversion_clear Hin.
          compute in H1; destruct H1; subst x' n'. destruct Hy as [Hy | [Hy | [Hy1 [Hy2 Hxy]]]].
            now inversion_clear Hy.
            now inversion_clear Hy.
            apply lt_le_weak. apply (Hy2 z). now left.
          now apply (Hle z).
  * destruct Hl as [[Hl1 Hl2] | [x [y [Hx [Hy Hle]]]]]; simpl in *.
    + destruct (nat_compare n' n0) eqn:Hnn; try discriminate Hl1.
      rewrite nat_compare_eq_iff in Hnn. inversion Hl1. subst n0 n'. clear Hl1.
      right. exists x'. exists l0. repeat split.
        now left.
        now left.
        intros z p Hin. inversion_clear Hin.
          compute in H1. now intuition.
          apply lt_le_weak. now apply (Hl2 z).
    + right. destruct (nat_compare n' n0) eqn:Hnn.
      - rewrite nat_compare_eq_iff in Hnn. subst n0.
        destruct Hy as [Hy | [Hy | [Hy1 [Hy2 Hxy]]]].
          discriminate Hy.
          inversion Hy. subst n'. clear Hy. exists x. exists l0. repeat split.
            now right.
            now left.
            intros z p Hin. inversion_clear Hin.
              compute in H1. destruct H1. subst. reflexivity.
              now apply (Hle z).
          exists x. exists y. repeat split.
            now right.
            do 2 right. repeat split.
              now right.
              intros z p [Habs | Habs].
                apply (Hy2 z). right. now inversion Habs.
                discriminate Habs.
              assumption.
            intros z p Hin. inversion_clear Hin.
              compute in H1; destruct H1; subst x' n'. apply lt_le_weak, (Hy2 z). now right.
              now apply (Hle z).
      - rewrite <- nat_compare_lt in Hnn. exists x. exists y.
        destruct Hy as [Hy | [Hy | [Hy1 [Hy2 Hxy]]]].
          inversion Hy. subst n0 l0. clear Hy. repeat split.
            now right.
            now left.
            intros z p Hin. inversion_clear Hin.
              compute in H1; destruct H1; subst. now apply lt_le_weak.
              now apply (Hle z).
          discriminate Hy.
          repeat split.
            now right.
            do 2 right. repeat split.
              now right.
              intros z p [Hin | Hin].
                apply (Hy2 l0). left. now inversion Hin.
                discriminate Hin.
              assumption.
              intros z p Hin. inversion_clear Hin.
                compute in H1; destruct H1; subst x' n'. apply lt_le_weak. transitivity n0.
                  assumption.
                  apply (Hy2 l0). now left.
            now apply (Hle z).
      - rewrite <- nat_compare_gt in Hnn. exists x. exists y.
        destruct Hy as [Hy | [Hy | [Hy1 [Hy2 Hxy]]]].
          inversion Hy. subst x' n'. clear Hy. repeat split.
            now right.
            do 2 right. repeat split.
              now left.
              intros z p [Hin | Hin].
                inversion Hin. subst n0 l0. clear Hin. assumption.
                discriminate Hin.
              intro. subst y. apply H. revert Hx. now apply (InA_impl_compat _).
            intros z p Hin. inversion_clear Hin.
              compute in H1. now intuition.
              now apply (Hle z).
          discriminate Hy.
          repeat split.
            now right.
            do 2 right. repeat split.
              now right.
              intros z p [Hin | Hin].
                inversion Hin. subst n0 l0. clear Hin. transitivity n'.
                  assumption.
                  apply (Hy2 x'). now left.
                discriminate Hin.
              assumption.
            intros z p Hin. inversion_clear Hin.
              compute in H1. destruct H1. subst. apply lt_le_weak, (Hy2 x'). now left.
              now apply (Hle z).
  * destruct Hl as [[Hl1 Hl2] | [x [y [Hx [Hy Hle]]]]]; simpl in *.
    + destruct (nat_compare n' n0) eqn:Hnn; try discriminate Hl1.
      - rewrite nat_compare_eq_iff in Hnn. inversion Hl1. subst n0 n'. clear Hl1.
        right. exists x'. exists x'. repeat split.
          now left.
          now right; left.
          intros z p Hin. inversion_clear Hin.
            compute in H1. now intuition.
            apply lt_le_weak. now apply (Hl2 z).
      - rewrite <- nat_compare_lt in Hnn. inversion Hl1. subst n0. clear Hl1.
        left. split. reflexivity.
        intros z p Hin. inversion_clear Hin.
          compute in H1. now intuition.
          now apply (Hl2 z).
    + right. exists x. exists y. destruct (nat_compare n' n0) eqn:Hnn.
      - rewrite nat_compare_eq_iff in Hnn. subst n0.
        destruct Hy as [Hy | [Hy | [Hy1 [Hy2 Hxy]]]].
          discriminate Hy.
          inversion Hy. subst n'. clear Hy. repeat split.
            now right.
            now right; left.
            intros z p Hin. inversion_clear Hin.
              compute in H1. destruct H1. subst. reflexivity.
              now apply (Hle z).
          repeat split.
            now right.
            do 2 right. repeat split.
              now right.
              intros z p [Habs | Habs].
                discriminate Habs.
                apply (Hy2 z). now right.
              assumption.
            intros z p Hin. inversion_clear Hin.
              compute in H1; destruct H1; subst x' n'. apply lt_le_weak, (Hy2 z). now right.
              now apply (Hle z).
      - rewrite <- nat_compare_lt in Hnn.
        destruct Hy as [Hy | [Hy | [Hy1 [Hy2 Hxy]]]].
          discriminate Hy.
          inversion Hy. subst n0. clear Hy. repeat split.
            now right.
            now right; left.
            intros z p Hin. inversion_clear Hin.
              compute in H1; destruct H1; subst. now apply lt_le_weak.
              now apply (Hle z).
          repeat split.
            now right.
            do 2 right. repeat split.
              now right.
              intros z p [Hin | Hin].
                discriminate Hin.
                apply (Hy2 y). now right.
              assumption.
              intros z p Hin. inversion_clear Hin.
                compute in H1; destruct H1; subst x' n'. apply lt_le_weak. transitivity n0.
                  assumption.
                  apply (Hy2 y). now right.
            now apply (Hle z).
      - rewrite <- nat_compare_gt in Hnn.
        destruct Hy as [Hy | [Hy | [Hy1 [Hy2 Hxy]]]].
          inversion Hy. subst x' n'. clear Hy. repeat split.
            now right.
            do 2 right. repeat split.
              now left.
              intros z p [Hin | Hin].
                discriminate Hin.
                inversion Hin. subst n0. clear Hin. assumption.
              intro. subst y. apply H. revert Hx. now apply (InA_impl_compat _).
            intros z p Hin. inversion_clear Hin.
              compute in H1. now intuition.
              now apply (Hle z).
          discriminate Hy.
          repeat split.
            now right.
            do 2 right. repeat split.
              now right.
              intros z p [Hin | Hin].
                discriminate Hin.
                inversion Hin. subst n0. clear Hin. transitivity n'.
                  assumption.
                  apply (Hy2 x'). now left.
              assumption.
            intros z p Hin. inversion_clear Hin.
              compute in H1. destruct H1. subst. apply lt_le_weak, (Hy2 x'). now left.
              now apply (Hle z).
Qed.

Corollary majority_stack_Invalid_correct : forall l n,
  majority_stack l = Invalid n ->
  n > 0 /\ exists x, exists y, M.multiplicity x (multiset l) = n /\ M.multiplicity y (multiset l) = n
                                /\ x <> y /\ forall z, M.multiplicity z (multiset l) <= n.
Proof.
intros l n H.
assert (Hn : n > 0) by (destruct n; omega || elim (majority_stack_Invalid_0 H)).
split. assumption.
unfold majority_stack in H. rewrite M.fold_spec in H.
apply (majority_stack_Invalid_spec_aux _ _ Hn) in H.
destruct H as [[Habs _] | [x [y [Hx [Hy Hle]]]]].
  discriminate Habs.
  exists x. exists y. destruct Hy as [Habs | [Habs | [Hy [_ Hxy]]]]; try discriminate Habs.
  rewrite M.elements_spec in *. simpl in *. destruct Hx, Hy. repeat split; trivial.
  intros z. destruct (M.multiplicity z (multiset l)) eqn:Hz.
    omega.
    rewrite <- Hz. apply (Hle z). rewrite M.elements_spec. split. reflexivity. rewrite Hz. simpl. omega.
Qed.

Theorem majority_stack_Invalid_spec : forall l n,
  majority_stack l = Invalid n <->
  n > 0 /\ exists x, exists y, M.multiplicity x (multiset l) = n /\ M.multiplicity y (multiset l) = n
                                /\ x <> y /\ forall z, M.multiplicity z (multiset l) <= n.
Proof.
intros l n. split; intro H.
+ now apply majority_stack_Invalid_correct.
+ destruct H as [Hn [x [ y [ H1 [H2 [H3 H4]]]]]]. destruct (majority_stack l) as [| pt p | p] eqn:Hmaj.
  - rewrite majority_stack_NoResult_spec in Hmaj. subst l. rewrite multiset_nil in *.
    rewrite M.empty_spec in H1. subst n. now elim (lt_irrefl 0).
  - rewrite majority_stack_Valid_spec in Hmaj. destruct Hmaj as [Hmaj1 Hmaj2].
    destruct (Rdec pt x).
      subst pt. rewrite H1 in Hmaj1. subst p. elim (lt_irrefl n). rewrite <- H2 at 1. now apply (Hmaj2 y).
      elim (lt_irrefl p). apply le_lt_trans with n.
        rewrite <- Hmaj1. now apply H4.
        rewrite <- H1. now apply (Hmaj2 x).
  - f_equal. apply majority_stack_Invalid_correct in Hmaj. destruct Hmaj as [Hp [x' [y' [Hx [ Hy [_ Hle]]]]]].
     apply le_antisym.
       rewrite <- Hx. now apply H4.
       rewrite <- H1. now apply Hle.
Qed.

Lemma majority_stack_Invalid_1 : forall l, majority_stack l = Invalid 1 -> NoDup l.
Proof.
intros l Hl. destruct (NoDup_dec Rdec l) as [| Habs]. assumption. exfalso.
rewrite <- NoDupA_Leibniz in Habs. apply (not_NoDupA _ Rdec) in Habs. destruct Habs as [x [l' Hperm]].
rewrite PermutationA_Leibniz in Hperm. rewrite Hperm in Hl. clear Hperm.
cut (2 <= 1). omega.
rewrite majority_stack_Invalid_spec in Hl. destruct Hl as [_ [_ [_ [_ [_ [_ Hle]]]]]].
transitivity (M.multiplicity x (multiset l') + 1 +1). omega.
do 2 rewrite <- M.add_spec, <- multiset_cons. apply Hle.
Qed.


Ltac Rdec_aux H :=
  match type of H with
    | context[Rdec ?x ?y] =>
      let Heq := fresh "Heq" in let Hneq := fresh "Hneq" in
      destruct (Rdec x y) as [Heq | Hneq]
    | _ => fail
  end.


(**  Back to the proof  **)

Lemma remove_alls_2 : forall x y l n, remove Rdec x l = alls y (S n) -> forall z, In z (x :: l) <-> z = x \/ z = y.
Proof.
intros x y l n Hl z. split; intro Hin.
- destruct (Rdec z x). now left. right.
  rewrite <- (remove_in_out Rdec x) in Hin.
  simpl in Hin. Rdec. rewrite Hl in Hin.
  now apply alls_In with (S n). auto.
- destruct (Rdec z x). subst. now left. destruct Hin. contradiction. subst.
  right. rewrite <- (remove_in_out Rdec x). rewrite Hl. now left. auto.
Qed.

Open Scope R_scope.
Definition range b1 b2 (s : spectrum) :=
  List.Forall (fun x => b1 <= x <= b2) s.

Lemma range_compat : Proper (eq ==> eq ==> @Permutation R ==> iff) range.
Proof.
intros inf1 inf2 ? sup1 sup2 ? s1 s2 Hs. subst.
unfold range. split; apply Forall_Perm_trans; trivial. reflexivity. reflexivity. now symmetry.
Qed.

Lemma range_split : forall b1 b2 s,
  range b1 b2 s <-> (List.Forall (fun x => b1 <= x) s /\ List.Forall (fun x => x <= b2) s).
Proof.
intros b1 b2 s. unfold range. setoid_rewrite List.Forall_forall.
intuition; apply (H _ H0).
Qed.

Definition extremal r (s : spectrum) :=
  exists b, range b r s \/ range r b s.

(*
Parameter is_extremal : ident Four Zero -> position Four Zero -> bool.
Hypothesis is_extremal_correct : forall r pos, is_extremal r pos = true <-> extremal r pos.
*)

Definition is_extremal r (s : spectrum) :=
  if Rdec r (List.hd r (sort s)) then true else
  if Rdec r (List.last (sort s) r) then true else false.

Theorem is_extremal_correct : forall r (s : spectrum),
  List.In r s -> (is_extremal r s = true <-> extremal r s).
Proof.
unfold is_extremal,extremal. intros r s Hin.
repeat Rdec_full; split; intro H; try (reflexivity || discriminate H);
try solve [reflexivity | discriminate H | right; now intros [] | left; now intros []].
+ clear H. rewrite Heq. exists (List.last (sort s) r). right.
  rewrite range_split. split;
  rewrite List.Forall_forall; apply sort_min || apply sort_max.
+ clear H. exists (List.hd r (sort s)). left. rewrite Heq.
  rewrite range_split. split;
  rewrite List.Forall_forall; apply sort_min || apply sort_max.
+ exfalso. destruct H as [b [Hb | Hb]].
  - elim (Rlt_irrefl r). apply Rlt_le_trans with (List.last (sort s) r).
      revert Hneq0. generalize (sort_max s r r Hin). apply Rle_neq_lt.
      apply range_split in Hb. destruct Hb as [_ Hb]. rewrite List.Forall_forall in Hb.
      apply Hb. rewrite (Permuted_sort s) at 2. apply last_In.
      rewrite (Permuted_sort s) in Hin. destruct (sort s).
      inversion Hin. discriminate.
  - elim (Rlt_irrefl r). apply Rle_lt_trans with (List.hd r (sort s)).
      apply range_split in Hb. destruct Hb as [Hb _]. rewrite List.Forall_forall in Hb.
      apply Hb. rewrite (Permuted_sort s) at 2.
      rewrite (Permuted_sort s) in Hin. destruct (sort s).
      inversion Hin. now left.
      assert (Hneq' : List.hd r (sort s) <> r). { intro. apply Hneq. now symmetry. }
      revert Hneq'. generalize (sort_min s r r Hin). apply Rle_neq_lt.
Qed.

Instance is_extremal_perm_invariant : Proper (eq ==> @Permutation R ==> eq) is_extremal.
Proof.
intros x y ? s s' Hs. subst. unfold is_extremal.
assert (Heq : sort s = sort s'). now rewrite Hs. now rewrite Heq.
Qed.

Definition monotonic {A B : Type} (RA : relation A) (RB : relation B) (f : A -> B) :=
  Proper (RA ==> RB) f \/ Proper (RA --> RB) f.

Lemma similarity_increasing : forall k t, k >= 0 -> Proper (Rleb ==> Rleb) (fun x => k * (x - t)).
Proof. repeat intro. hnf in *. rewrite Rleb_spec in *. apply Rmult_le_compat_l; lra. Qed.

Lemma similarity_decreasing : forall k t, k <= 0 -> Proper (Rleb --> Rleb) (fun x => k * (x - t)).
Proof.
repeat intro. hnf in *. rewrite Rleb_spec in *. apply Ropp_le_cancel.
replace (- (k * (y - t))) with ((- k) * (y - t)) by ring.
replace (- (k * (x - t))) with ((- k) * (x - t)) by ring.
apply Rmult_le_compat_l; lra.
Qed.

Corollary similarity_monotonic : forall k t, monotonic Rleb Rleb (fun x => k * (x - t)).
Proof.
intros k t. destruct (Rle_lt_dec 0 k) as [Hlt | Hle].
+ left. apply similarity_increasing. lra.
+ right. apply similarity_decreasing. lra.
Qed.

Lemma similarity_injective : forall k t, k <> 0 -> injective eq eq (fun x => k * (x - t)).
Proof. intros k t Hk x y. now rewrite local_invert. Qed.


Lemma is_extremal_map_monotonic_invariant : forall f, monotonic Rleb Rleb f -> injective eq eq f ->
  forall x l, is_extremal (f x) (map f l) = is_extremal x l.
Proof.
intros f Hfmon Hfinj x l. unfold is_extremal. destruct Hfmon as [Hfinc | Hfdec].
+ rewrite (sort_map_increasing Hfinc). rewrite map_hd, map_last.
  repeat Rdec_full; reflexivity || (apply Hfinj in Heq; contradiction)
                     || (now rewrite Heq in Hneq at 1; auto) || (rewrite Heq in Hneq0 at 1; auto).
+ rewrite (sort_map_decreasing Hfdec). rewrite hd_rev_last, last_rev_hd, map_hd, map_last.
  repeat Rdec_full; reflexivity || (apply Hfinj in Heq; contradiction)
                     || (now rewrite Heq in Hneq at 1; auto) || (rewrite Heq in Hneq0 at 1; auto).
Qed.

Corollary is_extremal_similarity_invariant : forall k t pos r, k <> 0 ->
  is_extremal (k * (r - t)) (nominal_spectrum (⟦k, t⟧ pos)) = is_extremal r (nominal_spectrum pos).
Proof.
intros k t pos r Hk. rewrite nominal_spectrum_similarity.
now rewrite (is_extremal_map_monotonic_invariant (similarity_monotonic k t) (similarity_injective Hk)).
Qed.

Definition extreme_center (s : spectrum) :=
  (List.hd 0 (sort s) + List.last (sort s) 0) / 2.
(* When there is no robot (s is empty), the center is 0. *)

Instance extreme_center_perm_invariant : Proper (@Permutation R ==> eq) extreme_center.
Proof. intros s s' Hs. unfold extreme_center. now rewrite Hs. Qed.

Lemma extreme_center_map_similarity_invariant : forall k t, k <> 0 ->
  forall l, l <> nil -> extreme_center (map (fun x => k * (x - t)) l) = k * (extreme_center l - t).
Proof.
intros k t Hk l Hl. destruct (similarity_monotonic k t) as [Hinc | Hdec].
+ unfold extreme_center. rewrite (sort_map_increasing Hinc). generalize 0.
  assert (Hperm := Permuted_sort l). destruct (sort l) as [| x l']; intro r.
    symmetry in Hperm. apply Permutation_nil in Hperm. contradiction.
    clear l Hl Hperm. simpl hd. cut (x :: l' <> nil). generalize (x :: l'). intro l.
    revert r. induction l; intros r Hl.
      now elim Hl.
      simpl. destruct l.
        simpl. field.
        rewrite <- IHl. reflexivity. discriminate. discriminate.
+ unfold extreme_center. rewrite (sort_map_decreasing Hdec).
  rewrite last_rev_hd, hd_rev_last. generalize 0.
  assert (Hperm := Permuted_sort l). destruct (sort l) as [| x l']; intro r.
    symmetry in Hperm. apply Permutation_nil in Hperm. contradiction.
    clear l Hl Hperm. simpl hd. cut (x :: l' <> nil). generalize (x :: l'). intro l.
    revert r. induction l; intros r Hl.
      now elim Hl.
      simpl. destruct l.
        simpl. field.
        rewrite <- IHl. reflexivity. discriminate. discriminate.
Qed.

Lemma extreme_center_similarity_invariant : forall k t pos, k <> 0 ->
  extreme_center (nominal_spectrum (⟦k, t⟧ pos)) = k * (extreme_center (nominal_spectrum pos) - t).
Proof.
intros k t pos Hk. rewrite nominal_spectrum_similarity, extreme_center_map_similarity_invariant; trivial.
assert (Hin : In (locate  pos (Good _ g1)) (nominal_spectrum pos)) by apply In_spectrum.
intro Habs. rewrite Habs in Hin. inversion Hin.
Qed.

(** The robogram works as follows:
    1) if there is a mojority stack, everyone goes there;
    2) if there are three stacks, everyone goes on the middle one;
    3) otherwise, robots located at non extremal locations go to the middle of the extremal locations.
    The last case will necessarily end into one of the first two, ensuring termination.
**)
Definition robogram (s : spectrum) : location :=
  match majority_stack s with
    | NoResult => 0 (* there is no robot anyway in this case *)
    | Valid p n => p
    | Invalid n => if beq_nat (length (M.support (multiset s))) 3
                   then List.nth 1 (sort (M.support (multiset s))) 0 else
                   if is_extremal 0 s then 0 else extreme_center s end.

Print Assumptions robogram.

(** The robogram is invariant by permutation of spectra. *)
Instance robogram_invariant : Proper (@Permutation R ==> eq) robogram.
Proof.
unfold robogram. intros s s' Hperm. rewrite Hperm.
destruct (majority_stack s'); trivial. now repeat rewrite Hperm.
Qed.
Print Assumptions robogram_invariant.


(* Actually, [n] does not depend on [pt] but it is easier to use this way. *)
Lemma nominal_spectrum_alls : forall pt,
  nominal_spectrum (@lift_gp nG (fun _ => pt)) = alls pt nG.
Proof.
intro. unfold nominal_spectrum. simpl. rewrite app_nil_r.
induction nG. reflexivity. simpl. now rewrite <- IHn.
Qed.

Lemma forbidden_similarity_invariant : forall pos k t, forbidden ((⟦k, t⟧) pos) -> forbidden pos.
Proof.
intros [gp bp] k t [p1 [p2 [n [Hneq Hperm]]]]. destruct (Rdec k 0).
+ subst. assert (Heq : PosEq (lift_gp (fun _ => 0)) (⟦0, t⟧ {| gp := gp; bp := bp |})).
  { split; simpl. intro. now rewrite Rmult_0_l. intro. now apply Fin.case0. }
  rewrite <- Heq in Hperm. clear Heq. rewrite nominal_spectrum_alls in Hperm.
  symmetry in Hperm.
  assert (p1 = 0).
  { apply Permutation_alls in Hperm. destruct nG eqn:HG.
      cut (0 >= 2)%nat. omega. rewrite <- HG at 1. now apply size_G.
      destruct n as [| n]; simpl in Hperm.
        discriminate Hperm.
        now inversion Hperm. }
  assert (p2 = 0).
  { rewrite Permutation_app_comm in Hperm. apply Permutation_alls in Hperm. destruct nG eqn:HG.
      cut (0 >= 2)%nat. omega. rewrite <- HG at 1. now apply size_G.
      destruct n as [| n]; simpl in Hperm.
        discriminate Hperm.
        now inversion Hperm. }
  subst p2. contradiction.
+ exists (p1 / k + t). exists (p2 / k + t). exists n. split.
  clear -Hneq n0. intro Habs. apply Hneq. apply Rdiv_reg with k. assumption.
  apply Rplus_eq_reg_l with t. now setoid_rewrite Rplus_comm.
  clear Hneq. rewrite <- (@similarity_inverse _ _ k t); trivial. unfold similarity at 1.
  replace (p1 / k + t) with (/k * (p1 - - k * t)) by now field.
  change (/k * (p1 - - k * t)) with ((fun x => /k * (x - - k * t)) p1). rewrite <- map_alls.
  replace (p2 / k + t) with (/k * (p2 - - k * t)) by now field.
  change (/k * (p2 - - k * t)) with ((fun x => /k * (x - - k * t)) p2). rewrite <- map_alls.
  rewrite nominal_spectrum_map. rewrite <- map_app. now apply Permutation_map.
Qed.

Corollary forbidden_similarity_iff : forall k t pos, k <> 0 -> (forbidden (⟦k, t⟧ pos) <-> forbidden pos).
Proof.
intros k t pos Hk. split.
+ apply forbidden_similarity_invariant.
+ rewrite <- (similarity_inverse t pos Hk) at 1. apply forbidden_similarity_invariant.
Qed.

Definition equiv_by (f : R -> R) r r' :=
  match r, r' with
    | NoResult, NoResult => True
    | Valid y m, Valid x n => y = f x /\ m = n
    | Invalid m, Invalid n => m = n
    | _, _ => False
  end.

Lemma majority_stack_inj_compat_aux : forall f l x n r r',
  injective eq eq f -> equiv_by f r r' ->
  (List.fold_left (fun acc xn => f_majority (fst xn) (snd xn) acc)
                  (map (fun xn => (f (fst xn), snd xn)) l) r = Valid (f x) n
  <-> List.fold_left (fun acc xn => f_majority (fst xn) (snd xn) acc) l r' = Valid x n).
Proof.
intros f l x n r r' Hf. revert r r'. induction l; intros r r' Hr; simpl.
+ split; intro; (subst r; destruct r') || (subst r'; destruct r); simpl in Hr; try now elim Hr.
    destruct Hr as [Hr1 Hr2]. apply Hf in Hr1. now subst.
    destruct Hr. now subst.
+ apply IHl. destruct a as [y m], r, r'; simpl; simpl in Hr; try now elim Hr.
    destruct Hr. subst. now destruct (nat_compare m n1).
    subst. now destruct (nat_compare m n1).
Qed.

Instance PermutationA_compat A eqA (HeqA : @Equivalence A eqA) :
  Proper (PermutationA eqA ==> PermutationA eqA ==> iff) (PermutationA eqA).
Proof. intros l1 l2 Hl12 l3 l4 Hl34. now rewrite Hl12, Hl34. Qed.

Lemma majority_stack_inj_map_Valid_compat : forall f l x n, injective eq eq f ->
  (majority_stack (map f l) = Valid (f x) n <-> majority_stack l = Valid x n).
Proof.
intros f l x n Hf. do 2 rewrite majority_stack_Valid_spec. split; intros [Hn Hle]; split.
+ clear Hle. revert n Hn. induction l; simpl; intros n Hn.
    now rewrite multiset_nil, M.empty_spec in *.
    destruct (Rdec a x) as [| Hneq].
      subst a. rewrite multiset_cons, M.add_spec in *. destruct n. omega.
      rewrite plus_comm in *; simpl in *. f_equal. apply eq_add_S in Hn. now apply IHl.
      assert (f a <> f x) by auto.
      rewrite multiset_cons, M.add_spec' in *; trivial. now apply IHl.
+ clear Hn. intros y Hxy. assert (Hn : f x <> f y) by auto. apply Hle in Hn. revert Hn. clear Hle Hxy.
  revert n y. induction l; simpl; intros n y Hin.
    now rewrite multiset_nil, M.empty_spec in *.
    rewrite multiset_cons in *. destruct (Rdec a y).
      subst a. rewrite M.add_spec in *. destruct n. omega.
      rewrite plus_comm in *; simpl in *. apply lt_n_S. apply lt_S_n in Hin. now apply IHl.
      assert (f a <> f y) by auto. rewrite M.add_spec' in *; trivial. now apply IHl.
+ clear Hle. revert n Hn. induction l; simpl; intros n Hn.
    now rewrite multiset_nil, M.empty_spec in *.
    destruct (Rdec a x) as [| Hneq].
      subst a. rewrite multiset_cons, M.add_spec in *. destruct n. omega.
      rewrite plus_comm in *; simpl in *. f_equal. apply eq_add_S in Hn. now apply IHl.
      assert (f a <> f x) by auto.
      rewrite multiset_cons, M.add_spec' in *; trivial. now apply IHl.
+ clear Hn. intros y Hxy. destruct (in_dec Rdec y (map f l)) as [Hin | Hin].
  - rewrite in_map_iff in Hin. destruct Hin as [z [Hyz Hin]]. subst y.
    assert (Hxz : x <> z). { intro. subst z. now apply Hxy. }
    apply Hle in Hxz. clear Hle Hxy Hin. revert n z Hxz. induction l; intros n z Hin.
      now rewrite multiset_nil, M.empty_spec in *.
      simpl. rewrite multiset_cons in *. destruct (Rdec a z).
        subst a. rewrite M.add_spec in *. destruct n. omega.
        rewrite plus_comm in *; simpl in *. apply lt_n_S. apply lt_S_n in Hin. now apply IHl.
        assert (f a <> f z) by auto. rewrite M.add_spec' in *; trivial. now apply IHl.
  - destruct n.
      specialize (Hle _ (succ_neq x)). omega.
      rewrite <- multiset_In in Hin. omega.
Qed.

Lemma majority_stack_Valid_similarity : forall k t pos x n, k <> 0 ->
  (majority_stack (nominal_spectrum ((⟦k, t⟧) pos)) = Valid (k * (x - t)) n
  <-> majority_stack (nominal_spectrum pos) = Valid x n).
Proof.
intros k t pos x n Hk. rewrite nominal_spectrum_similarity.
assert (Hf := fun x y => proj1 (@local_invert k t x y Hk)).
now rewrite (majority_stack_inj_map_Valid_compat _ _ _ Hf).
Qed.

Lemma majority_stack_Invalid_similarity : forall k t pos n, k <> 0 ->
  (majority_stack (nominal_spectrum ((⟦k, t⟧) pos)) = Invalid n
  <-> majority_stack (nominal_spectrum pos) = Invalid n).
Proof.
intros k t pos n Hk. rewrite nominal_spectrum_similarity. generalize (nominal_spectrum pos). clear pos.
intro s. do 2 rewrite majority_stack_Invalid_spec. split; intros [Hn [x [y [Hx [Hy [Hxy Hle]]]]]].
* split. assumption. exists (/k * x + t). exists (/k * y + t). repeat split.
  + clear y Hxy Hy Hle. revert n Hn Hx. induction s; simpl; intros n Hn Hx.
      now rewrite multiset_nil, M.empty_spec in *.
      rewrite multiset_cons in *. destruct (Rdec (k * (a - t)) x) as [Heq | Hneq].
      - subst x. assert (/k * (k * (a - t)) + t = a) by now field. rewrite H in *.
        rewrite M.add_spec in *. destruct n. omega. rewrite plus_comm in *. simpl in *.
        f_equal. apply eq_add_S in Hx. destruct n.
          assert (Hin : ~In (k * (a - t)) (map (fun x : R => k * (x - t)) s)). { rewrite <- multiset_In. omega. }
          rewrite in_map_iff in Hin. destruct (in_dec Rdec a s) as [| Hnin].
            elim Hin. exists a. now split.
            rewrite <- multiset_In in Hnin. omega.
          apply IHs. omega. assumption.
      - assert (a <> /k * x + t). { intro. subst a. apply Hneq. clear -Hk. unfold M.elt in x. now field. }
        rewrite M.add_spec' in *; trivial. now apply IHs.
  + clear x Hxy Hx Hle. revert n Hn Hy. induction s; simpl; intros n Hn Hy.
      now rewrite multiset_nil, M.empty_spec in *.
      rewrite multiset_cons in *. destruct (Rdec (k * (a - t)) y) as [Heq | Hneq].
      - subst y. assert (/k * (k * (a - t)) + t = a) by now field. rewrite H in *.
        rewrite M.add_spec in *. destruct n. omega. rewrite plus_comm in *. simpl in *.
        f_equal. apply eq_add_S in Hy. destruct n.
          assert (Hin : ~In (k * (a - t)) (map (fun x : R => k * (x - t)) s)). { rewrite <- multiset_In. omega. }
          rewrite in_map_iff in Hin. destruct (in_dec Rdec a s) as [| Hnin].
            elim Hin. exists a. now split.
            rewrite <- multiset_In in Hnin. omega.
          apply IHs. omega. assumption.
      - assert (a <> /k * y + t). { intro. subst a. apply Hneq. clear -Hk. unfold M.elt in y. now field. }
        rewrite M.add_spec' in *; trivial. now apply IHs.
  + rewrite <- (local_invert t _ _ Hk). intro Heq. field_simplify in Heq; auto. apply Hxy.
    assert (x / 1 = x) by field. rewrite <- H, Heq. now assert (y / 1 = y) by field.
  + clear x y Hx Hy Hxy. intro z. specialize (Hle (k * (z - t))).
    revert n Hn Hle. induction s; simpl; intros n Hn Hle.
      rewrite multiset_nil, M.empty_spec. omega.
      rewrite multiset_cons in *. destruct (Rdec a z).
      - subst z. rewrite M.add_spec in *. destruct n. omega. rewrite plus_comm in *. simpl in *.
        apply le_n_S. apply le_S_n in Hle. destruct n.
          assert (Hin : ~In (k * (a - t)) (map (fun x : R => k * (x - t)) s)). { rewrite <- multiset_In. omega. }
          rewrite in_map_iff in Hin. destruct (in_dec Rdec a s) as [| Hnin].
            elim Hin. exists a. now split.
            rewrite <- multiset_In in Hnin. omega.
          apply IHs. omega. assumption.
      - assert (k * (a - t) <> k * (z - t)) by now rewrite local_invert.
        rewrite M.add_spec' in *; trivial. now apply IHs.
* split. assumption. exists (k * (x - t)). exists (k * (y - t)). repeat split.
  + clear y Hxy Hy Hle. revert n Hn Hx. induction s; simpl; intros n Hn Hx.
      now rewrite multiset_nil, M.empty_spec in *.
      rewrite multiset_cons in *. destruct (Rdec a x) as [Heq | Hneq].
      - subst x. rewrite M.add_spec in *. destruct n. omega. rewrite plus_comm in *. simpl in *.
        f_equal. apply eq_add_S in Hx. destruct n.
          assert (Hnin : ~In a s). { rewrite <- multiset_In. omega. }
          assert (Hin : ~In (k * (a -t)) (map (fun x : R => k * (x - t)) s)).
          { rewrite in_map_iff. intros [x [Heq Hin]]. apply Hnin. rewrite local_invert in Heq; trivial. now subst a. }
          rewrite <- multiset_In in Hin. omega.
          apply IHs. omega. assumption.
      - assert (k * (a - t) <> k * (x - t)) by now rewrite local_invert.
        rewrite M.add_spec' in *; trivial. now apply IHs.
  + clear x Hxy Hx Hle. revert n Hn Hy. induction s; simpl; intros n Hn Hy.
      now rewrite multiset_nil, M.empty_spec in *.
      rewrite multiset_cons in *. destruct (Rdec a y) as [Heq | Hneq].
      - subst y. rewrite M.add_spec in *. destruct n. omega. rewrite plus_comm in *. simpl in *.
        f_equal. apply eq_add_S in Hy. destruct n.
          assert (Hnin : ~In a s). { rewrite <- multiset_In. omega. }
          assert (Hin : ~In (k * (a -t)) (map (fun x : R => k * (x - t)) s)).
          { rewrite in_map_iff. intros [x [Heq Hin]]. apply Hnin. rewrite local_invert in Heq; trivial. now subst a. }
          rewrite <- multiset_In in Hin. omega.
          apply IHs. omega. assumption.
      - assert (k * (a - t) <> k * (y - t)) by now rewrite local_invert.
        rewrite M.add_spec' in *; trivial. now apply IHs.
  + now rewrite (local_invert t _ _ Hk).
  + clear x y Hx Hy Hxy. intro z. specialize (Hle (/k * z + t)).
    revert n Hn Hle. induction s; simpl; intros n Hn Hle.
      rewrite multiset_nil, M.empty_spec. omega.
      rewrite multiset_cons in *. destruct (Rdec (k * (a - t)) z) as [| Hneq].
      - subst z. assert (/ k * (k * (a - t)) + t = a) by now field. rewrite H in *.
        rewrite M.add_spec in *. destruct n. omega. rewrite plus_comm in *. simpl in *.
        apply le_n_S. apply le_S_n in Hle. destruct n.
          assert (Hnin : ~In a s). { rewrite <- multiset_In. omega. }
          assert (Hin : ~In (k * (a -t)) (map (fun x : R => k * (x - t)) s)).
          { rewrite in_map_iff. intros [x [Heq Hin]]. apply Hnin. rewrite local_invert in Heq; trivial. now subst a. }
          rewrite <- multiset_In in Hin. omega.
          apply IHs. omega. assumption.
      - assert (a <> /k * z + t).
        { intro Habs. rewrite <- (local_invert t _ _ Hk) in Habs. apply Hneq. rewrite Habs. now field. }
        rewrite M.add_spec' in *; trivial. now apply IHs.
Qed.

Theorem robogram_homothecy_invariant : forall k t pos, k <> 0 ->
  robogram (nominal_spectrum (⟦k, t⟧ pos)) = k * (robogram (nominal_spectrum (⟦1, t⟧ pos))).
Proof.
intros k t pos Hk. unfold robogram.
destruct (majority_stack (nominal_spectrum  (⟦k, t⟧ pos))) eqn:Hmaj.
* rewrite majority_stack_NoResult_spec in Hmaj. elim (nominal_spectrum_nil _ Hmaj).
* assert (Hl : l = k * ((/k * l + t) - t)) by now field.
  rewrite Hl, majority_stack_Valid_similarity in Hmaj; trivial. clear Hl.
  destruct (majority_stack (nominal_spectrum  (⟦1, t⟧ pos))) eqn:Hmaj1.
  - rewrite majority_stack_NoResult_spec in Hmaj1. elim (nominal_spectrum_nil _ Hmaj1).
  - replace l0 with (1 * (l0 + t - t)) in Hmaj1 by ring. rewrite majority_stack_Valid_similarity in Hmaj1.
    rewrite Hmaj1 in Hmaj. inversion Hmaj. subst n0. clear Hmaj1 Hmaj.
    setoid_rewrite Rplus_comm in H0. apply Rplus_eq_reg_l in H0. subst l0. now field. apply R1_neq_R0.
  - rewrite majority_stack_Invalid_similarity in Hmaj1; try exact R1_neq_R0.
    rewrite Hmaj1 in Hmaj. discriminate Hmaj.
* rewrite majority_stack_Invalid_similarity in Hmaj; trivial.
  rewrite <- (@majority_stack_Invalid_similarity 1) in Hmaj; try exact R1_neq_R0. rewrite Hmaj.
  repeat rewrite nominal_spectrum_similarity.
  repeat rewrite multiset_map; try apply similarity_injective; try (apply R1_neq_R0 || assumption).
  assert (Hlen : length (M.support (M.map (fun x : R => k * (x - t)) (multiset (nominal_spectrum pos))))
               = length (M.support (M.map (fun x : R => 1 * (x - t)) (multiset (nominal_spectrum pos))))).
  { now do 2 rewrite M.map_support, map_length. }
  setoid_rewrite Hlen at 1.
  destruct (beq_nat (length (M.support (M.map (fun x : R => 1 * (x - t)) (multiset (nominal_spectrum pos))))) 3)
  eqn:H3.
  assert (div2 3 = 1%nat) by reflexivity.
  + repeat rewrite M.map_support.
    rewrite (@sort_map_increasing (fun x => 1 * (x - t))); try now apply similarity_increasing; lra.
    replace 0 with (1 * (t - t)) by ring. rewrite (map_nth (fun x => 1 * (x - t))). ring_simplify.
    symmetry in H3. apply beq_nat_eq in H3. rewrite <- Hlen in H3. rewrite <- H, <- H3.
    rewrite M.map_support. rewrite (Permutation_length (Permuted_sort _)).
    destruct (Rlt_le_dec k 0).
    - rewrite (@sort_map_decreasing (fun x => k * (x - t))); try now apply similarity_decreasing; lra.
      rewrite rev_length, odd_middle.
        rewrite map_length. replace (1 * (t - t)) with (k * (t - t)) by ring.
        rewrite (map_nth (fun x => k * (x - t))). now rewrite Rmult_minus_distr_l.
        rewrite map_length, <- (Permutation_length (Permuted_sort _)). SearchAbout List.map Proper.
        rewrite M.map_support, map_length in H3. unfold M.elt in H3. rewrite H3. now exists 1%nat.
    - rewrite (@sort_map_increasing (fun x => k * (x - t))); try now apply similarity_increasing; lra.
      rewrite map_length. replace (1 * (t - t)) with (k * (t - t)) by ring.
      rewrite (map_nth (fun x => k * (x - t))). now rewrite Rmult_minus_distr_l.
  + do 2 rewrite <- nominal_spectrum_similarity.
  assert (H0 : forall k, k * (t - t) = 0) by (intro; ring). rewrite <- (H0 k) at 1. rewrite <- (H0 1) at 2.
  repeat rewrite is_extremal_similarity_invariant; exact R1_neq_R0 || trivial.
  destruct (is_extremal t (nominal_spectrum pos)). ring.
  repeat rewrite extreme_center_similarity_invariant; exact R1_neq_R0 || trivial. ring.
Qed.
Print Assumptions robogram_homothecy_invariant.

(** **  General simplification lemmas for [round robogram da _] and [nominal_spectrum (round robogram da _)] **)

Lemma round_simplify : forall (da : demonic_action nG 0) pos,
  ExtEq (round robogram da (gp pos))
        (fun g => if Rdec (frame da g) 0 then gp pos g else
                  match majority_stack (nominal_spectrum pos) with
                    | NoResult => 0
                    | Valid pt n => pt
                    | Invalid n => if beq_nat (length (M.support (multiset (nominal_spectrum pos)))) 3
                                   then List.nth 1 (sort (M.support (multiset (nominal_spectrum pos)))) (gp pos g)
                                   else if is_extremal (gp pos g) (nominal_spectrum pos) then gp pos g
                                        else extreme_center (nominal_spectrum pos)
                  end).
Proof.
intros da pos g. unfold round. destruct (Rdec (frame da g) 0) as [| Hframe]. reflexivity.
rewrite (spectrum_ok da). rewrite robogram_homothecy_invariant; trivial. field_simplify; trivial. clear Hframe.
unfold robogram.
rewrite (lift_gp_equiv {| gp := gp pos; bp := locate_byz da |}). simpl. rewrite <- lift_gp_equiv.
destruct (majority_stack (nominal_spectrum pos)) eqn:Hmaj.
+ rewrite majority_stack_NoResult_spec in Hmaj. elim (nominal_spectrum_nil _ Hmaj).
+ rewrite <- majority_stack_Valid_similarity in Hmaj; try exact R1_neq_R0. rewrite Hmaj. field.
+ rewrite <- majority_stack_Invalid_similarity in Hmaj; try exact R1_neq_R0. rewrite Hmaj.
  rewrite (lift_gp_equiv {| gp := gp pos; bp := locate_byz da |}). simpl. rewrite <- lift_gp_equiv.
  assert (Hinj : injective eq eq (fun x => 1 * (x - gp pos g))) by (apply similarity_injective; lra).
  rewrite nominal_spectrum_similarity, multiset_map, M.map_support, map_length; trivial.
  assert (H0 : 1 * (gp pos g - gp pos g) = 0) by ring.
  destruct (beq_nat (length (M.support (multiset (nominal_spectrum pos)))) 3) eqn:H3.
  - rewrite nominal_spectrum_similarity, multiset_map, M.map_support; trivial.
    rewrite (lift_gp_equiv {| gp := gp pos; bp := locate_byz da |}). simpl. rewrite <- lift_gp_equiv.
    rewrite sort_map_increasing; try now apply similarity_increasing; lra.
    rewrite <- H0 at 1. rewrite (map_nth (fun x => 1 * (x - gp pos g))). field.
  - rewrite <- H0 at 1. rewrite is_extremal_similarity_invariant; try exact R1_neq_R0.
    rewrite (lift_gp_equiv {| gp := gp pos; bp := locate_byz da |}). simpl. rewrite <- lift_gp_equiv.
    destruct (is_extremal (gp pos g) (nominal_spectrum pos)). field.
    rewrite extreme_center_similarity_invariant; try exact R1_neq_R0. field_simplify.
    rewrite (lift_gp_equiv {| gp := gp pos; bp := locate_byz da |}). simpl. now rewrite <- lift_gp_equiv.
Qed.
Print Assumptions round_simplify.

(* Definitions of two subsets of robots: active and idle ones. *)
Definition idle nG (da : demonic_action nG 0) := filter (fun x => Rdec_bool (frame da x) 0) (Gnames nG).
Definition active nG (da : demonic_action nG 0) := filter (fun x => negb (Rdec_bool (frame da x) 0)) (Gnames nG).

Theorem nominal_spectrum_round_simplify : forall (da : demonic_action nG 0) pos,
  Permutation
    (nominal_spectrum (lift_gp (round robogram da (gp pos))))
    (* robots that are not activated this turn *)
    (map (gp pos) (idle da)
    (* robots that are activated this turn *)
    ++ map (fun g => match majority_stack (nominal_spectrum pos) with
                       | NoResult => 0
                       | Valid pt n => pt
                       | Invalid n => if beq_nat (length (M.support (multiset (nominal_spectrum pos)))) 3
                                      then List.nth 1 (sort (M.support (multiset (nominal_spectrum pos)))) (gp pos g)
                                      else if is_extremal (gp pos g) (nominal_spectrum pos) then gp pos g
                                           else extreme_center (nominal_spectrum pos)
                     end)
           (active da)).
Proof.
intros da pos. rewrite round_simplify. unfold lift_gp. rewrite (if_Rdec_ExtEq 0 (frame da)).
rewrite nominal_spectrum_combineG. simpl. rewrite app_nil_r, partition_filter. reflexivity.
Qed.

(** ** Simplification of the global position in the three cases of the robogram **)

(** When there is a majority stack, it grows and all other stacks wither. **)
Theorem Stack_at_grow :  forall pt pos (da : demonic_action nG 0),
  Stack_at pt pos -> (M.multiplicity pt (multiset (nominal_spectrum (lift_gp (round robogram da (gp pos)))))
                     >= M.multiplicity pt (multiset (nominal_spectrum pos)))%nat.
Proof.
intros pt pos da Hstack.
(* we first simplify the lhs *)
rewrite <- majority_stack_spec in Hstack. destruct Hstack as [m Hstack].
rewrite nominal_spectrum_round_simplify, Hstack. rewrite multiset_app, M.union_spec.
(* Same thing for the rhs *)
rewrite (lift_gp_equiv pos), <- (if_ExtEq (fun g => Rdec_bool (frame da g) 0) (gp pos)) at 2.
unfold lift_gp. rewrite (nominal_spectrum_combineG (fun g => Rdec_bool (frame da g) 0)).
rewrite partition_filter. repeat rewrite multiset_app, M.union_spec.
change (filter (fun g : G nG => Rdec_bool (frame da g) 0) (Gnames nG)) with (idle da).
change (filter (fun g : G nG => negb (Rdec_bool (frame da g) 0)) (Gnames nG)) with (active da).
simpl; rewrite multiset_nil, M.empty_spec, plus_0_r.
(* Non activated robots are in the same locations in both positions so we can simplify them out *)
apply plus_le_compat. reflexivity.
(* Among those that are activated, at most all can be at position pt *)
rewrite map_cst, multiset_alls, M.singleton_spec.
Rdec. rewrite <- (map_length (gp pos)), <- cardinal_multiset. apply M.cardinal_lower.
Qed.
Print Assumptions Stack_at_grow.

(* This proof follows the exact same structure.
   It is simpler because among robots that are activated, none goes to pt' <> pt *)
Theorem Stack_at_wither : forall pt pt' pos (da : demonic_action nG 0), pt <> pt' ->
  Stack_at pt pos -> (M.multiplicity pt' (multiset (nominal_spectrum (lift_gp (round robogram da (gp pos)))))
                     <= M.multiplicity pt' (multiset (nominal_spectrum pos)))%nat.
Proof.
intros pt pt' pos da Hdiff Hstack.
(* we first simplify the lhs *)
rewrite <- majority_stack_spec in Hstack. destruct Hstack as [m Hstack].
rewrite nominal_spectrum_round_simplify, Hstack. repeat rewrite multiset_app, M.union_spec.
(* Same thing for the rhs *)
rewrite (lift_gp_equiv pos), <- (if_ExtEq (fun g => Rdec_bool (frame da g) 0) (gp pos)) at 2.
unfold lift_gp. rewrite (nominal_spectrum_combineG (fun g => Rdec_bool (frame da g) 0)).
rewrite partition_filter. repeat rewrite multiset_app, M.union_spec.
change (filter (fun g : G nG => Rdec_bool (frame da g) 0) (Gnames nG)) with (idle da).
change (filter (fun g : G nG => negb (Rdec_bool (frame da g) 0)) (Gnames nG)) with (active da).
simpl; rewrite multiset_nil, M.empty_spec, plus_0_r.
(* non activated robots are in the same locations in both positions so we can simplify them out *)
apply plus_le_compat. reflexivity.
(* No activated robot goes to pt' as pt' <> pt *)
rewrite map_cst, multiset_alls, M.singleton_spec.
Rdec_full. now symmetry in Heq. omega.
Qed.

(** As a consequence, whenever there is a majority stack, it remains forever so. **)
Theorem Stack_at_forever : forall pt pos (da : demonic_action nG 0),
  Stack_at pt pos -> Stack_at pt (lift_gp (round robogram da (gp pos))).
Proof.
intros pt pos da Hstack. assert (Hs := Hstack). destruct Hs as [n [? Hpos]].
eexists. split. reflexivity. intros pt' Hdiff.
eapply le_lt_trans. apply Stack_at_wither with pt; trivial.
eapply lt_le_trans. apply Hpos. assumption.
subst n. apply Stack_at_grow. assumption.
Qed.


Existing Instance range_compat.
Existing Instance nominal_spectrum_compat.
Existing Instance lift_gp_compat.


(** If we have three stacks, everyone goes to the middle one. **)
Lemma round_simplify_Three : forall (da : demonic_action nG 0) pos n,
  majority_stack (nominal_spectrum pos) = Invalid n ->
  length (M.support (multiset (nominal_spectrum pos))) = 3%nat ->
  ExtEq (round robogram da (gp pos))
        (fun g => if Rdec (frame da g) 0 then gp pos g
                  else nth 1 (sort (M.support (multiset (nominal_spectrum pos)))) 0).
Proof.
intros da pos n Hmaj H3.
rewrite round_simplify; trivial. intro g. Rdec_full. reflexivity.
rewrite Hmaj, H3. rewrite <- beq_nat_refl.
apply nth_indep. unfold M.elt in H3. rewrite <- (Permutation_length (Permuted_sort _)), H3. omega.
Qed.

(** If we do not have a majority stack and have more than three stacks,
    then all activated robots except the ones on the extreme positions [x] and [t] go to [(x + t) / 2]. **)
Lemma round_simplify_Generic : forall (da : demonic_action nG 0) pos n x t,
  majority_stack (nominal_spectrum pos) = Invalid n ->
  range x t (nominal_spectrum pos) -> In x (nominal_spectrum pos) -> In t (nominal_spectrum pos) ->
  length (M.support (multiset (nominal_spectrum pos))) <> 3%nat ->
  ExtEq (round robogram da (gp pos))
        (fun g => if Rdec (frame da g) 0 then gp pos g else
                  if Rdec (gp pos g) x then x else if Rdec (gp pos g) t then t else (x + t) / 2).
Proof.
intros da pos n min max Hmaj Hrange Hmin Hmax H3.
rewrite round_simplify; trivial. intro g. Rdec_full. reflexivity.
rewrite Hmaj. rewrite <- beq_nat_false_iff in H3. rewrite H3.
rewrite range_split in Hrange. destruct Hrange as [Hrange1 Hrange2]. rewrite Forall_forall in Hrange1, Hrange2.
assert (Hhd : forall d, hd d (sort (nominal_spectrum pos)) = min).
{ intro d. destruct (sort (nominal_spectrum pos)) eqn:Hs.
  - elim (nominal_spectrum_nil pos). apply Permutation_nil. rewrite <- Hs. symmetry. apply Permuted_sort.
  - apply Rle_antisym.
      rewrite <- Hs. now apply sort_min.
      apply Hrange1. apply (Permutation_in _ (symmetry (Permuted_sort _))). rewrite Hs. now left. }
assert (Hlast : forall d, last (sort (nominal_spectrum pos)) d = max).
{ intro d. destruct (sort (nominal_spectrum pos)) eqn:Hs.
  - elim (nominal_spectrum_nil pos). apply Permutation_nil. rewrite <- Hs. symmetry. apply Permuted_sort.
  - apply Rle_antisym.
      apply Hrange2. apply (Permutation_in _ (symmetry (Permuted_sort _))). rewrite Hs. apply last_In. discriminate.
      rewrite <- Hs. now apply sort_max. }
assert (Hextreme : forall pt, is_extremal pt (nominal_spectrum pos) = true <-> pt = min \/ pt = max).
{ intro pt. unfold is_extremal. repeat Rdec_full; split; intro H; try reflexivity || discriminate H.
  + clear H. left. rewrite Heq. apply Hhd.
  + clear H. right. rewrite Heq. apply Hlast.
  + exfalso. destruct H.
    - apply Hneq0. subst pt. symmetry. apply Hhd.
    - apply Hneq1. subst pt. symmetry. apply Hlast. }
destruct (is_extremal (gp pos g) (nominal_spectrum pos)) eqn:Hext.
  rewrite Hextreme in Hext. destruct Hext; repeat Rdec_full; assumption || contradiction.
  repeat Rdec_full.
  - apply (@or_introl _ (gp pos g = max)) in Heq. rewrite <- Hextreme in Heq.
    rewrite Heq in Hext. discriminate Hext.
  - apply (@or_intror (gp pos g = min)) in Heq. rewrite <- Hextreme in Heq.
    rewrite Heq in Hext. discriminate Hext.
  - unfold extreme_center. now rewrite Hhd, Hlast.
Qed.

(** If we have no majority stack (hence more than one stack), then the extreme locations are different. **)
Lemma min_max_diff :
  forall l n x t, majority_stack l = Invalid n -> range x t l -> In x l -> In t l -> x <> t.
Proof.
intros l n x t Hl Hrange Hx Ht Heq. subst t.
rewrite range_split in Hrange. destruct Hrange as [Hrange1 Hrange2]. rewrite Forall_forall in Hrange1, Hrange2.
assert (l = alls x (length l)).
{ rewrite <- (alls_carac x l). intros y Hy. now apply Rle_antisym; apply Hrange1 || apply Hrange2. }
rewrite H, majority_stack_alls in Hl. discriminate Hl.
intro Habs. apply length_0 in Habs. subst l. simpl in Hl. rewrite majority_stack_nil in Hl. discriminate Hl.
Qed.


Theorem Will_stack : forall da pos, ~forbidden pos -> ~Stack pos ->
  Stack (lift_gp (round (B:=Zero) robogram da pos.(gp))).
Proof.
intros da pos Hok Hyet.
rewrite <- majority_stack_spec in Hyet.
assert (exists n, majority_stack (nominal_spectrum pos) = Invalid n).
{ destruct (majority_stack (nominal_spectrum pos)) eqn:Hpos.
  - rewrite majority_stack_NoResult_spec in Hpos. rewrite nominal_spectrum4 in Hpos. discriminate Hpos.
  - elim Hyet. exists l. exists n. reflexivity.
  - exists n. reflexivity. }
destruct H as [n Hn]. clear Hyet.
(* We express more directly the position after one round *)
assert (Heq : ExtEq (round robogram da (gp pos))
             (fun g => if is_extremal (gp pos g) (nominal_spectrum pos)
                       then gp pos g else extreme_center (nominal_spectrum pos))).
{ etransitivity. apply round_simplify. assumption.
  intro g. destruct (Rdec (frame da g) 0) as [| Hframe]. now elim (active da g).
  now rewrite Hn. }
assert (Hl : length (sort (nominal_spectrum pos)) = 4%nat).
{ rewrite (Permutation_length (symmetry (Permuted_sort _))). now rewrite nominal_spectrum4. }
assert (Hperm := Permuted_sort (nominal_spectrum pos)).
assert (Hsort := Sorted_sort (nominal_spectrum pos)).
destruct (sort (nominal_spectrum pos)) as [| x [| y [| z [| t [| ]]]]] eqn:Hs; try discriminate Hl. clear Hl.
inversion_clear Hsort. inversion_clear H. inversion_clear H1. clear H. unfold is_true in *. rewrite Rleb_spec in *.
assert (Hd := Invalid_spectrum_simplify Hok Hn).
rewrite Hperm in Hd. inversion_clear Hd. inversion_clear H1. inversion_clear H5.
assert (Hxy : x < y). { apply Rle_neq_lt. assumption. intro. subst y. apply H. now left. }
assert (Hyz : y < z). { apply Rle_neq_lt. assumption. intro. subst y. apply H4. now left. }
assert (Hzt : z < t). { apply Rle_neq_lt. assumption. intro. subst z. apply H1. now left. }
clear H H0 H1 H2 H3 H4 H6.
assert (x <> t) by lra. assert (x <> (x + t) / 2) by lra. assert (t <> (x + t) / 2) by lra.
assert (Hperm2 : Permutation (nominal_spectrum (lift_gp (round robogram da (gp pos))))
                             (x :: (x + t) / 2 :: (x + t) / 2 :: t :: nil)).
{ apply (@nominal_spectrum_simplify da pos n x t Hok Hn).
  - rewrite range_split. do 2 rewrite Forall_forall. split; intros a Hin.
      change x with (hd 0 (x :: y :: z :: t :: nil)). rewrite <- Hs. now apply sort_min.
      change t with (last (x :: y :: z :: t :: nil) 0). rewrite <- Hs. now apply sort_max.
  - rewrite Hperm. now left.
  - rewrite Hperm. now do 3 right; left. }
exists (extreme_center (nominal_spectrum pos)). exists 2%nat. split.
+ unfold is_extremal, extreme_center. rewrite Hs, Hperm2. simpl.
  repeat rewrite multiset_cons.
  now rewrite M.add_spec', M.add_spec, M.add_spec, M.add_spec', multiset_nil, M.empty_spec.
+ unfold is_extremal, extreme_center. intro pt. rewrite Hs, Hperm2. simpl. repeat rewrite multiset_cons.
  intro Hy. destruct (Rdec x pt).
    subst pt. now rewrite M.add_spec, M.add_spec', M.add_spec', M.add_spec', multiset_nil, M.empty_spec; auto.
    destruct (Rdec t pt).
      subst pt. now rewrite M.add_spec', M.add_spec', M.add_spec', M.add_spec, multiset_nil, M.empty_spec; auto.
      now rewrite M.add_spec', M.add_spec', M.add_spec', M.add_spec', multiset_nil, M.empty_spec; auto.
Qed.


Lemma gathered_at_PosEq : forall (gp : Four -> R) pt, gathered_at gp pt -> ExtEq gp (fun _ => pt).
Proof. intros gp pt Hgather. intro n. apply Hgather. Qed.

Theorem gathered_at_forever : forall pt gp (da : demonic_action Four Zero),
  gathered_at gp pt -> gathered_at (round robogram da gp) pt.
Proof.
intros pt gp [] Hgather. unfold round. simpl.
intro g. destruct (Rdec (frame g) 0). now apply Hgather.
rewrite Hgather. rewrite <- Rplus_0_r. f_equal. rewrite <- (Rmult_0_r (/ frame g)). f_equal.
unfold similarity. simpl. rewrite (spectrum_exteq g _ (lift_gp (fun _ => 0))). unfold robogram.
assert (spectrum_of g (lift_gp (fun _ => 0)) = alls 0 4) as Heq.
{ apply Permutation_alls.
  transitivity (nominal_spectrum (lift_gp (fun _ : Four => 0))).
    apply spectrum_ok.
    now rewrite nominal_spectrum_alls. }
rewrite Heq. rewrite is_forbidden_alls. unfold majority_stack.
rewrite multiset_alls, M.fold_singleton; simpl; try omega. reflexivity. now repeat intro; subst.
split; (now intros []) || intro x; simpl. rewrite Hgather, Rminus_diag_eq. now rewrite Rmult_0_r. reflexivity.
Qed.

Lemma gathered_at_Gather : forall pt (d : demon Four Zero) gp, gathered_at gp pt ->
  Gather pt (execute robogram d gp).
Proof.
intro pt. cofix gather. intros d gp Hgather. constructor. apply Hgather.
rewrite execute_tail. apply gather. now apply gathered_at_forever.
Qed.

Theorem stack_gathered_at : forall (da : demonic_action Four Zero) gp pt n, ~forbidden (lift_gp gp) ->
  majority_stack (nominal_spectrum (lift_gp gp)) = Valid pt n ->
  gathered_at (round robogram da gp) pt.
Proof.
intros da gp pt n Hok Hstack g. unfold round.
pose (s := spectrum_of da g ((⟦frame da g, gp g⟧) {| gp := gp; bp := locate_byz da |})). fold s.
destruct (Rdec (frame da g) 0).
  now elim (active da g). (* Stalling case *)
  unfold robogram.
  assert (Hfor : is_forbidden s = false).
  { unfold s. rewrite spectrum_ok. rewrite is_forbidden_false. intro Habs. apply Hok.
    revert Habs. setoid_rewrite lift_gp_equiv at 2. simpl. apply forbidden_similarity_invariant. }
  rewrite Hfor. clear Hfor.
  assert (Hperm : Permutation s (nominal_spectrum (⟦frame da g, gp g⟧ {| gp := gp; bp := locate_byz da |})))
  by apply da.(spectrum_ok).
  rewrite <- is_forbidden_false in Hok. rewrite Hperm. setoid_rewrite lift_gp_equiv at 2.
  simpl. rewrite <- (majority_stack_Valid_similarity (gp g) _ _ _ (active da g)) in Hstack.
  rewrite Hstack. now field.
Qed.

Corollary stack_sol : forall k (d : demon Four Zero), kFair k d ->
  forall gp : Four -> R, ~forbidden (lift_gp gp) ->
  Stack (lift_gp gp) ->
  exists pt, WillGather pt (execute robogram d gp).
Proof.
intros k [da d] Hfair gp Hok Hstack.
assert (Hs := Hstack). rewrite <- majority_stack_spec in Hs. destruct Hs as [pt [n Hpt]].
exists pt. constructor 2. constructor 1.
rewrite execute_tail. cofix gathered. constructor. clear gathered. simpl. now apply stack_gathered_at with n.
(* back to coinduction *)
apply gathered. (* ill-formed recursive definition: we cannot use stack_gathered *)
Admitted.

Theorem never_forbidden : forall (da : demonic_action Four Zero) pos,
  ~forbidden pos -> ~forbidden (lift_gp (round robogram da pos.(gp))).
Proof.
intros da pos Hok.
(* We express more directly the position after one round *)
assert (Heq : ExtEq (round robogram da (gp pos))
                    (fun g : Four => match majority_stack (nominal_spectrum pos) with
                                       | NoResult => 0
                                       | Valid pt n => pt
                                       | Invalid n => if is_extremal (gp pos g) (nominal_spectrum pos)
                                                      then gp pos g else extreme_center (nominal_spectrum pos)
                                     end)).
{ etransitivity. apply round_simplify. assumption.
  intro g. destruct (Rdec (frame da g) 0). now elim (active da g). reflexivity. }
destruct (majority_stack (nominal_spectrum pos)) eqn:Hmaj.
+ rewrite majority_stack_NoResult_spec, nominal_spectrum4 in Hmaj. discriminate Hmaj.
+ intros [x [y [m [Hxy Hperm]]]]. rewrite Heq, nominal_spectrum_alls in Hperm.
  symmetry in Hperm. apply Permutation_alls in Hperm.
  destruct m as [| [| [| m]]]; simpl in Hperm; try discriminate Hperm.
    inversion Hperm. subst. now apply Hxy.
    cut (6 <= 4)%nat. omega. change 4%nat with (length (l :: l :: l :: l :: nil)) at 2. rewrite <- Hperm.
    simpl. rewrite app_length. simpl. omega.
+ intros [x [y [m [Hxy Hperm]]]].
  assert (Hm : m = 2%nat).
  { apply Permutation_length in Hperm. rewrite nominal_spectrum4, app_length in Hperm. simpl in *.
    destruct m as [| [| [| m]]]; simpl in *; try discriminate Hperm. reflexivity. omega. }
  subst m. simpl in *. destruct (Rle_lt_dec x y).
    rewrite (@nominal_spectrum_simplify da pos n x y Hok Hmaj) in Hperm.
    - apply Permutation_cons_inv in Hperm. apply Permutation_rev' in Hperm. simpl in Hperm.
      apply Permutation_cons_inv in Hperm.
      change ((x + y) / 2 :: (x + y) / 2 :: nil) with (alls ((x + y) / 2) 2) in Hperm.
      symmetry in Hperm. apply Permutation_alls in Hperm. inversion Hperm. do 2 rewrite <- H0 in H1. contradiction.
    - 
Admitted.

Theorem meeting4 :
  forall d : demon Four Zero, forall k, kFair k d -> solGathering robogram d.
Proof.
intros d k Hfair gp Hok.
destruct (majority_stack (nominal_spectrum (lift_gp gp))) as [| r n | n] eqn:Hdup.
  (* there is no robot *)
  rewrite majority_stack_NoResult_spec in Hdup. rewrite nominal_spectrum4 in Hdup. discriminate Hdup.
  (* there is a stack *)
  apply (stack_sol Hfair Hok). rewrite <- majority_stack_spec. now exists r; exists n.
  (* there is not stack, it will be created at the next step *)
  inversion_clear Hfair as [_ Htfair].
  destruct (stack_sol Htfair (@never_forbidden (demon_head d) _ Hok)) as [pt Hpt].
    apply Will_stack. assumption. rewrite <- majority_stack_spec.
    intros [x [m Habs]]. rewrite Hdup in Habs. discriminate Habs.
    exists pt. constructor 2. rewrite execute_tail. exact Hpt.
Qed.
Print Assumptions meeting4.

