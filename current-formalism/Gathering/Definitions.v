Require Import Arith.Div2.
Require Import Omega.
Require Import Equalities.
Require Import Pactole.Preliminary.
Require Import Pactole.Robots.
Require Import Pactole.Configurations.
Require Import Pactole.RealMetricSpace.
Require Import Pactole.Similarity.
Require Pactole.CommonRealFormalism.
Require Pactole.RigidFormalism.
Require Import Pactole.MultisetSpectrum.
Require Import Morphisms.


Close Scope R_scope.
Set Implicit Arguments.


Module GatheringDefs(Loc : RealMetricSpace)(N : Size).

(** The spectrum is a multiset of positions *)
Module Info := Unit(Loc).
Module Names := Robots.Make(N).
Module Config := Configurations.Make(Loc)(N)(Names)(Info).
Module Spect := MultisetSpectrum.Make(Loc)(N)(Names)(Info)(Config).

Notation "s [ pt ]" := (Spect.multiplicity pt s) (at level 5, format "s [ pt ]").
Notation "!!" := Spect.from_config (at level 1).
Add Search Blacklist "Spect.M" "Ring".

Module Export Common := CommonRealFormalism.Make(Loc)(N)(Names)(Info)(Config)(Spect).
Module Export Rigid := RigidFormalism.Make(Loc)(N)(Names)(Info)(Config)(Spect)(Common).

Module Sim := Common.Sim.

(** There is no meaningful information inside Info.t. *)
Lemma no_info : forall rc1 rc2, Loc.eq (Config.loc rc1) (Config.loc rc2) -> Config.eq_RobotConf rc1 rc2.
Proof. intros [? []] [? []] Heq; split; simpl in *; auto. Qed.


(** [gathered_at conf pt] means that in configuration [conf] all good robots
    are at the same location [pt] (exactly). *)
Definition gathered_at (pt : Loc.t) (conf : Config.t) :=
           forall g : Names.G, Loc.eq (Config.loc (conf (Good g))) pt.

(** [Gather pt e] means that at all rounds of (infinite) execution [e],
    robots are gathered at the same position [pt]. *)
Definition Gather (pt: Loc.t) (e : execution) : Prop := Streams.forever (Streams.instant (gathered_at pt)) e.

(** [WillGather pt e] means that (infinite) execution [e] is *eventually* [Gather]ed. *)
Definition WillGather (pt : Loc.t) (e : execution) : Prop := Streams.eventually (Gather pt) e.

(** When all robots are on two towers of the same height,
    there is no solution to the gathering problem.
    Therefore, we define these configurations as [invalid]. *)
Definition invalid (config : Config.t) :=
  Nat.Even N.nG /\ N.nG >=2 /\ let m := Spect.from_config(config) in
  exists pt1 pt2, ~Loc.eq pt1 pt2 /\ m[pt1] = Nat.div2 N.nG /\ m[pt2] = Nat.div2 N.nG.

(** [FullSolGathering r d] means that any possible (infinite)
    execution, generated by demon [d] and robogram [r] and any intial
    configuration, will *eventually* be [Gather]ed.
    This is the statement used for the impossiblity proof. *)
Definition FullSolGathering (r : robogram) (d : demon) :=
  forall config, exists pt : Loc.t, WillGather pt (execute r d config).

(** [ValidsolGathering r d] means that any possible (infinite)
    execution, generated by demon [d] and robogram [r] and any intial
    configuration not [invalid], will *eventually* be [Gather]ed.
    This is the statement used for the correctness proof of the algorithms. *)
Definition ValidSolGathering (r : robogram) (d : demon) :=
  forall config, ~invalid config -> exists pt : Loc.t, WillGather pt (execute r d config).


(** Compatibility properties *)
Instance gathered_at_compat : Proper (Loc.eq ==> Config.eq ==> iff) gathered_at.
Proof.
intros pt1 pt2 Hpt config1 config2 Hconfig. unfold gathered_at. 
split; intros H g; specialize (H g); specialize (Hconfig (Good g));
destruct (config2 (Good g)) eqn:c2, (config1 (Good g)) eqn:c1 in *.
rewrite <- Hpt, <- H; unfold Config.eq, Config.eq_RobotConf in Hconfig;
intuition. rewrite Hpt, <- H. unfold Config.eq, Config.eq_RobotConf in Hconfig; intuition.
Qed.

Instance Gather_compat : Proper (Loc.eq ==> eeq ==> iff) Gather.
Proof.
intros pt1 pt2 Hpt. apply Streams.forever_compat, Streams.instant_compat.
intros config1 config2 Hconfig. now rewrite Hpt, Hconfig.
Qed.

Instance WillGather_compat : Proper (Loc.eq ==> eeq ==> iff) WillGather.
Proof. intros pt1 pt2 Hpt. apply Streams.eventually_compat. now apply Gather_compat. Qed.

Instance invalid_compat : Proper (Config.eq ==> iff) invalid.
Proof.
intros ? ? Heq. split; intros [HnG [Hle [pt1 [pt2 [Hneq Hpt]]]]]; repeat split; trivial ||
exists pt1; exists pt2; split; try rewrite Heq in *; trivial.
Qed.

(** **  Generic properties  **)

Lemma spect_non_nil : 2 <= N.nG -> forall conf, ~Spect.eq (!! conf) Spect.empty.
Proof.
intros HnG conf Heq.
unfold Spect.from_config in Heq.
rewrite Spect.multiset_empty in Heq.
assert (Hlgth:= Config.list_length conf).
erewrite <- List.map_length, Heq in Hlgth.
simpl in *.
omega.
Qed.

End GatheringDefs.
