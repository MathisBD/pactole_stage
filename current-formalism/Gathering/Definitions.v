Require Import Arith.Div2.
Require Import Omega.
Require Import Equalities.
Require Import Pactole.Preliminary.
Require Import Pactole.Robots.
Require Import Pactole.Configurations.
Require Import Pactole.RealMetricSpace.
Require Import Pactole.Similarity.
Require Pactole.CommonRealFormalism.
Require Pactole.RigidFormalism.
Require Import Pactole.MultisetSpectrum.
Require Import Morphisms.


Close Scope R_scope.
Set Implicit Arguments.


Module GatheringDefs(Loc : RealMetricSpace)(N : Size).

(** The spectrum is a multiset of positions *)
Module Info := Unit(Loc).
Module Names := Robots.Make(N).
Module Config := Configurations.Make(Loc)(N)(Names)(Info).
Module Spect := MultisetSpectrum.Make(Loc)(N)(Names)(Info)(Config).

Notation "s [ pt ]" := (Spect.multiplicity pt s) (at level 5, format "s [ pt ]").
Notation "!!" := Spect.from_config (at level 1).
Add Search Blacklist "Spect.M" "Ring".

Module Export Common := CommonRealFormalism.Make(Loc)(N)(Names)(Info)(Config)(Spect).
Module Export Rigid := RigidFormalism.Make(Loc)(N)(Names)(Info)(Config)(Spect)(Common).


(** There is no meaningful information inside Info.t. *)
Lemma no_info : forall rc1 rc2, Loc.eq (Config.loc rc1) (Config.loc rc2) -> Config.eq_RobotConf rc1 rc2.
Proof. intros [? []] [? []] Heq; split; simpl in *; auto. Qed.

(** Not true in general as the info may change even if the robot does not move. *)
Lemma no_moving_same_conf : forall r da config,
  moving r da config = List.nil -> Config.eq (round r da config) config.
Proof.
intros r da config Hmove id. apply no_info.
destruct (Loc.eq_dec (Config.loc (round r da config id)) (Config.loc (config id))) as [Heq | Heq]; trivial; [].
rewrite <- moving_spec, Hmove in Heq. inversion Heq.
Qed.

(** The full information for a robot only depends on its location. *)
Definition mk_info l := {| Config.loc := l; Config.info := tt |}.


(** [gathered_at conf pt] means that in configuration [conf] all good robots
    are at the same location [pt] (exactly). *)
Definition gathered_at (pt : Loc.t) (conf : Config.t) :=
           forall g : Names.G, Loc.eq (Config.loc (conf (Good g))) pt.

(** [Gather pt e] means that at all rounds of (infinite) execution [e],
    robots are gathered at the same position [pt]. *)
Definition Gather (pt: Loc.t) (e : execution) : Prop := Streams.forever (Streams.instant (gathered_at pt)) e.

(** [WillGather pt e] means that (infinite) execution [e] is *eventually* [Gather]ed. *)
Definition WillGather (pt : Loc.t) (e : execution) : Prop := Streams.eventually (Gather pt) e.

(** When all robots are on two towers of the same height,
    there is no solution to the gathering problem.
    Therefore, we define these configurations as [invalid]. *)
Definition invalid (config : Config.t) :=
  Nat.Even N.nG /\ N.nG >=2 /\ let m := Spect.from_config(config) in
  exists pt1 pt2, ~Loc.eq pt1 pt2 /\ m[pt1] = Nat.div2 N.nG /\ m[pt2] = Nat.div2 N.nG.

(** [FullSolGathering r d] means that any possible (infinite)
    execution, generated by demon [d] and robogram [r] and any intial
    configuration, will *eventually* be [Gather]ed.
    This is the statement used for the impossiblity proof. *)
Definition FullSolGathering (r : robogram) (d : demon) :=
  forall config, exists pt : Loc.t, WillGather pt (execute r d config).

(** [ValidsolGathering r d] means that any possible (infinite)
    execution, generated by demon [d] and robogram [r] and any intial
    configuration not [invalid], will *eventually* be [Gather]ed.
    This is the statement used for the correctness proof of the algorithms. *)
Definition ValidSolGathering (r : robogram) (d : demon) :=
  forall config, ~invalid config -> exists pt : Loc.t, WillGather pt (execute r d config).


(** Compatibility properties *)
Instance gathered_at_compat : Proper (Loc.eq ==> Config.eq ==> iff) gathered_at.
Proof.
intros pt1 pt2 Hpt config1 config2 Hconfig. unfold gathered_at. 
split; intros H g; specialize (H g); specialize (Hconfig (Good g));
destruct (config2 (Good g)) eqn:c2, (config1 (Good g)) eqn:c1 in *.
rewrite <- Hpt, <- H; unfold Config.eq, Config.eq_RobotConf in Hconfig;
intuition. rewrite Hpt, <- H. unfold Config.eq, Config.eq_RobotConf in Hconfig; intuition.
Qed.

Instance Gather_compat : Proper (Loc.eq ==> eeq ==> iff) Gather.
Proof.
intros pt1 pt2 Hpt. apply Streams.forever_compat, Streams.instant_compat.
intros config1 config2 Hconfig. now rewrite Hpt, Hconfig.
Qed.

Instance WillGather_compat : Proper (Loc.eq ==> eeq ==> iff) WillGather.
Proof. intros pt1 pt2 Hpt. apply Streams.eventually_compat. now apply Gather_compat. Qed.

Instance invalid_compat : Proper (Config.eq ==> iff) invalid.
Proof.
intros ? ? Heq. split; intros [HnG [Hle [pt1 [pt2 [Hneq Hpt]]]]]; repeat split; trivial ||
exists pt1; exists pt2; split; try rewrite Heq in *; trivial.
Qed.

(** **  Generic properties  **)

Lemma spect_non_nil : 2 <= N.nG -> forall conf, ~Spect.eq (!! conf) Spect.empty.
Proof.
intros HnG conf Heq.
unfold Spect.from_config in Heq.
rewrite Spect.multiset_empty in Heq.
assert (Hlgth:= Config.list_length conf).
erewrite <- List.map_length, Heq in Hlgth.
simpl in *.
omega.
Qed.

Lemma invalid_support_length : N.nB = 0 -> forall config, invalid config ->
  Spect.size (!! config) = 2.
Proof.
intros HnB conf [Heven [HsizeG [pt1 [pt2 [Hdiff [Hpt1 Hpt2]]]]]].
rewrite <- (@Spect.cardinal_total_sub_eq (Spect.add pt2 (Nat.div2 N.nG) (Spect.singleton pt1 (Nat.div2 N.nG)))
                                        (!! conf)).
+ rewrite Spect.size_add.
  destruct (Spect.In_dec pt2 (Spect.singleton pt1 (Nat.div2 N.nG))) as [Hin | Hin].
  - exfalso. rewrite Spect.In_singleton in Hin.
    destruct Hin. now elim Hdiff.
  - rewrite Spect.size_singleton; trivial.
    apply Exp_prop.div2_not_R0. apply HsizeG.
  - apply Exp_prop.div2_not_R0. apply HsizeG.
+ intro pt. destruct (Loc.eq_dec pt pt2) as [Heq2 | Heq2], (Loc.eq_dec pt pt1) as [Heq1 | Heq1].
  - rewrite Heq1, Heq2 in *. now elim Hdiff.
  - rewrite Spect.add_spec, Spect.singleton_spec.
    destruct (Loc.eq_dec pt pt2); try contradiction.
    destruct (Loc.eq_dec pt pt1); try contradiction.
    simpl.
    rewrite Heq2.
    now apply Nat.eq_le_incl.
  - rewrite Spect.add_other, Spect.singleton_spec;auto.
    destruct (Loc.eq_dec pt pt1); try contradiction.
    rewrite Heq1.
    now apply Nat.eq_le_incl.
  - rewrite Spect.add_other, Spect.singleton_spec; auto.
    destruct (Loc.eq_dec pt pt1); try contradiction.
    auto with arith.
+ rewrite Spect.cardinal_add, Spect.cardinal_singleton, Spect.cardinal_from_config.
  rewrite HnB. rewrite plus_0_r. now apply even_div2.
Qed.

End GatheringDefs.
