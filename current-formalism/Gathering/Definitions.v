(**************************************************************************)
(*   Mechanised Framework for Local Interactions & Distributed Algorithms *)
(*   P. Courtieu, L. Rieg, X. Urbain                                      *)
(*   PACTOLE project                                                      *)
(*                                                                        *)
(*   This file is distributed under the terms of the CeCILL-C licence.    *)
(*                                                                        *)
(**************************************************************************)


Require Import Arith.Div2.
Require Import Omega.
(* Require Import Morphisms. *)
Require Import SetoidDec.
Require Import Pactole.Util.Preliminary.
Require Import Pactole.Setting.
Require Import Pactole.Models.Rigid.
Require Import Pactole.Spectra.Definition.
Require Import Pactole.Spectra.MultisetSpectrum.


Close Scope R_scope.
Set Implicit Arguments.


Section GatheringDefinitions.

Context (loc : Type).
Context (loc_Setoid : Setoid loc).
Context (loc_EqDec : EqDec loc_Setoid).
Context (loc_RMS : @RealMetricSpace loc loc_Setoid loc_EqDec).
Context (RobotsDef : NamesDef).
Context (Robots : Names).
Context (FMSetOps : MMultisetInterface.FMOps loc loc_EqDec).
Context (FMSets : MMultisetInterface.FMultisetsOn loc FMSetOps).

Instance Spect : Spectrum loc := multiset_spectrum.


(* Notation "s [ pt ]" := (Spect.multiplicity pt (s : Spect.t)) (at level 5, format "s [ pt ]"). *)
Notation "!!" := spect_from_config (at level 1).
(* Add Search Blacklist "Spect.M" "Ring". *)


(** [gathered_at conf pt] means that in configuration [conf] all good robots
    are at the same location [pt] (exactly). *)
Definition gathered_at (pt : loc) (config : configuration) := forall g : G, config (Good g) == pt.

(** [Gather pt e] means that at all rounds of (infinite) execution [e],
    robots are gathered at the same position [pt]. *)
Definition Gather (pt: loc) (e : execution) : Prop := Streams.forever (Streams.instant (gathered_at pt)) e.

(** [WillGather pt e] means that (infinite) execution [e] is *eventually* [Gather]ed. *)
Definition WillGather (pt : loc) (e : execution) : Prop := Streams.eventually (Gather pt) e.

(** When all robots are on two towers of the same height,
    there is no solution to the gathering problem.
    Therefore, we define these configurations as [forbidden]. *)
Definition forbidden (config : configuration) :=
     Nat.Even nG /\ nG >=2 /\ exists pt1 pt2, ~pt1 == pt2
  /\ (!! config)[pt1] = Nat.div2 nG /\ (spect_from_config config)[pt2] = Nat.div2 nG.

(** [FullSolGathering r d] means that any possible (infinite)
    execution, generated by demon [d] and robogram [r] and any intial
    configuration, will *eventually* be [Gather]ed.
    This is the statement used for the impossiblity proof. *)

Definition FullSolGathering (r : robogram) (d : demon) :=
  forall config : configuration, exists pt : loc, WillGather pt (execute r d config).

(** [ValidsolGathering r d] means that any possible (infinite)
    execution, generated by demon [d] and robogram [r] and any intial
    configuration not [forbidden], will *eventually* be [Gather]ed.
    This is the statement used for the correctness proof of the algorithms. *)
Definition ValidSolGathering (r : robogram) (d : demon) :=
  forall config : configuration, ~forbidden config -> exists pt : loc, WillGather pt (execute r d config).


(** Compatibility properties *)
Instance gathered_at_compat : Proper (equiv ==> equiv ==> iff) gathered_at.
Proof.
intros pt1 pt2 Hpt config1 config2 Hconfig. unfold gathered_at. setoid_rewrite Hpt.
split; intros; rewrite <- (H g); idtac + symmetry; apply Hconfig.
Qed.

Instance Gather_compat : Proper (equiv ==> equiv ==> iff) Gather.
Proof.
intros pt1 pt2 Hpt. apply Streams.forever_compat, Streams.instant_compat.
intros config1 config2 Hconfig. now rewrite Hpt, Hconfig.
Qed.

Instance WillGather_compat : Proper (equiv ==> equiv ==> iff) WillGather.
Proof. intros pt1 pt2 Hpt. apply Streams.eventually_compat. now apply Gather_compat. Qed.

Instance forbidden_compat : Proper (equiv ==> iff) forbidden.
Proof.
intros ? ? Heq. split; intros [HnG [Hle [pt1 [pt2 [Hneq Hpt]]]]];
repeat split; trivial; exists pt1, pt2; split; trivial; now rewrite Heq in *.
Qed.

(** **  Generic properties  **)

Lemma spect_non_nil : 2 <= nG -> forall conf, ~!! conf == MMultisetInterface.empty.
Proof.
simpl spect_from_config. intros HnG conf Heq.
assert (Hlgth:= config_list_length conf).
assert (Hl : config_list conf = nil) by now rewrite <- multiset_empty, Heq.
rewrite Hl in Hlgth.
simpl in *.
omega.
Qed.

End GatheringDefinitions.
