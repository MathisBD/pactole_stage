To set-up a working Pactole environment, we need to define four modules.
To illustrate all this, there is an example at the end of this file building
the setting for the rigid formalism in R².

1° Define the location space in which robots evolve.
   The most general setting only requires a decidable type for locations (for
   instance when building a ring).
   Here, we are more interested in the continuous setting which requires a
   metric space but the formalism currently only supports R as the base field.
   To do so, build a module of type [Configurations.RealMetricSpaceDef].
   Then apply the [Configurations.MakeRealMetricSpace] functor to get a
   [Configurations.RealMetricSpace] module which proves some basic properties
   of metric spaces.
2° Choose the numbers of robots (both byzantine and normal ones) by building a
   module of type [Robots.Size].
   If you prefer these numbers ot stay abstract, you can either
     - assume the existence of such a module,
     - assume the existence of one of both integers (nG or nB), and build a
   [Size] module by defining the other one.
3° Choose a type of spectrum (set, multisets, etc.).
   Currently, there are four spectrum available: Sets, Multisets, and their
   conterpart with limited range of vision.
   To do so, apply the matching functor [Make] to the [Size] and
   [RealMetricSpace] modules built previously.
4° Using these three modules, we can finally define the full setting by applying
   the functor [CommonRealFormalism.Make] and then either
   [FlexibleFormalism.Make] or [RigidFormalism.Make] depending if we want a
   rigid or flexible formalism.

Now everything is defined, in particular the [robogram] type with the selected
location and spectrum types.

Let us illustrate all this with a concrete example:
(* 1° *)
Module R2def : RealMetricSpaceDef with Definition t := (R * R)%type
                                  with Definition ... .
  ...
End R2def.

(* 2° *)
Parameter nG: nat.
Module N : Size with Definition nG := nG with Definition nB := 0%nat.
  Definition nG := nG.
  Definition nB := 0%nat.
End N.

(* 3° *)
Module Spect := MultisetSpectrum.Make(R2)(N).

(* 4° *)
Module Export Common := CommonRealFormalism.Make(R2)(N)(Spect).
Module Export Rigid := RigidFormalism.Make(R2)(N)(Spect)(Common).

Notice that we use the rigid formalism, and not the flexible one.
The "Export" allows to avoid qualifying names, writing [robogram] rather than
[Rigid.robogram].
The « with Definition » in [R2def] make the body of definitions transparent to
modules which otherwise make objects abstract.  This means that in our proofs,
we will able to use the fact that the equality on R² is Coq equality [eq].

For more details (and some useful notations for R or R²), have a look at the
Gathering/Definitions.v, Gathering/InR2/R2geometry.v, and
Gathering/InR2/AlgorithmR2.v files.


Last update: March 2016
